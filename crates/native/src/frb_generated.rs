// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.10.0.

#![allow(
    non_camel_case_types,
    unused,
    non_snake_case,
    clippy::needless_return,
    clippy::redundant_closure_call,
    clippy::redundant_closure,
    clippy::useless_conversion,
    clippy::unit_arg,
    clippy::unused_unit,
    clippy::double_parens,
    clippy::let_and_return,
    clippy::too_many_arguments,
    clippy::match_single_binding,
    clippy::clone_on_copy,
    clippy::let_unit_value,
    clippy::deref_addrof,
    clippy::explicit_auto_deref,
    clippy::borrow_deref_ref,
    clippy::needless_borrow
)]

// Section: imports

use crate::*;
use flutter_rust_bridge::for_generated::byteorder::{
    NativeEndian, ReadBytesExt, WriteBytesExt,
};
use flutter_rust_bridge::for_generated::{
    transform_result_dco, Lifetimeable, Lockable,
};
use flutter_rust_bridge::{Handler, IntoIntoDart};

// Section: boilerplate

flutter_rust_bridge::frb_generated_boilerplate!(
    default_stream_sink_codec = SseCodec,
    default_rust_opaque = RustOpaqueMoi,
    default_rust_auto_opaque = RustAutoOpaqueMoi,
);
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_VERSION: &str = "2.10.0";
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_CONTENT_HASH: i32 = -40294053;

// Section: executor

pub use crate::api::FLUTTER_RUST_BRIDGE_HANDLER;

// Section: wire_funcs

fn wire__crate__api__add_ice_candidate_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "add_ice_candidate", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_peer = <RustOpaqueMoi<Arc < PeerConnection >>>::sse_decode(&mut deserializer);
let api_candidate = <String>::sse_decode(&mut deserializer);
let api_sdp_mid = <String>::sse_decode(&mut deserializer);
let api_sdp_mline_index = <i32>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>((move ||  {
                         let output_ok = crate::api::add_ice_candidate(api_peer, api_candidate, api_sdp_mid, api_sdp_mline_index)?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__add_transceiver_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "add_transceiver", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_peer = <RustOpaqueMoi<Arc < PeerConnection >>>::sse_decode(&mut deserializer);
let api_media_type = <crate::api::MediaType>::sse_decode(&mut deserializer);
let api_init = <crate::api::RtpTransceiverInit>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>((move ||  {
                         let output_ok = crate::api::add_transceiver(api_peer, api_media_type, api_init)?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__audio_processing_constraints_default_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "audio_processing_constraints_default", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok(crate::api::AudioProcessingConstraints::default())?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__clone_track_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "clone_track", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_track_id = <String>::sse_decode(&mut deserializer);
let api_peer_id = <Option<u32>>::sse_decode(&mut deserializer);
let api_kind = <crate::api::MediaType>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok(crate::api::clone_track(api_track_id, api_peer_id, api_kind))?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__create_answer_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "create_answer", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_peer = <RustOpaqueMoi<Arc < PeerConnection >>>::sse_decode(&mut deserializer);
let api_voice_activity_detection = <bool>::sse_decode(&mut deserializer);
let api_ice_restart = <bool>::sse_decode(&mut deserializer);
let api_use_rtp_mux = <bool>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>((move ||  {
                         let output_ok = crate::api::create_answer(api_peer, api_voice_activity_detection, api_ice_restart, api_use_rtp_mux)?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__create_offer_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "create_offer", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_peer = <RustOpaqueMoi<Arc < PeerConnection >>>::sse_decode(&mut deserializer);
let api_voice_activity_detection = <bool>::sse_decode(&mut deserializer);
let api_ice_restart = <bool>::sse_decode(&mut deserializer);
let api_use_rtp_mux = <bool>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>((move ||  {
                         let output_ok = crate::api::create_offer(api_peer, api_voice_activity_detection, api_ice_restart, api_use_rtp_mux)?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__create_peer_connection_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "create_peer_connection", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_cb = <StreamSink<crate::api::PeerConnectionEvent,flutter_rust_bridge::for_generated::SseCodec>>::sse_decode(&mut deserializer);
let api_configuration = <crate::api::RtcConfiguration>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>((move ||  {
                         let output_ok = crate::api::create_peer_connection(api_cb, api_configuration)?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__create_video_sink_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "create_video_sink", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_cb = <StreamSink<crate::renderer::TextureEvent,flutter_rust_bridge::for_generated::SseCodec>>::sse_decode(&mut deserializer);
let api_sink_id = <i64>::sse_decode(&mut deserializer);
let api_peer_id = <Option<u32>>::sse_decode(&mut deserializer);
let api_track_id = <String>::sse_decode(&mut deserializer);
let api_callback_ptr = <i64>::sse_decode(&mut deserializer);
let api_texture_id = <i64>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok({ crate::api::create_video_sink(api_cb, api_sink_id, api_peer_id, api_track_id, api_callback_ptr, api_texture_id); })?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__dispose_peer_connection_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "dispose_peer_connection", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_peer = <RustOpaqueMoi<Arc < PeerConnection >>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok({ crate::api::dispose_peer_connection(api_peer); })?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__dispose_track_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "dispose_track", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_track_id = <String>::sse_decode(&mut deserializer);
let api_peer_id = <Option<u32>>::sse_decode(&mut deserializer);
let api_kind = <crate::api::MediaType>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok({ crate::api::dispose_track(api_track_id, api_peer_id, api_kind); })?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__dispose_video_sink_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "dispose_video_sink", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_sink_id = <i64>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok({ crate::api::dispose_video_sink(api_sink_id); })?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__enable_fake_media_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "enable_fake_media", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok({ crate::api::enable_fake_media(); })?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__enumerate_devices_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "enumerate_devices", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end(); move |context|  {
                    transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>((move ||  {
                         let output_ok = crate::api::enumerate_devices()?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__enumerate_displays_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "enumerate_displays", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok(crate::api::enumerate_displays())?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__get_audio_processing_config_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "get_audio_processing_config", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_track_id = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>((move ||  {
                         let output_ok = crate::api::get_audio_processing_config(api_track_id)?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__get_media_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "get_media", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_constraints = <crate::api::MediaStreamConstraints>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok(crate::api::get_media(api_constraints))?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__get_peer_stats_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "get_peer_stats", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_peer = <RustOpaqueMoi<Arc < PeerConnection >>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>((move ||  {
                         let output_ok = crate::api::get_peer_stats(api_peer)?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__get_rtp_receiver_capabilities_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "get_rtp_receiver_capabilities", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_kind = <crate::api::MediaType>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok(crate::api::get_rtp_receiver_capabilities(api_kind))?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__get_rtp_sender_capabilities_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "get_rtp_sender_capabilities", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_kind = <crate::api::MediaType>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok(crate::api::get_rtp_sender_capabilities(api_kind))?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__get_transceiver_direction_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "get_transceiver_direction", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_transceiver = <RustOpaqueMoi<Arc < RtpTransceiver >>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok(crate::api::get_transceiver_direction(api_transceiver))?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__get_transceiver_mid_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "get_transceiver_mid", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_transceiver = <RustOpaqueMoi<Arc < RtpTransceiver >>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok(crate::api::get_transceiver_mid(api_transceiver))?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__get_transceivers_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "get_transceivers", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_peer = <RustOpaqueMoi<Arc < PeerConnection >>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok(crate::api::get_transceivers(api_peer))?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__is_fake_media_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "is_fake_media", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok(crate::api::is_fake_media())?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__microphone_volume_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "microphone_volume", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end(); move |context|  {
                    transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>((move ||  {
                         let output_ok = crate::api::microphone_volume()?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__microphone_volume_is_available_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "microphone_volume_is_available", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end(); move |context|  {
                    transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>((move ||  {
                         let output_ok = crate::api::microphone_volume_is_available()?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__register_track_observer_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "register_track_observer", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_cb = <StreamSink<crate::api::TrackEvent,flutter_rust_bridge::for_generated::SseCodec>>::sse_decode(&mut deserializer);
let api_peer_id = <Option<u32>>::sse_decode(&mut deserializer);
let api_track_id = <String>::sse_decode(&mut deserializer);
let api_kind = <crate::api::MediaType>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok({ crate::api::register_track_observer(api_cb, api_peer_id, api_track_id, api_kind); })?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__restart_ice_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "restart_ice", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_peer = <RustOpaqueMoi<Arc < PeerConnection >>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok({ crate::api::restart_ice(api_peer); })?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__sender_get_parameters_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "sender_get_parameters", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_transceiver = <RustOpaqueMoi<Arc < RtpTransceiver >>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok(crate::api::sender_get_parameters(api_transceiver))?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__sender_replace_track_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "sender_replace_track", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_peer = <RustOpaqueMoi<Arc < PeerConnection >>>::sse_decode(&mut deserializer);
let api_transceiver = <RustOpaqueMoi<Arc < RtpTransceiver >>>::sse_decode(&mut deserializer);
let api_track_id = <Option<String>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>((move ||  {
                         let output_ok = crate::api::sender_replace_track(api_peer, api_transceiver, api_track_id)?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__sender_set_parameters_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "sender_set_parameters", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_transceiver = <RustOpaqueMoi<Arc < RtpTransceiver >>>::sse_decode(&mut deserializer);
let api_params = <crate::api::RtcRtpSendParameters>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>((move ||  {
                         let output_ok = crate::api::sender_set_parameters(api_transceiver, api_params)?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__set_audio_level_observer_enabled_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "set_audio_level_observer_enabled", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_track_id = <String>::sse_decode(&mut deserializer);
let api_peer_id = <Option<u32>>::sse_decode(&mut deserializer);
let api_enabled = <bool>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok({ crate::api::set_audio_level_observer_enabled(api_track_id, api_peer_id, api_enabled); })?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__set_audio_playout_device_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "set_audio_playout_device", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_device_id = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>((move ||  {
                         let output_ok = crate::api::set_audio_playout_device(api_device_id)?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__set_codec_preferences_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "set_codec_preferences", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_transceiver = <RustOpaqueMoi<Arc < RtpTransceiver >>>::sse_decode(&mut deserializer);
let api_codecs = <Vec<crate::api::RtpCodecCapability>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok({ crate::api::set_codec_preferences(api_transceiver, api_codecs); })?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__set_local_description_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "set_local_description", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_peer = <RustOpaqueMoi<Arc < PeerConnection >>>::sse_decode(&mut deserializer);
let api_kind = <crate::api::SdpType>::sse_decode(&mut deserializer);
let api_sdp = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>((move ||  {
                         let output_ok = crate::api::set_local_description(api_peer, api_kind, api_sdp)?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__set_microphone_volume_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "set_microphone_volume", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_level = <u8>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>((move ||  {
                         let output_ok = crate::api::set_microphone_volume(api_level)?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__set_on_device_changed_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "set_on_device_changed", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_cb = <StreamSink<(),flutter_rust_bridge::for_generated::SseCodec>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok({ crate::api::set_on_device_changed(api_cb); })?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__set_remote_description_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "set_remote_description", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_peer = <RustOpaqueMoi<Arc < PeerConnection >>>::sse_decode(&mut deserializer);
let api_kind = <crate::api::SdpType>::sse_decode(&mut deserializer);
let api_sdp = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>((move ||  {
                         let output_ok = crate::api::set_remote_description(api_peer, api_kind, api_sdp)?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__set_track_enabled_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "set_track_enabled", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_track_id = <String>::sse_decode(&mut deserializer);
let api_peer_id = <Option<u32>>::sse_decode(&mut deserializer);
let api_kind = <crate::api::MediaType>::sse_decode(&mut deserializer);
let api_enabled = <bool>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok({ crate::api::set_track_enabled(api_track_id, api_peer_id, api_kind, api_enabled); })?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__set_transceiver_direction_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "set_transceiver_direction", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_transceiver = <RustOpaqueMoi<Arc < RtpTransceiver >>>::sse_decode(&mut deserializer);
let api_direction = <crate::api::RtpTransceiverDirection>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>((move ||  {
                         let output_ok = crate::api::set_transceiver_direction(api_transceiver, api_direction)?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__set_transceiver_recv_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "set_transceiver_recv", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_transceiver = <RustOpaqueMoi<Arc < RtpTransceiver >>>::sse_decode(&mut deserializer);
let api_recv = <bool>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>((move ||  {
                         let output_ok = crate::api::set_transceiver_recv(api_transceiver, api_recv)?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__set_transceiver_send_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "set_transceiver_send", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_transceiver = <RustOpaqueMoi<Arc < RtpTransceiver >>>::sse_decode(&mut deserializer);
let api_send = <bool>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>((move ||  {
                         let output_ok = crate::api::set_transceiver_send(api_transceiver, api_send)?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__stop_transceiver_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "stop_transceiver", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_transceiver = <RustOpaqueMoi<Arc < RtpTransceiver >>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>((move ||  {
                         let output_ok = crate::api::stop_transceiver(api_transceiver)?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__track_height_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "track_height", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_track_id = <String>::sse_decode(&mut deserializer);
let api_peer_id = <Option<u32>>::sse_decode(&mut deserializer);
let api_kind = <crate::api::MediaType>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok(crate::api::track_height(api_track_id, api_peer_id, api_kind))?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__track_state_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "track_state", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_track_id = <String>::sse_decode(&mut deserializer);
let api_peer_id = <Option<u32>>::sse_decode(&mut deserializer);
let api_kind = <crate::api::MediaType>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok(crate::api::track_state(api_track_id, api_peer_id, api_kind))?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__track_width_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "track_width", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_track_id = <String>::sse_decode(&mut deserializer);
let api_peer_id = <Option<u32>>::sse_decode(&mut deserializer);
let api_kind = <crate::api::MediaType>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok(crate::api::track_width(api_track_id, api_peer_id, api_kind))?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__update_audio_processing_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "update_audio_processing", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_track_id = <String>::sse_decode(&mut deserializer);
let api_conf = <crate::api::AudioProcessingConstraints>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>((move ||  {
                         let output_ok = crate::api::update_audio_processing(api_track_id, api_conf)?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__video_decoders_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "video_decoders", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok(crate::api::video_decoders())?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__video_encoders_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "video_encoders", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok(crate::api::video_encoders())?;   Ok(output_ok)
                    })())
                } })
}

// Section: related_funcs

flutter_rust_bridge::frb_generated_moi_arc_impl_value!(Arc<PeerConnection>);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    Arc<RtpEncodingParameters>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(Arc<RtpParameters>);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(Arc<RtpTransceiver>);

// Section: dart2rust

impl SseDecode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::anyhow::anyhow!(
            "{}", inner
        );
    }
}

impl SseDecode for RustOpaqueMoi<Arc<PeerConnection>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode for RustOpaqueMoi<Arc<RtpEncodingParameters>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode for RustOpaqueMoi<Arc<RtpParameters>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode for RustOpaqueMoi<Arc<RtpTransceiver>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for StreamSink<
        crate::api::PeerConnectionEvent,
        flutter_rust_bridge::for_generated::SseCodec,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return StreamSink::deserialize(inner);
    }
}

impl SseDecode
    for StreamSink<
        crate::renderer::TextureEvent,
        flutter_rust_bridge::for_generated::SseCodec,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return StreamSink::deserialize(inner);
    }
}

impl SseDecode
    for StreamSink<
        crate::api::TrackEvent,
        flutter_rust_bridge::for_generated::SseCodec,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return StreamSink::deserialize(inner);
    }
}

impl SseDecode
    for StreamSink<(), flutter_rust_bridge::for_generated::SseCodec>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return StreamSink::deserialize(inner);
    }
}

impl SseDecode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return String::from_utf8(inner).unwrap();
    }
}

impl SseDecode for crate::api::AudioConstraints {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut var_deviceId = <Option<String>>::sse_decode(deserializer);
        let mut var_processing =
            <crate::api::AudioProcessingConstraints>::sse_decode(deserializer);
        return crate::api::AudioConstraints {
            device_id: var_deviceId,
            processing: var_processing,
        };
    }
}

impl SseDecode for crate::api::AudioProcessingConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut var_autoGainControl = <bool>::sse_decode(deserializer);
        let mut var_highPassFilter = <bool>::sse_decode(deserializer);
        let mut var_noiseSuppression = <bool>::sse_decode(deserializer);
        let mut var_noiseSuppressionLevel =
            <crate::api::NoiseSuppressionLevel>::sse_decode(deserializer);
        let mut var_echoCancellation = <bool>::sse_decode(deserializer);
        return crate::api::AudioProcessingConfig {
            auto_gain_control: var_autoGainControl,
            high_pass_filter: var_highPassFilter,
            noise_suppression: var_noiseSuppression,
            noise_suppression_level: var_noiseSuppressionLevel,
            echo_cancellation: var_echoCancellation,
        };
    }
}

impl SseDecode for crate::api::AudioProcessingConstraints {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut var_autoGainControl = <Option<bool>>::sse_decode(deserializer);
        let mut var_highPassFilter = <Option<bool>>::sse_decode(deserializer);
        let mut var_noiseSuppression = <Option<bool>>::sse_decode(deserializer);
        let mut var_noiseSuppressionLevel = <Option<
            crate::api::NoiseSuppressionLevel,
        >>::sse_decode(deserializer);
        let mut var_echoCancellation = <Option<bool>>::sse_decode(deserializer);
        return crate::api::AudioProcessingConstraints {
            auto_gain_control: var_autoGainControl,
            high_pass_filter: var_highPassFilter,
            noise_suppression: var_noiseSuppression,
            noise_suppression_level: var_noiseSuppressionLevel,
            echo_cancellation: var_echoCancellation,
        };
    }
}

impl SseDecode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        deserializer.cursor.read_u8().unwrap() != 0
    }
}

impl SseDecode for crate::api::BundlePolicy {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::BundlePolicy::Balanced,
            1 => crate::api::BundlePolicy::MaxBundle,
            2 => crate::api::BundlePolicy::MaxCompat,
            _ => unreachable!("Invalid variant for BundlePolicy: {}", inner),
        };
    }
}

impl SseDecode for crate::api::CandidateType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::CandidateType::Host,
            1 => crate::api::CandidateType::Srflx,
            2 => crate::api::CandidateType::Prflx,
            3 => crate::api::CandidateType::Relay,
            _ => unreachable!("Invalid variant for CandidateType: {}", inner),
        };
    }
}

impl SseDecode for f64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        deserializer.cursor.read_f64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for crate::api::GetMediaError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::GetMediaError::Audio(var_field0);
            }
            1 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::GetMediaError::Video(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::GetMediaResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 =
                    <Vec<crate::api::MediaStreamTrack>>::sse_decode(
                        deserializer,
                    );
                return crate::api::GetMediaResult::Ok(var_field0);
            }
            1 => {
                let mut var_field0 =
                    <crate::api::GetMediaError>::sse_decode(deserializer);
                return crate::api::GetMediaResult::Err(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        deserializer.cursor.read_i32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for i64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        deserializer.cursor.read_i64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for crate::api::IceCandidateStats {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut var_transportId = <Option<String>>::sse_decode(deserializer);
        let mut var_address = <Option<String>>::sse_decode(deserializer);
        let mut var_port = <Option<i32>>::sse_decode(deserializer);
        let mut var_protocol = <crate::api::Protocol>::sse_decode(deserializer);
        let mut var_candidateType =
            <crate::api::CandidateType>::sse_decode(deserializer);
        let mut var_priority = <Option<i32>>::sse_decode(deserializer);
        let mut var_url = <Option<String>>::sse_decode(deserializer);
        let mut var_relayProtocol =
            <Option<crate::api::Protocol>>::sse_decode(deserializer);
        return crate::api::IceCandidateStats {
            transport_id: var_transportId,
            address: var_address,
            port: var_port,
            protocol: var_protocol,
            candidate_type: var_candidateType,
            priority: var_priority,
            url: var_url,
            relay_protocol: var_relayProtocol,
        };
    }
}

impl SseDecode for crate::api::IceConnectionState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::IceConnectionState::New,
            1 => crate::api::IceConnectionState::Checking,
            2 => crate::api::IceConnectionState::Connected,
            3 => crate::api::IceConnectionState::Completed,
            4 => crate::api::IceConnectionState::Failed,
            5 => crate::api::IceConnectionState::Disconnected,
            6 => crate::api::IceConnectionState::Closed,
            _ => unreachable!(
                "Invalid variant for IceConnectionState: {}",
                inner
            ),
        };
    }
}

impl SseDecode for crate::api::IceGatheringState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::IceGatheringState::New,
            1 => crate::api::IceGatheringState::Gathering,
            2 => crate::api::IceGatheringState::Complete,
            _ => {
                unreachable!("Invalid variant for IceGatheringState: {}", inner)
            }
        };
    }
}

impl SseDecode for crate::api::IceRole {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::IceRole::Unknown,
            1 => crate::api::IceRole::Controlling,
            2 => crate::api::IceRole::Controlled,
            _ => unreachable!("Invalid variant for IceRole: {}", inner),
        };
    }
}

impl SseDecode for crate::api::IceTransportsType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::IceTransportsType::All,
            1 => crate::api::IceTransportsType::Relay,
            2 => crate::api::IceTransportsType::NoHost,
            3 => crate::api::IceTransportsType::None,
            _ => {
                unreachable!("Invalid variant for IceTransportsType: {}", inner)
            }
        };
    }
}

impl SseDecode for Vec<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<String>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::media_info::MediaDeviceInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::media_info::MediaDeviceInfo>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::media_info::MediaDisplayInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::media_info::MediaDisplayInfo>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::MediaStreamTrack> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::MediaStreamTrack>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u8>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode
    for Vec<(
        crate::api::RtcRtpEncodingParameters,
        RustOpaqueMoi<Arc<RtpEncodingParameters>>,
    )>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(
                crate::api::RtcRtpEncodingParameters,
                RustOpaqueMoi<Arc<RtpEncodingParameters>>,
            )>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<(String, String)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(String, String)>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::RtcIceServer> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::RtcIceServer>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::RtcRtpEncodingParameters> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::RtcRtpEncodingParameters>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::RtcRtpTransceiver> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::RtcRtpTransceiver>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::RtcStats> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::RtcStats>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::RtcpFeedback> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::RtcpFeedback>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::RtpCodecCapability> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::RtpCodecCapability>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::RtpHeaderExtensionCapability> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::RtpHeaderExtensionCapability>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::ScalabilityMode> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::ScalabilityMode>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::VideoCodecInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::VideoCodecInfo>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for crate::api::media_info::MediaDeviceInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut var_deviceId = <String>::sse_decode(deserializer);
        let mut var_kind =
            <crate::api::media_info::MediaDeviceKind>::sse_decode(deserializer);
        let mut var_label = <String>::sse_decode(deserializer);
        return crate::api::media_info::MediaDeviceInfo {
            device_id: var_deviceId,
            kind: var_kind,
            label: var_label,
        };
    }
}

impl SseDecode for crate::api::media_info::MediaDeviceKind {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::media_info::MediaDeviceKind::AudioInput,
            1 => crate::api::media_info::MediaDeviceKind::AudioOutput,
            2 => crate::api::media_info::MediaDeviceKind::VideoInput,
            _ => unreachable!("Invalid variant for MediaDeviceKind: {}", inner),
        };
    }
}

impl SseDecode for crate::api::media_info::MediaDisplayInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut var_deviceId = <String>::sse_decode(deserializer);
        let mut var_title = <Option<String>>::sse_decode(deserializer);
        return crate::api::media_info::MediaDisplayInfo {
            device_id: var_deviceId,
            title: var_title,
        };
    }
}

impl SseDecode for crate::api::MediaStreamConstraints {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut var_audio =
            <Option<crate::api::AudioConstraints>>::sse_decode(deserializer);
        let mut var_video =
            <Option<crate::api::VideoConstraints>>::sse_decode(deserializer);
        return crate::api::MediaStreamConstraints {
            audio: var_audio,
            video: var_video,
        };
    }
}

impl SseDecode for crate::api::MediaStreamTrack {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_peerId = <Option<u32>>::sse_decode(deserializer);
        let mut var_deviceId = <String>::sse_decode(deserializer);
        let mut var_kind = <crate::api::MediaType>::sse_decode(deserializer);
        let mut var_enabled = <bool>::sse_decode(deserializer);
        return crate::api::MediaStreamTrack {
            id: var_id,
            peer_id: var_peerId,
            device_id: var_deviceId,
            kind: var_kind,
            enabled: var_enabled,
        };
    }
}

impl SseDecode for crate::api::MediaType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::MediaType::Audio,
            1 => crate::api::MediaType::Video,
            _ => unreachable!("Invalid variant for MediaType: {}", inner),
        };
    }
}

impl SseDecode for crate::api::NoiseSuppressionLevel {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::NoiseSuppressionLevel::Low,
            1 => crate::api::NoiseSuppressionLevel::Moderate,
            2 => crate::api::NoiseSuppressionLevel::High,
            3 => crate::api::NoiseSuppressionLevel::VeryHigh,
            _ => unreachable!(
                "Invalid variant for NoiseSuppressionLevel: {}",
                inner
            ),
        };
    }
}

impl SseDecode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<String>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::AudioConstraints> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::AudioConstraints>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<bool> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<bool>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<f64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<f64>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<i32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<i32>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::IceRole> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::IceRole>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::MediaStreamTrack> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::MediaStreamTrack>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::NoiseSuppressionLevel> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::NoiseSuppressionLevel>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::Protocol> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::Protocol>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::RtcInboundRtpStreamMediaType> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <crate::api::RtcInboundRtpStreamMediaType>::sse_decode(
                    deserializer,
                ),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::RtcpFeedbackMessageType> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::RtcpFeedbackMessageType>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u32>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u64>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::VideoConstraints> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::VideoConstraints>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for crate::api::PeerConnectionEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_peer =
                    <RustOpaqueMoi<Arc<PeerConnection>>>::sse_decode(
                        deserializer,
                    );
                return crate::api::PeerConnectionEvent::PeerCreated {
                    peer: var_peer,
                };
            }
            1 => {
                let mut var_sdpMid = <String>::sse_decode(deserializer);
                let mut var_sdpMlineIndex = <i32>::sse_decode(deserializer);
                let mut var_candidate = <String>::sse_decode(deserializer);
                return crate::api::PeerConnectionEvent::IceCandidate {
                    sdp_mid: var_sdpMid,
                    sdp_mline_index: var_sdpMlineIndex,
                    candidate: var_candidate,
                };
            }
            2 => {
                let mut var_field0 =
                    <crate::api::IceGatheringState>::sse_decode(deserializer);
                return crate::api::PeerConnectionEvent::IceGatheringStateChange(var_field0);
            }
            3 => {
                let mut var_address = <String>::sse_decode(deserializer);
                let mut var_port = <i32>::sse_decode(deserializer);
                let mut var_url = <String>::sse_decode(deserializer);
                let mut var_errorCode = <i32>::sse_decode(deserializer);
                let mut var_errorText = <String>::sse_decode(deserializer);
                return crate::api::PeerConnectionEvent::IceCandidateError {
                    address: var_address,
                    port: var_port,
                    url: var_url,
                    error_code: var_errorCode,
                    error_text: var_errorText,
                };
            }
            4 => {
                return crate::api::PeerConnectionEvent::NegotiationNeeded;
            }
            5 => {
                let mut var_field0 =
                    <crate::api::SignalingState>::sse_decode(deserializer);
                return crate::api::PeerConnectionEvent::SignallingChange(
                    var_field0,
                );
            }
            6 => {
                let mut var_field0 =
                    <crate::api::IceConnectionState>::sse_decode(deserializer);
                return crate::api::PeerConnectionEvent::IceConnectionStateChange(var_field0);
            }
            7 => {
                let mut var_field0 =
                    <crate::api::PeerConnectionState>::sse_decode(deserializer);
                return crate::api::PeerConnectionEvent::ConnectionStateChange(
                    var_field0,
                );
            }
            8 => {
                let mut var_field0 =
                    <crate::api::RtcTrackEvent>::sse_decode(deserializer);
                return crate::api::PeerConnectionEvent::Track(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::PeerConnectionState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::PeerConnectionState::New,
            1 => crate::api::PeerConnectionState::Connecting,
            2 => crate::api::PeerConnectionState::Connected,
            3 => crate::api::PeerConnectionState::Disconnected,
            4 => crate::api::PeerConnectionState::Failed,
            5 => crate::api::PeerConnectionState::Closed,
            _ => unreachable!(
                "Invalid variant for PeerConnectionState: {}",
                inner
            ),
        };
    }
}

impl SseDecode for crate::api::Protocol {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::Protocol::Tcp,
            1 => crate::api::Protocol::Udp,
            _ => unreachable!("Invalid variant for Protocol: {}", inner),
        };
    }
}

impl SseDecode
    for (
        crate::api::RtcRtpEncodingParameters,
        RustOpaqueMoi<Arc<RtpEncodingParameters>>,
    )
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut var_field0 =
            <crate::api::RtcRtpEncodingParameters>::sse_decode(deserializer);
        let mut var_field1 =
            <RustOpaqueMoi<Arc<RtpEncodingParameters>>>::sse_decode(
                deserializer,
            );
        return (var_field0, var_field1);
    }
}

impl SseDecode for (String, String) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut var_field0 = <String>::sse_decode(deserializer);
        let mut var_field1 = <String>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for crate::api::RtcConfiguration {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut var_iceTransportPolicy =
            <crate::api::IceTransportsType>::sse_decode(deserializer);
        let mut var_bundlePolicy =
            <crate::api::BundlePolicy>::sse_decode(deserializer);
        let mut var_iceServers =
            <Vec<crate::api::RtcIceServer>>::sse_decode(deserializer);
        return crate::api::RtcConfiguration {
            ice_transport_policy: var_iceTransportPolicy,
            bundle_policy: var_bundlePolicy,
            ice_servers: var_iceServers,
        };
    }
}

impl SseDecode for crate::api::RtcIceCandidateStats {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 =
                    <crate::api::IceCandidateStats>::sse_decode(deserializer);
                return crate::api::RtcIceCandidateStats::Local(var_field0);
            }
            1 => {
                let mut var_field0 =
                    <crate::api::IceCandidateStats>::sse_decode(deserializer);
                return crate::api::RtcIceCandidateStats::Remote(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::RtcIceServer {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut var_urls = <Vec<String>>::sse_decode(deserializer);
        let mut var_username = <String>::sse_decode(deserializer);
        let mut var_credential = <String>::sse_decode(deserializer);
        return crate::api::RtcIceServer {
            urls: var_urls,
            username: var_username,
            credential: var_credential,
        };
    }
}

impl SseDecode for crate::api::RtcInboundRtpStreamMediaType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_voiceActivityFlag =
                    <Option<bool>>::sse_decode(deserializer);
                let mut var_totalSamplesReceived =
                    <Option<u64>>::sse_decode(deserializer);
                let mut var_concealedSamples =
                    <Option<u64>>::sse_decode(deserializer);
                let mut var_silentConcealedSamples =
                    <Option<u64>>::sse_decode(deserializer);
                let mut var_audioLevel =
                    <Option<f64>>::sse_decode(deserializer);
                let mut var_totalAudioEnergy =
                    <Option<f64>>::sse_decode(deserializer);
                let mut var_totalSamplesDuration =
                    <Option<f64>>::sse_decode(deserializer);
                return crate::api::RtcInboundRtpStreamMediaType::Audio {
                    voice_activity_flag: var_voiceActivityFlag,
                    total_samples_received: var_totalSamplesReceived,
                    concealed_samples: var_concealedSamples,
                    silent_concealed_samples: var_silentConcealedSamples,
                    audio_level: var_audioLevel,
                    total_audio_energy: var_totalAudioEnergy,
                    total_samples_duration: var_totalSamplesDuration,
                };
            }
            1 => {
                let mut var_framesDecoded =
                    <Option<u32>>::sse_decode(deserializer);
                let mut var_keyFramesDecoded =
                    <Option<u32>>::sse_decode(deserializer);
                let mut var_frameWidth =
                    <Option<u32>>::sse_decode(deserializer);
                let mut var_frameHeight =
                    <Option<u32>>::sse_decode(deserializer);
                let mut var_totalInterFrameDelay =
                    <Option<f64>>::sse_decode(deserializer);
                let mut var_framesPerSecond =
                    <Option<f64>>::sse_decode(deserializer);
                let mut var_firCount = <Option<u32>>::sse_decode(deserializer);
                let mut var_pliCount = <Option<u32>>::sse_decode(deserializer);
                let mut var_sliCount = <Option<u32>>::sse_decode(deserializer);
                let mut var_concealmentEvents =
                    <Option<u64>>::sse_decode(deserializer);
                let mut var_framesReceived =
                    <Option<i32>>::sse_decode(deserializer);
                return crate::api::RtcInboundRtpStreamMediaType::Video {
                    frames_decoded: var_framesDecoded,
                    key_frames_decoded: var_keyFramesDecoded,
                    frame_width: var_frameWidth,
                    frame_height: var_frameHeight,
                    total_inter_frame_delay: var_totalInterFrameDelay,
                    frames_per_second: var_framesPerSecond,
                    fir_count: var_firCount,
                    pli_count: var_pliCount,
                    sli_count: var_sliCount,
                    concealment_events: var_concealmentEvents,
                    frames_received: var_framesReceived,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::RtcMediaSourceStatsMediaType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_width = <Option<u32>>::sse_decode(deserializer);
                let mut var_height = <Option<u32>>::sse_decode(deserializer);
                let mut var_frames = <Option<u32>>::sse_decode(deserializer);
                let mut var_framesPerSecond =
                    <Option<f64>>::sse_decode(deserializer);
                return crate::api::RtcMediaSourceStatsMediaType::RtcVideoSourceStats{width: var_width, height: var_height, frames: var_frames, frames_per_second: var_framesPerSecond};
            }
            1 => {
                let mut var_audioLevel =
                    <Option<f64>>::sse_decode(deserializer);
                let mut var_totalAudioEnergy =
                    <Option<f64>>::sse_decode(deserializer);
                let mut var_totalSamplesDuration =
                    <Option<f64>>::sse_decode(deserializer);
                let mut var_echoReturnLoss =
                    <Option<f64>>::sse_decode(deserializer);
                let mut var_echoReturnLossEnhancement =
                    <Option<f64>>::sse_decode(deserializer);
                return crate::api::RtcMediaSourceStatsMediaType::RtcAudioSourceStats{audio_level: var_audioLevel, total_audio_energy: var_totalAudioEnergy, total_samples_duration: var_totalSamplesDuration, echo_return_loss: var_echoReturnLoss, echo_return_loss_enhancement: var_echoReturnLossEnhancement};
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::RtcOutboundRtpStreamStatsMediaType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_totalSamplesSent =
                    <Option<u64>>::sse_decode(deserializer);
                let mut var_voiceActivityFlag =
                    <Option<bool>>::sse_decode(deserializer);
                return crate::api::RtcOutboundRtpStreamStatsMediaType::Audio {
                    total_samples_sent: var_totalSamplesSent,
                    voice_activity_flag: var_voiceActivityFlag,
                };
            }
            1 => {
                let mut var_frameWidth =
                    <Option<u32>>::sse_decode(deserializer);
                let mut var_frameHeight =
                    <Option<u32>>::sse_decode(deserializer);
                let mut var_framesPerSecond =
                    <Option<f64>>::sse_decode(deserializer);
                return crate::api::RtcOutboundRtpStreamStatsMediaType::Video {
                    frame_width: var_frameWidth,
                    frame_height: var_frameHeight,
                    frames_per_second: var_framesPerSecond,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::RtcRtpEncodingParameters {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut var_rid = <String>::sse_decode(deserializer);
        let mut var_active = <bool>::sse_decode(deserializer);
        let mut var_maxBitrate = <Option<i32>>::sse_decode(deserializer);
        let mut var_maxFramerate = <Option<f64>>::sse_decode(deserializer);
        let mut var_scaleResolutionDownBy =
            <Option<f64>>::sse_decode(deserializer);
        let mut var_scalabilityMode =
            <Option<String>>::sse_decode(deserializer);
        return crate::api::RtcRtpEncodingParameters {
            rid: var_rid,
            active: var_active,
            max_bitrate: var_maxBitrate,
            max_framerate: var_maxFramerate,
            scale_resolution_down_by: var_scaleResolutionDownBy,
            scalability_mode: var_scalabilityMode,
        };
    }
}

impl SseDecode for crate::api::RtcRtpSendParameters {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut var_encodings = <Vec<(
            crate::api::RtcRtpEncodingParameters,
            RustOpaqueMoi<Arc<RtpEncodingParameters>>,
        )>>::sse_decode(deserializer);
        let mut var_inner =
            <RustOpaqueMoi<Arc<RtpParameters>>>::sse_decode(deserializer);
        return crate::api::RtcRtpSendParameters {
            encodings: var_encodings,
            inner: var_inner,
        };
    }
}

impl SseDecode for crate::api::RtcRtpTransceiver {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut var_peer =
            <RustOpaqueMoi<Arc<PeerConnection>>>::sse_decode(deserializer);
        let mut var_transceiver =
            <RustOpaqueMoi<Arc<RtpTransceiver>>>::sse_decode(deserializer);
        let mut var_mid = <Option<String>>::sse_decode(deserializer);
        let mut var_direction =
            <crate::api::RtpTransceiverDirection>::sse_decode(deserializer);
        return crate::api::RtcRtpTransceiver {
            peer: var_peer,
            transceiver: var_transceiver,
            mid: var_mid,
            direction: var_direction,
        };
    }
}

impl SseDecode for crate::api::RtcSessionDescription {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut var_sdp = <String>::sse_decode(deserializer);
        let mut var_kind = <crate::api::SdpType>::sse_decode(deserializer);
        return crate::api::RtcSessionDescription {
            sdp: var_sdp,
            kind: var_kind,
        };
    }
}

impl SseDecode for crate::api::RtcStats {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_timestampUs = <i64>::sse_decode(deserializer);
        let mut var_kind = <crate::api::RtcStatsType>::sse_decode(deserializer);
        return crate::api::RtcStats {
            id: var_id,
            timestamp_us: var_timestampUs,
            kind: var_kind,
        };
    }
}

impl SseDecode for crate::api::RtcStatsIceCandidatePairState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::RtcStatsIceCandidatePairState::Frozen,
            1 => crate::api::RtcStatsIceCandidatePairState::Waiting,
            2 => crate::api::RtcStatsIceCandidatePairState::InProgress,
            3 => crate::api::RtcStatsIceCandidatePairState::Failed,
            4 => crate::api::RtcStatsIceCandidatePairState::Succeeded,
            _ => unreachable!(
                "Invalid variant for RtcStatsIceCandidatePairState: {}",
                inner
            ),
        };
    }
}

impl SseDecode for crate::api::RtcStatsType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_trackIdentifier =
                    <Option<String>>::sse_decode(deserializer);
                let mut var_kind =
                    <crate::api::RtcMediaSourceStatsMediaType>::sse_decode(
                        deserializer,
                    );
                return crate::api::RtcStatsType::RtcMediaSourceStats {
                    track_identifier: var_trackIdentifier,
                    kind: var_kind,
                };
            }
            1 => {
                let mut var_field0 =
                    <crate::api::RtcIceCandidateStats>::sse_decode(
                        deserializer,
                    );
                return crate::api::RtcStatsType::RtcIceCandidateStats(
                    var_field0,
                );
            }
            2 => {
                let mut var_trackId =
                    <Option<String>>::sse_decode(deserializer);
                let mut var_mediaType = <crate::api::RtcOutboundRtpStreamStatsMediaType>::sse_decode(deserializer);
                let mut var_bytesSent = <Option<u64>>::sse_decode(deserializer);
                let mut var_packetsSent =
                    <Option<u32>>::sse_decode(deserializer);
                let mut var_mediaSourceId =
                    <Option<String>>::sse_decode(deserializer);
                return crate::api::RtcStatsType::RtcOutboundRtpStreamStats {
                    track_id: var_trackId,
                    media_type: var_mediaType,
                    bytes_sent: var_bytesSent,
                    packets_sent: var_packetsSent,
                    media_source_id: var_mediaSourceId,
                };
            }
            3 => {
                let mut var_remoteId =
                    <Option<String>>::sse_decode(deserializer);
                let mut var_bytesReceived =
                    <Option<u64>>::sse_decode(deserializer);
                let mut var_packetsReceived =
                    <Option<u32>>::sse_decode(deserializer);
                let mut var_packetsLost =
                    <Option<u64>>::sse_decode(deserializer);
                let mut var_jitter = <Option<f64>>::sse_decode(deserializer);
                let mut var_totalDecodeTime =
                    <Option<f64>>::sse_decode(deserializer);
                let mut var_jitterBufferEmittedCount =
                    <Option<u64>>::sse_decode(deserializer);
                let mut var_mediaType = <Option<
                    crate::api::RtcInboundRtpStreamMediaType,
                >>::sse_decode(
                    deserializer
                );
                return crate::api::RtcStatsType::RtcInboundRtpStreamStats {
                    remote_id: var_remoteId,
                    bytes_received: var_bytesReceived,
                    packets_received: var_packetsReceived,
                    packets_lost: var_packetsLost,
                    jitter: var_jitter,
                    total_decode_time: var_totalDecodeTime,
                    jitter_buffer_emitted_count: var_jitterBufferEmittedCount,
                    media_type: var_mediaType,
                };
            }
            4 => {
                let mut var_state =
                    <crate::api::RtcStatsIceCandidatePairState>::sse_decode(
                        deserializer,
                    );
                let mut var_nominated =
                    <Option<bool>>::sse_decode(deserializer);
                let mut var_bytesSent = <Option<u64>>::sse_decode(deserializer);
                let mut var_bytesReceived =
                    <Option<u64>>::sse_decode(deserializer);
                let mut var_totalRoundTripTime =
                    <Option<f64>>::sse_decode(deserializer);
                let mut var_currentRoundTripTime =
                    <Option<f64>>::sse_decode(deserializer);
                let mut var_availableOutgoingBitrate =
                    <Option<f64>>::sse_decode(deserializer);
                return crate::api::RtcStatsType::RtcIceCandidatePairStats {
                    state: var_state,
                    nominated: var_nominated,
                    bytes_sent: var_bytesSent,
                    bytes_received: var_bytesReceived,
                    total_round_trip_time: var_totalRoundTripTime,
                    current_round_trip_time: var_currentRoundTripTime,
                    available_outgoing_bitrate: var_availableOutgoingBitrate,
                };
            }
            5 => {
                let mut var_packetsSent =
                    <Option<u64>>::sse_decode(deserializer);
                let mut var_packetsReceived =
                    <Option<u64>>::sse_decode(deserializer);
                let mut var_bytesSent = <Option<u64>>::sse_decode(deserializer);
                let mut var_bytesReceived =
                    <Option<u64>>::sse_decode(deserializer);
                let mut var_iceRole =
                    <Option<crate::api::IceRole>>::sse_decode(deserializer);
                return crate::api::RtcStatsType::RtcTransportStats {
                    packets_sent: var_packetsSent,
                    packets_received: var_packetsReceived,
                    bytes_sent: var_bytesSent,
                    bytes_received: var_bytesReceived,
                    ice_role: var_iceRole,
                };
            }
            6 => {
                let mut var_localId =
                    <Option<String>>::sse_decode(deserializer);
                let mut var_jitter = <Option<f64>>::sse_decode(deserializer);
                let mut var_roundTripTime =
                    <Option<f64>>::sse_decode(deserializer);
                let mut var_fractionLost =
                    <Option<f64>>::sse_decode(deserializer);
                let mut var_reportsReceived =
                    <Option<u64>>::sse_decode(deserializer);
                let mut var_roundTripTimeMeasurements =
                    <Option<i32>>::sse_decode(deserializer);
                return crate::api::RtcStatsType::RtcRemoteInboundRtpStreamStats{local_id: var_localId, jitter: var_jitter, round_trip_time: var_roundTripTime, fraction_lost: var_fractionLost, reports_received: var_reportsReceived, round_trip_time_measurements: var_roundTripTimeMeasurements};
            }
            7 => {
                let mut var_localId =
                    <Option<String>>::sse_decode(deserializer);
                let mut var_remoteTimestamp =
                    <Option<f64>>::sse_decode(deserializer);
                let mut var_reportsSent =
                    <Option<u64>>::sse_decode(deserializer);
                return crate::api::RtcStatsType::RtcRemoteOutboundRtpStreamStats{local_id: var_localId, remote_timestamp: var_remoteTimestamp, reports_sent: var_reportsSent};
            }
            8 => {
                return crate::api::RtcStatsType::Unimplemented;
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::RtcTrackEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut var_track =
            <crate::api::MediaStreamTrack>::sse_decode(deserializer);
        let mut var_transceiver =
            <crate::api::RtcRtpTransceiver>::sse_decode(deserializer);
        return crate::api::RtcTrackEvent {
            track: var_track,
            transceiver: var_transceiver,
        };
    }
}

impl SseDecode for crate::api::RtcpFeedback {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut var_messageType =
            <Option<crate::api::RtcpFeedbackMessageType>>::sse_decode(
                deserializer,
            );
        let mut var_kind =
            <crate::api::RtcpFeedbackType>::sse_decode(deserializer);
        return crate::api::RtcpFeedback {
            message_type: var_messageType,
            kind: var_kind,
        };
    }
}

impl SseDecode for crate::api::RtcpFeedbackMessageType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::RtcpFeedbackMessageType::GenericNACK,
            1 => crate::api::RtcpFeedbackMessageType::Pli,
            2 => crate::api::RtcpFeedbackMessageType::Fir,
            _ => unreachable!(
                "Invalid variant for RtcpFeedbackMessageType: {}",
                inner
            ),
        };
    }
}

impl SseDecode for crate::api::RtcpFeedbackType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::RtcpFeedbackType::Ccm,
            1 => crate::api::RtcpFeedbackType::Lntf,
            2 => crate::api::RtcpFeedbackType::Nack,
            3 => crate::api::RtcpFeedbackType::Remb,
            4 => crate::api::RtcpFeedbackType::TransportCC,
            _ => {
                unreachable!("Invalid variant for RtcpFeedbackType: {}", inner)
            }
        };
    }
}

impl SseDecode for crate::api::RtpCapabilities {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut var_codecs =
            <Vec<crate::api::RtpCodecCapability>>::sse_decode(deserializer);
        let mut var_headerExtensions = <Vec<
            crate::api::RtpHeaderExtensionCapability,
        >>::sse_decode(deserializer);
        return crate::api::RtpCapabilities {
            codecs: var_codecs,
            header_extensions: var_headerExtensions,
        };
    }
}

impl SseDecode for crate::api::RtpCodecCapability {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut var_preferredPayloadType =
            <Option<i32>>::sse_decode(deserializer);
        let mut var_scalabilityModes =
            <Vec<crate::api::ScalabilityMode>>::sse_decode(deserializer);
        let mut var_mimeType = <String>::sse_decode(deserializer);
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_kind = <crate::api::MediaType>::sse_decode(deserializer);
        let mut var_clockRate = <Option<i32>>::sse_decode(deserializer);
        let mut var_numChannels = <Option<i32>>::sse_decode(deserializer);
        let mut var_parameters =
            <Vec<(String, String)>>::sse_decode(deserializer);
        let mut var_feedback =
            <Vec<crate::api::RtcpFeedback>>::sse_decode(deserializer);
        return crate::api::RtpCodecCapability {
            preferred_payload_type: var_preferredPayloadType,
            scalability_modes: var_scalabilityModes,
            mime_type: var_mimeType,
            name: var_name,
            kind: var_kind,
            clock_rate: var_clockRate,
            num_channels: var_numChannels,
            parameters: var_parameters,
            feedback: var_feedback,
        };
    }
}

impl SseDecode for crate::api::RtpHeaderExtensionCapability {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut var_uri = <String>::sse_decode(deserializer);
        let mut var_preferredId = <Option<i32>>::sse_decode(deserializer);
        let mut var_preferredEncrypted = <bool>::sse_decode(deserializer);
        let mut var_direction =
            <crate::api::RtpTransceiverDirection>::sse_decode(deserializer);
        return crate::api::RtpHeaderExtensionCapability {
            uri: var_uri,
            preferred_id: var_preferredId,
            preferred_encrypted: var_preferredEncrypted,
            direction: var_direction,
        };
    }
}

impl SseDecode for crate::api::RtpTransceiverDirection {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::RtpTransceiverDirection::SendRecv,
            1 => crate::api::RtpTransceiverDirection::SendOnly,
            2 => crate::api::RtpTransceiverDirection::RecvOnly,
            3 => crate::api::RtpTransceiverDirection::Inactive,
            4 => crate::api::RtpTransceiverDirection::Stopped,
            _ => unreachable!(
                "Invalid variant for RtpTransceiverDirection: {}",
                inner
            ),
        };
    }
}

impl SseDecode for crate::api::RtpTransceiverInit {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut var_direction =
            <crate::api::RtpTransceiverDirection>::sse_decode(deserializer);
        let mut var_sendEncodings =
            <Vec<crate::api::RtcRtpEncodingParameters>>::sse_decode(
                deserializer,
            );
        return crate::api::RtpTransceiverInit {
            direction: var_direction,
            send_encodings: var_sendEncodings,
        };
    }
}

impl SseDecode for crate::api::ScalabilityMode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::ScalabilityMode::L1T1,
            1 => crate::api::ScalabilityMode::L1T2,
            2 => crate::api::ScalabilityMode::L1T3,
            3 => crate::api::ScalabilityMode::L2T1,
            4 => crate::api::ScalabilityMode::L2T1h,
            5 => crate::api::ScalabilityMode::L2t1Key,
            6 => crate::api::ScalabilityMode::L2T2,
            7 => crate::api::ScalabilityMode::L2T2h,
            8 => crate::api::ScalabilityMode::L2T2Key,
            9 => crate::api::ScalabilityMode::L2T2KeyShift,
            10 => crate::api::ScalabilityMode::L2T3,
            11 => crate::api::ScalabilityMode::L2T3h,
            12 => crate::api::ScalabilityMode::L2T3Key,
            13 => crate::api::ScalabilityMode::L3T1,
            14 => crate::api::ScalabilityMode::L3T1h,
            15 => crate::api::ScalabilityMode::L3T1Key,
            16 => crate::api::ScalabilityMode::L3T2,
            17 => crate::api::ScalabilityMode::L3T2h,
            18 => crate::api::ScalabilityMode::L3T2Key,
            19 => crate::api::ScalabilityMode::L3T3,
            20 => crate::api::ScalabilityMode::L3T3h,
            21 => crate::api::ScalabilityMode::L3T3Key,
            22 => crate::api::ScalabilityMode::S2T1,
            23 => crate::api::ScalabilityMode::S2T1h,
            24 => crate::api::ScalabilityMode::S2T2,
            25 => crate::api::ScalabilityMode::S2T2h,
            26 => crate::api::ScalabilityMode::S2T3,
            27 => crate::api::ScalabilityMode::S2T3h,
            28 => crate::api::ScalabilityMode::S3T1,
            29 => crate::api::ScalabilityMode::S3T1h,
            30 => crate::api::ScalabilityMode::S3T2,
            31 => crate::api::ScalabilityMode::S3T2h,
            32 => crate::api::ScalabilityMode::S3T3,
            33 => crate::api::ScalabilityMode::S3T3h,
            _ => unreachable!("Invalid variant for ScalabilityMode: {}", inner),
        };
    }
}

impl SseDecode for crate::api::SdpType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::SdpType::Offer,
            1 => crate::api::SdpType::PrAnswer,
            2 => crate::api::SdpType::Answer,
            3 => crate::api::SdpType::Rollback,
            _ => unreachable!("Invalid variant for SdpType: {}", inner),
        };
    }
}

impl SseDecode for crate::api::SignalingState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::SignalingState::Stable,
            1 => crate::api::SignalingState::HaveLocalOffer,
            2 => crate::api::SignalingState::HaveLocalPrAnswer,
            3 => crate::api::SignalingState::HaveRemoteOffer,
            4 => crate::api::SignalingState::HaveRemotePrAnswer,
            5 => crate::api::SignalingState::Closed,
            _ => unreachable!("Invalid variant for SignalingState: {}", inner),
        };
    }
}

impl SseDecode for crate::renderer::TextureEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_textureId = <i64>::sse_decode(deserializer);
                let mut var_width = <i32>::sse_decode(deserializer);
                let mut var_height = <i32>::sse_decode(deserializer);
                let mut var_rotation = <i32>::sse_decode(deserializer);
                return crate::renderer::TextureEvent::OnTextureChange {
                    texture_id: var_textureId,
                    width: var_width,
                    height: var_height,
                    rotation: var_rotation,
                };
            }
            1 => {
                let mut var_textureId = <i64>::sse_decode(deserializer);
                return crate::renderer::TextureEvent::OnFirstFrameRendered {
                    texture_id: var_textureId,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::TrackEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::api::TrackEvent::Ended;
            }
            1 => {
                let mut var_field0 = <u32>::sse_decode(deserializer);
                return crate::api::TrackEvent::AudioLevelUpdated(var_field0);
            }
            2 => {
                return crate::api::TrackEvent::TrackCreated;
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::TrackState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::TrackState::Live,
            1 => crate::api::TrackState::Ended,
            _ => unreachable!("Invalid variant for TrackState: {}", inner),
        };
    }
}

impl SseDecode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        deserializer.cursor.read_u32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        deserializer.cursor.read_u8().unwrap()
    }
}

impl SseDecode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
    }
}

impl SseDecode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap() as _
    }
}

impl SseDecode for crate::api::VideoCodec {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::VideoCodec::AV1,
            1 => crate::api::VideoCodec::H264,
            2 => crate::api::VideoCodec::H265,
            3 => crate::api::VideoCodec::VP8,
            4 => crate::api::VideoCodec::VP9,
            _ => unreachable!("Invalid variant for VideoCodec: {}", inner),
        };
    }
}

impl SseDecode for crate::api::VideoCodecInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut var_isHardwareAccelerated = <bool>::sse_decode(deserializer);
        let mut var_codec = <crate::api::VideoCodec>::sse_decode(deserializer);
        return crate::api::VideoCodecInfo {
            is_hardware_accelerated: var_isHardwareAccelerated,
            codec: var_codec,
        };
    }
}

impl SseDecode for crate::api::VideoConstraints {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut var_deviceId = <Option<String>>::sse_decode(deserializer);
        let mut var_width = <u32>::sse_decode(deserializer);
        let mut var_height = <u32>::sse_decode(deserializer);
        let mut var_frameRate = <u32>::sse_decode(deserializer);
        let mut var_isDisplay = <bool>::sse_decode(deserializer);
        return crate::api::VideoConstraints {
            device_id: var_deviceId,
            width: var_width,
            height: var_height,
            frame_rate: var_frameRate,
            is_display: var_isDisplay,
        };
    }
}

fn pde_ffi_dispatcher_primary_impl(
    func_id: i32,
    port: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        1 => wire__crate__api__add_ice_candidate_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        2 => wire__crate__api__add_transceiver_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        3 => wire__crate__api__audio_processing_constraints_default_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        4 => wire__crate__api__clone_track_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        5 => wire__crate__api__create_answer_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        6 => wire__crate__api__create_offer_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        7 => wire__crate__api__create_peer_connection_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        8 => wire__crate__api__create_video_sink_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        9 => wire__crate__api__dispose_peer_connection_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        10 => wire__crate__api__dispose_track_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        11 => wire__crate__api__dispose_video_sink_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        12 => wire__crate__api__enable_fake_media_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        13 => wire__crate__api__enumerate_devices_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        14 => wire__crate__api__enumerate_displays_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        15 => wire__crate__api__get_audio_processing_config_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        16 => {
            wire__crate__api__get_media_impl(port, ptr, rust_vec_len, data_len)
        }
        17 => wire__crate__api__get_peer_stats_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        18 => wire__crate__api__get_rtp_receiver_capabilities_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        19 => wire__crate__api__get_rtp_sender_capabilities_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        20 => wire__crate__api__get_transceiver_direction_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        21 => wire__crate__api__get_transceiver_mid_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        22 => wire__crate__api__get_transceivers_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        23 => wire__crate__api__is_fake_media_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        24 => wire__crate__api__microphone_volume_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        25 => wire__crate__api__microphone_volume_is_available_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        26 => wire__crate__api__register_track_observer_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        27 => wire__crate__api__restart_ice_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        28 => wire__crate__api__sender_get_parameters_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        29 => wire__crate__api__sender_replace_track_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        30 => wire__crate__api__sender_set_parameters_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        31 => wire__crate__api__set_audio_level_observer_enabled_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        32 => wire__crate__api__set_audio_playout_device_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        33 => wire__crate__api__set_codec_preferences_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        34 => wire__crate__api__set_local_description_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        35 => wire__crate__api__set_microphone_volume_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        36 => wire__crate__api__set_on_device_changed_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        37 => wire__crate__api__set_remote_description_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        38 => wire__crate__api__set_track_enabled_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        39 => wire__crate__api__set_transceiver_direction_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        40 => wire__crate__api__set_transceiver_recv_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        41 => wire__crate__api__set_transceiver_send_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        42 => wire__crate__api__stop_transceiver_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        43 => wire__crate__api__track_height_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        44 => wire__crate__api__track_state_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        45 => wire__crate__api__track_width_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        46 => wire__crate__api__update_audio_processing_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        47 => wire__crate__api__video_decoders_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        48 => wire__crate__api__video_encoders_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        _ => unreachable!(),
    }
}

fn pde_ffi_dispatcher_sync_impl(
    func_id: i32,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        _ => unreachable!(),
    }
}

// Section: rust2dart

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::AudioConstraints {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.device_id.into_into_dart().into_dart(),
            self.processing.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::AudioConstraints
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::AudioConstraints>
    for crate::api::AudioConstraints
{
    fn into_into_dart(self) -> crate::api::AudioConstraints {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::AudioProcessingConfig {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.auto_gain_control.into_into_dart().into_dart(),
            self.high_pass_filter.into_into_dart().into_dart(),
            self.noise_suppression.into_into_dart().into_dart(),
            self.noise_suppression_level.into_into_dart().into_dart(),
            self.echo_cancellation.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::AudioProcessingConfig
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::AudioProcessingConfig>
    for crate::api::AudioProcessingConfig
{
    fn into_into_dart(self) -> crate::api::AudioProcessingConfig {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::AudioProcessingConstraints {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.auto_gain_control.into_into_dart().into_dart(),
            self.high_pass_filter.into_into_dart().into_dart(),
            self.noise_suppression.into_into_dart().into_dart(),
            self.noise_suppression_level.into_into_dart().into_dart(),
            self.echo_cancellation.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::AudioProcessingConstraints
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::AudioProcessingConstraints>
    for crate::api::AudioProcessingConstraints
{
    fn into_into_dart(self) -> crate::api::AudioProcessingConstraints {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::BundlePolicy {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Balanced => 0.into_dart(),
            Self::MaxBundle => 1.into_dart(),
            Self::MaxCompat => 2.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::BundlePolicy
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::BundlePolicy>
    for crate::api::BundlePolicy
{
    fn into_into_dart(self) -> crate::api::BundlePolicy {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::CandidateType {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Host => 0.into_dart(),
            Self::Srflx => 1.into_dart(),
            Self::Prflx => 2.into_dart(),
            Self::Relay => 3.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::CandidateType
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::CandidateType>
    for crate::api::CandidateType
{
    fn into_into_dart(self) -> crate::api::CandidateType {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::GetMediaError {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::GetMediaError::Audio(field0) => {
                [0.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::GetMediaError::Video(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::GetMediaError
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::GetMediaError>
    for crate::api::GetMediaError
{
    fn into_into_dart(self) -> crate::api::GetMediaError {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::GetMediaResult {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::GetMediaResult::Ok(field0) => {
                [0.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::GetMediaResult::Err(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::GetMediaResult
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::GetMediaResult>
    for crate::api::GetMediaResult
{
    fn into_into_dart(self) -> crate::api::GetMediaResult {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::IceCandidateStats {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.transport_id.into_into_dart().into_dart(),
            self.address.into_into_dart().into_dart(),
            self.port.into_into_dart().into_dart(),
            self.protocol.into_into_dart().into_dart(),
            self.candidate_type.into_into_dart().into_dart(),
            self.priority.into_into_dart().into_dart(),
            self.url.into_into_dart().into_dart(),
            self.relay_protocol.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::IceCandidateStats
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::IceCandidateStats>
    for crate::api::IceCandidateStats
{
    fn into_into_dart(self) -> crate::api::IceCandidateStats {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::IceConnectionState {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::New => 0.into_dart(),
            Self::Checking => 1.into_dart(),
            Self::Connected => 2.into_dart(),
            Self::Completed => 3.into_dart(),
            Self::Failed => 4.into_dart(),
            Self::Disconnected => 5.into_dart(),
            Self::Closed => 6.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::IceConnectionState
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::IceConnectionState>
    for crate::api::IceConnectionState
{
    fn into_into_dart(self) -> crate::api::IceConnectionState {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::IceGatheringState {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::New => 0.into_dart(),
            Self::Gathering => 1.into_dart(),
            Self::Complete => 2.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::IceGatheringState
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::IceGatheringState>
    for crate::api::IceGatheringState
{
    fn into_into_dart(self) -> crate::api::IceGatheringState {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::IceRole {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Unknown => 0.into_dart(),
            Self::Controlling => 1.into_dart(),
            Self::Controlled => 2.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::IceRole
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::IceRole>
    for crate::api::IceRole
{
    fn into_into_dart(self) -> crate::api::IceRole {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::IceTransportsType {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::All => 0.into_dart(),
            Self::Relay => 1.into_dart(),
            Self::NoHost => 2.into_dart(),
            Self::None => 3.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::IceTransportsType
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::IceTransportsType>
    for crate::api::IceTransportsType
{
    fn into_into_dart(self) -> crate::api::IceTransportsType {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::media_info::MediaDeviceInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.device_id.into_into_dart().into_dart(),
            self.kind.into_into_dart().into_dart(),
            self.label.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::media_info::MediaDeviceInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::media_info::MediaDeviceInfo>
    for crate::api::media_info::MediaDeviceInfo
{
    fn into_into_dart(self) -> crate::api::media_info::MediaDeviceInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::media_info::MediaDeviceKind {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::AudioInput => 0.into_dart(),
            Self::AudioOutput => 1.into_dart(),
            Self::VideoInput => 2.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::media_info::MediaDeviceKind
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::media_info::MediaDeviceKind>
    for crate::api::media_info::MediaDeviceKind
{
    fn into_into_dart(self) -> crate::api::media_info::MediaDeviceKind {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::media_info::MediaDisplayInfo
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.device_id.into_into_dart().into_dart(),
            self.title.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::media_info::MediaDisplayInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::media_info::MediaDisplayInfo>
    for crate::api::media_info::MediaDisplayInfo
{
    fn into_into_dart(self) -> crate::api::media_info::MediaDisplayInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::MediaStreamConstraints {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.audio.into_into_dart().into_dart(),
            self.video.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::MediaStreamConstraints
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::MediaStreamConstraints>
    for crate::api::MediaStreamConstraints
{
    fn into_into_dart(self) -> crate::api::MediaStreamConstraints {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::MediaStreamTrack {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.peer_id.into_into_dart().into_dart(),
            self.device_id.into_into_dart().into_dart(),
            self.kind.into_into_dart().into_dart(),
            self.enabled.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::MediaStreamTrack
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::MediaStreamTrack>
    for crate::api::MediaStreamTrack
{
    fn into_into_dart(self) -> crate::api::MediaStreamTrack {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::MediaType {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Audio => 0.into_dart(),
            Self::Video => 1.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::MediaType
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::MediaType>
    for crate::api::MediaType
{
    fn into_into_dart(self) -> crate::api::MediaType {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::NoiseSuppressionLevel {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Low => 0.into_dart(),
            Self::Moderate => 1.into_dart(),
            Self::High => 2.into_dart(),
            Self::VeryHigh => 3.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::NoiseSuppressionLevel
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::NoiseSuppressionLevel>
    for crate::api::NoiseSuppressionLevel
{
    fn into_into_dart(self) -> crate::api::NoiseSuppressionLevel {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::PeerConnectionEvent {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::PeerConnectionEvent::PeerCreated { peer } => {
                [0.into_dart(), peer.into_into_dart().into_dart()].into_dart()
            }
            crate::api::PeerConnectionEvent::IceCandidate {
                sdp_mid,
                sdp_mline_index,
                candidate,
            } => [
                1.into_dart(),
                sdp_mid.into_into_dart().into_dart(),
                sdp_mline_index.into_into_dart().into_dart(),
                candidate.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::PeerConnectionEvent::IceGatheringStateChange(
                field0,
            ) => {
                [2.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::PeerConnectionEvent::IceCandidateError {
                address,
                port,
                url,
                error_code,
                error_text,
            } => [
                3.into_dart(),
                address.into_into_dart().into_dart(),
                port.into_into_dart().into_dart(),
                url.into_into_dart().into_dart(),
                error_code.into_into_dart().into_dart(),
                error_text.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::PeerConnectionEvent::NegotiationNeeded => {
                [4.into_dart()].into_dart()
            }
            crate::api::PeerConnectionEvent::SignallingChange(field0) => {
                [5.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::PeerConnectionEvent::IceConnectionStateChange(
                field0,
            ) => {
                [6.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::PeerConnectionEvent::ConnectionStateChange(field0) => {
                [7.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::PeerConnectionEvent::Track(field0) => {
                [8.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::PeerConnectionEvent
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::PeerConnectionEvent>
    for crate::api::PeerConnectionEvent
{
    fn into_into_dart(self) -> crate::api::PeerConnectionEvent {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::PeerConnectionState {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::New => 0.into_dart(),
            Self::Connecting => 1.into_dart(),
            Self::Connected => 2.into_dart(),
            Self::Disconnected => 3.into_dart(),
            Self::Failed => 4.into_dart(),
            Self::Closed => 5.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::PeerConnectionState
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::PeerConnectionState>
    for crate::api::PeerConnectionState
{
    fn into_into_dart(self) -> crate::api::PeerConnectionState {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::Protocol {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Tcp => 0.into_dart(),
            Self::Udp => 1.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::Protocol
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::Protocol>
    for crate::api::Protocol
{
    fn into_into_dart(self) -> crate::api::Protocol {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::RtcConfiguration {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.ice_transport_policy.into_into_dart().into_dart(),
            self.bundle_policy.into_into_dart().into_dart(),
            self.ice_servers.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::RtcConfiguration
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::RtcConfiguration>
    for crate::api::RtcConfiguration
{
    fn into_into_dart(self) -> crate::api::RtcConfiguration {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::RtcIceCandidateStats {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::RtcIceCandidateStats::Local(field0) => {
                [0.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::RtcIceCandidateStats::Remote(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::RtcIceCandidateStats
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::RtcIceCandidateStats>
    for crate::api::RtcIceCandidateStats
{
    fn into_into_dart(self) -> crate::api::RtcIceCandidateStats {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::RtcIceServer {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.urls.into_into_dart().into_dart(),
            self.username.into_into_dart().into_dart(),
            self.credential.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::RtcIceServer
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::RtcIceServer>
    for crate::api::RtcIceServer
{
    fn into_into_dart(self) -> crate::api::RtcIceServer {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::RtcInboundRtpStreamMediaType
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::RtcInboundRtpStreamMediaType::Audio {
                voice_activity_flag,
                total_samples_received,
                concealed_samples,
                silent_concealed_samples,
                audio_level,
                total_audio_energy,
                total_samples_duration,
            } => [
                0.into_dart(),
                voice_activity_flag.into_into_dart().into_dart(),
                total_samples_received.into_into_dart().into_dart(),
                concealed_samples.into_into_dart().into_dart(),
                silent_concealed_samples.into_into_dart().into_dart(),
                audio_level.into_into_dart().into_dart(),
                total_audio_energy.into_into_dart().into_dart(),
                total_samples_duration.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::RtcInboundRtpStreamMediaType::Video {
                frames_decoded,
                key_frames_decoded,
                frame_width,
                frame_height,
                total_inter_frame_delay,
                frames_per_second,
                fir_count,
                pli_count,
                sli_count,
                concealment_events,
                frames_received,
            } => [
                1.into_dart(),
                frames_decoded.into_into_dart().into_dart(),
                key_frames_decoded.into_into_dart().into_dart(),
                frame_width.into_into_dart().into_dart(),
                frame_height.into_into_dart().into_dart(),
                total_inter_frame_delay.into_into_dart().into_dart(),
                frames_per_second.into_into_dart().into_dart(),
                fir_count.into_into_dart().into_dart(),
                pli_count.into_into_dart().into_dart(),
                sli_count.into_into_dart().into_dart(),
                concealment_events.into_into_dart().into_dart(),
                frames_received.into_into_dart().into_dart(),
            ]
            .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::RtcInboundRtpStreamMediaType
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::RtcInboundRtpStreamMediaType>
    for crate::api::RtcInboundRtpStreamMediaType
{
    fn into_into_dart(self) -> crate::api::RtcInboundRtpStreamMediaType {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::RtcMediaSourceStatsMediaType
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::RtcMediaSourceStatsMediaType::RtcVideoSourceStats {
                width,
                height,
                frames,
                frames_per_second,
            } => [
                0.into_dart(),
                width.into_into_dart().into_dart(),
                height.into_into_dart().into_dart(),
                frames.into_into_dart().into_dart(),
                frames_per_second.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::RtcMediaSourceStatsMediaType::RtcAudioSourceStats {
                audio_level,
                total_audio_energy,
                total_samples_duration,
                echo_return_loss,
                echo_return_loss_enhancement,
            } => [
                1.into_dart(),
                audio_level.into_into_dart().into_dart(),
                total_audio_energy.into_into_dart().into_dart(),
                total_samples_duration.into_into_dart().into_dart(),
                echo_return_loss.into_into_dart().into_dart(),
                echo_return_loss_enhancement.into_into_dart().into_dart(),
            ]
            .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::RtcMediaSourceStatsMediaType
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::RtcMediaSourceStatsMediaType>
    for crate::api::RtcMediaSourceStatsMediaType
{
    fn into_into_dart(self) -> crate::api::RtcMediaSourceStatsMediaType {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::RtcOutboundRtpStreamStatsMediaType
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::RtcOutboundRtpStreamStatsMediaType::Audio {
                total_samples_sent,
                voice_activity_flag,
            } => [
                0.into_dart(),
                total_samples_sent.into_into_dart().into_dart(),
                voice_activity_flag.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::RtcOutboundRtpStreamStatsMediaType::Video {
                frame_width,
                frame_height,
                frames_per_second,
            } => [
                1.into_dart(),
                frame_width.into_into_dart().into_dart(),
                frame_height.into_into_dart().into_dart(),
                frames_per_second.into_into_dart().into_dart(),
            ]
            .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::RtcOutboundRtpStreamStatsMediaType
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::api::RtcOutboundRtpStreamStatsMediaType,
    > for crate::api::RtcOutboundRtpStreamStatsMediaType
{
    fn into_into_dart(self) -> crate::api::RtcOutboundRtpStreamStatsMediaType {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::RtcRtpEncodingParameters {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.rid.into_into_dart().into_dart(),
            self.active.into_into_dart().into_dart(),
            self.max_bitrate.into_into_dart().into_dart(),
            self.max_framerate.into_into_dart().into_dart(),
            self.scale_resolution_down_by.into_into_dart().into_dart(),
            self.scalability_mode.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::RtcRtpEncodingParameters
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::RtcRtpEncodingParameters>
    for crate::api::RtcRtpEncodingParameters
{
    fn into_into_dart(self) -> crate::api::RtcRtpEncodingParameters {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::RtcRtpSendParameters {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.encodings.into_into_dart().into_dart(),
            self.inner.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::RtcRtpSendParameters
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::RtcRtpSendParameters>
    for crate::api::RtcRtpSendParameters
{
    fn into_into_dart(self) -> crate::api::RtcRtpSendParameters {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::RtcRtpTransceiver {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.peer.into_into_dart().into_dart(),
            self.transceiver.into_into_dart().into_dart(),
            self.mid.into_into_dart().into_dart(),
            self.direction.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::RtcRtpTransceiver
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::RtcRtpTransceiver>
    for crate::api::RtcRtpTransceiver
{
    fn into_into_dart(self) -> crate::api::RtcRtpTransceiver {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::RtcSessionDescription {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.sdp.into_into_dart().into_dart(),
            self.kind.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::RtcSessionDescription
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::RtcSessionDescription>
    for crate::api::RtcSessionDescription
{
    fn into_into_dart(self) -> crate::api::RtcSessionDescription {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::RtcStats {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.timestamp_us.into_into_dart().into_dart(),
            self.kind.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::RtcStats
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::RtcStats>
    for crate::api::RtcStats
{
    fn into_into_dart(self) -> crate::api::RtcStats {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::RtcStatsIceCandidatePairState
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Frozen => 0.into_dart(),
            Self::Waiting => 1.into_dart(),
            Self::InProgress => 2.into_dart(),
            Self::Failed => 3.into_dart(),
            Self::Succeeded => 4.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::RtcStatsIceCandidatePairState
{
}
impl
    flutter_rust_bridge::IntoIntoDart<crate::api::RtcStatsIceCandidatePairState>
    for crate::api::RtcStatsIceCandidatePairState
{
    fn into_into_dart(self) -> crate::api::RtcStatsIceCandidatePairState {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::RtcStatsType {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::RtcStatsType::RtcMediaSourceStats {
                track_identifier,
                kind,
            } => [
                0.into_dart(),
                track_identifier.into_into_dart().into_dart(),
                kind.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::RtcStatsType::RtcIceCandidateStats(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::RtcStatsType::RtcOutboundRtpStreamStats {
                track_id,
                media_type,
                bytes_sent,
                packets_sent,
                media_source_id,
            } => [
                2.into_dart(),
                track_id.into_into_dart().into_dart(),
                media_type.into_into_dart().into_dart(),
                bytes_sent.into_into_dart().into_dart(),
                packets_sent.into_into_dart().into_dart(),
                media_source_id.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::RtcStatsType::RtcInboundRtpStreamStats {
                remote_id,
                bytes_received,
                packets_received,
                packets_lost,
                jitter,
                total_decode_time,
                jitter_buffer_emitted_count,
                media_type,
            } => [
                3.into_dart(),
                remote_id.into_into_dart().into_dart(),
                bytes_received.into_into_dart().into_dart(),
                packets_received.into_into_dart().into_dart(),
                packets_lost.into_into_dart().into_dart(),
                jitter.into_into_dart().into_dart(),
                total_decode_time.into_into_dart().into_dart(),
                jitter_buffer_emitted_count.into_into_dart().into_dart(),
                media_type.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::RtcStatsType::RtcIceCandidatePairStats {
                state,
                nominated,
                bytes_sent,
                bytes_received,
                total_round_trip_time,
                current_round_trip_time,
                available_outgoing_bitrate,
            } => [
                4.into_dart(),
                state.into_into_dart().into_dart(),
                nominated.into_into_dart().into_dart(),
                bytes_sent.into_into_dart().into_dart(),
                bytes_received.into_into_dart().into_dart(),
                total_round_trip_time.into_into_dart().into_dart(),
                current_round_trip_time.into_into_dart().into_dart(),
                available_outgoing_bitrate.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::RtcStatsType::RtcTransportStats {
                packets_sent,
                packets_received,
                bytes_sent,
                bytes_received,
                ice_role,
            } => [
                5.into_dart(),
                packets_sent.into_into_dart().into_dart(),
                packets_received.into_into_dart().into_dart(),
                bytes_sent.into_into_dart().into_dart(),
                bytes_received.into_into_dart().into_dart(),
                ice_role.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::RtcStatsType::RtcRemoteInboundRtpStreamStats {
                local_id,
                jitter,
                round_trip_time,
                fraction_lost,
                reports_received,
                round_trip_time_measurements,
            } => [
                6.into_dart(),
                local_id.into_into_dart().into_dart(),
                jitter.into_into_dart().into_dart(),
                round_trip_time.into_into_dart().into_dart(),
                fraction_lost.into_into_dart().into_dart(),
                reports_received.into_into_dart().into_dart(),
                round_trip_time_measurements.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::RtcStatsType::RtcRemoteOutboundRtpStreamStats {
                local_id,
                remote_timestamp,
                reports_sent,
            } => [
                7.into_dart(),
                local_id.into_into_dart().into_dart(),
                remote_timestamp.into_into_dart().into_dart(),
                reports_sent.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::RtcStatsType::Unimplemented => {
                [8.into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::RtcStatsType
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::RtcStatsType>
    for crate::api::RtcStatsType
{
    fn into_into_dart(self) -> crate::api::RtcStatsType {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::RtcTrackEvent {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.track.into_into_dart().into_dart(),
            self.transceiver.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::RtcTrackEvent
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::RtcTrackEvent>
    for crate::api::RtcTrackEvent
{
    fn into_into_dart(self) -> crate::api::RtcTrackEvent {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::RtcpFeedback {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.message_type.into_into_dart().into_dart(),
            self.kind.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::RtcpFeedback
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::RtcpFeedback>
    for crate::api::RtcpFeedback
{
    fn into_into_dart(self) -> crate::api::RtcpFeedback {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::RtcpFeedbackMessageType {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::GenericNACK => 0.into_dart(),
            Self::Pli => 1.into_dart(),
            Self::Fir => 2.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::RtcpFeedbackMessageType
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::RtcpFeedbackMessageType>
    for crate::api::RtcpFeedbackMessageType
{
    fn into_into_dart(self) -> crate::api::RtcpFeedbackMessageType {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::RtcpFeedbackType {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Ccm => 0.into_dart(),
            Self::Lntf => 1.into_dart(),
            Self::Nack => 2.into_dart(),
            Self::Remb => 3.into_dart(),
            Self::TransportCC => 4.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::RtcpFeedbackType
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::RtcpFeedbackType>
    for crate::api::RtcpFeedbackType
{
    fn into_into_dart(self) -> crate::api::RtcpFeedbackType {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::RtpCapabilities {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.codecs.into_into_dart().into_dart(),
            self.header_extensions.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::RtpCapabilities
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::RtpCapabilities>
    for crate::api::RtpCapabilities
{
    fn into_into_dart(self) -> crate::api::RtpCapabilities {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::RtpCodecCapability {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.preferred_payload_type.into_into_dart().into_dart(),
            self.scalability_modes.into_into_dart().into_dart(),
            self.mime_type.into_into_dart().into_dart(),
            self.name.into_into_dart().into_dart(),
            self.kind.into_into_dart().into_dart(),
            self.clock_rate.into_into_dart().into_dart(),
            self.num_channels.into_into_dart().into_dart(),
            self.parameters.into_into_dart().into_dart(),
            self.feedback.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::RtpCodecCapability
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::RtpCodecCapability>
    for crate::api::RtpCodecCapability
{
    fn into_into_dart(self) -> crate::api::RtpCodecCapability {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::RtpHeaderExtensionCapability
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.uri.into_into_dart().into_dart(),
            self.preferred_id.into_into_dart().into_dart(),
            self.preferred_encrypted.into_into_dart().into_dart(),
            self.direction.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::RtpHeaderExtensionCapability
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::RtpHeaderExtensionCapability>
    for crate::api::RtpHeaderExtensionCapability
{
    fn into_into_dart(self) -> crate::api::RtpHeaderExtensionCapability {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::RtpTransceiverDirection {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::SendRecv => 0.into_dart(),
            Self::SendOnly => 1.into_dart(),
            Self::RecvOnly => 2.into_dart(),
            Self::Inactive => 3.into_dart(),
            Self::Stopped => 4.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::RtpTransceiverDirection
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::RtpTransceiverDirection>
    for crate::api::RtpTransceiverDirection
{
    fn into_into_dart(self) -> crate::api::RtpTransceiverDirection {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::RtpTransceiverInit {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.direction.into_into_dart().into_dart(),
            self.send_encodings.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::RtpTransceiverInit
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::RtpTransceiverInit>
    for crate::api::RtpTransceiverInit
{
    fn into_into_dart(self) -> crate::api::RtpTransceiverInit {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::ScalabilityMode {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::L1T1 => 0.into_dart(),
            Self::L1T2 => 1.into_dart(),
            Self::L1T3 => 2.into_dart(),
            Self::L2T1 => 3.into_dart(),
            Self::L2T1h => 4.into_dart(),
            Self::L2t1Key => 5.into_dart(),
            Self::L2T2 => 6.into_dart(),
            Self::L2T2h => 7.into_dart(),
            Self::L2T2Key => 8.into_dart(),
            Self::L2T2KeyShift => 9.into_dart(),
            Self::L2T3 => 10.into_dart(),
            Self::L2T3h => 11.into_dart(),
            Self::L2T3Key => 12.into_dart(),
            Self::L3T1 => 13.into_dart(),
            Self::L3T1h => 14.into_dart(),
            Self::L3T1Key => 15.into_dart(),
            Self::L3T2 => 16.into_dart(),
            Self::L3T2h => 17.into_dart(),
            Self::L3T2Key => 18.into_dart(),
            Self::L3T3 => 19.into_dart(),
            Self::L3T3h => 20.into_dart(),
            Self::L3T3Key => 21.into_dart(),
            Self::S2T1 => 22.into_dart(),
            Self::S2T1h => 23.into_dart(),
            Self::S2T2 => 24.into_dart(),
            Self::S2T2h => 25.into_dart(),
            Self::S2T3 => 26.into_dart(),
            Self::S2T3h => 27.into_dart(),
            Self::S3T1 => 28.into_dart(),
            Self::S3T1h => 29.into_dart(),
            Self::S3T2 => 30.into_dart(),
            Self::S3T2h => 31.into_dart(),
            Self::S3T3 => 32.into_dart(),
            Self::S3T3h => 33.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::ScalabilityMode
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::ScalabilityMode>
    for crate::api::ScalabilityMode
{
    fn into_into_dart(self) -> crate::api::ScalabilityMode {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::SdpType {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Offer => 0.into_dart(),
            Self::PrAnswer => 1.into_dart(),
            Self::Answer => 2.into_dart(),
            Self::Rollback => 3.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::SdpType
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::SdpType>
    for crate::api::SdpType
{
    fn into_into_dart(self) -> crate::api::SdpType {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::SignalingState {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Stable => 0.into_dart(),
            Self::HaveLocalOffer => 1.into_dart(),
            Self::HaveLocalPrAnswer => 2.into_dart(),
            Self::HaveRemoteOffer => 3.into_dart(),
            Self::HaveRemotePrAnswer => 4.into_dart(),
            Self::Closed => 5.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::SignalingState
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::SignalingState>
    for crate::api::SignalingState
{
    fn into_into_dart(self) -> crate::api::SignalingState {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::renderer::TextureEvent {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::renderer::TextureEvent::OnTextureChange {
                texture_id,
                width,
                height,
                rotation,
            } => [
                0.into_dart(),
                texture_id.into_into_dart().into_dart(),
                width.into_into_dart().into_dart(),
                height.into_into_dart().into_dart(),
                rotation.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::renderer::TextureEvent::OnFirstFrameRendered {
                texture_id,
            } => [1.into_dart(), texture_id.into_into_dart().into_dart()]
                .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::renderer::TextureEvent
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::renderer::TextureEvent>
    for crate::renderer::TextureEvent
{
    fn into_into_dart(self) -> crate::renderer::TextureEvent {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::TrackEvent {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::TrackEvent::Ended => [0.into_dart()].into_dart(),
            crate::api::TrackEvent::AudioLevelUpdated(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::TrackEvent::TrackCreated => [2.into_dart()].into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::TrackEvent
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::TrackEvent>
    for crate::api::TrackEvent
{
    fn into_into_dart(self) -> crate::api::TrackEvent {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::TrackState {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Live => 0.into_dart(),
            Self::Ended => 1.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::TrackState
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::TrackState>
    for crate::api::TrackState
{
    fn into_into_dart(self) -> crate::api::TrackState {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::VideoCodec {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::AV1 => 0.into_dart(),
            Self::H264 => 1.into_dart(),
            Self::H265 => 2.into_dart(),
            Self::VP8 => 3.into_dart(),
            Self::VP9 => 4.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::VideoCodec
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::VideoCodec>
    for crate::api::VideoCodec
{
    fn into_into_dart(self) -> crate::api::VideoCodec {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::VideoCodecInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.is_hardware_accelerated.into_into_dart().into_dart(),
            self.codec.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::VideoCodecInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::VideoCodecInfo>
    for crate::api::VideoCodecInfo
{
    fn into_into_dart(self) -> crate::api::VideoCodecInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::VideoConstraints {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.device_id.into_into_dart().into_dart(),
            self.width.into_into_dart().into_dart(),
            self.height.into_into_dart().into_dart(),
            self.frame_rate.into_into_dart().into_dart(),
            self.is_display.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::VideoConstraints
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::VideoConstraints>
    for crate::api::VideoConstraints
{
    fn into_into_dart(self) -> crate::api::VideoConstraints {
        self
    }
}

impl SseEncode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <String>::sse_encode(format!("{:?}", self), serializer);
    }
}

impl SseEncode for RustOpaqueMoi<Arc<PeerConnection>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueMoi<Arc<RtpEncodingParameters>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueMoi<Arc<RtpParameters>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueMoi<Arc<RtpTransceiver>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for StreamSink<
        crate::api::PeerConnectionEvent,
        flutter_rust_bridge::for_generated::SseCodec,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        unimplemented!("")
    }
}

impl SseEncode
    for StreamSink<
        crate::renderer::TextureEvent,
        flutter_rust_bridge::for_generated::SseCodec,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        unimplemented!("")
    }
}

impl SseEncode
    for StreamSink<
        crate::api::TrackEvent,
        flutter_rust_bridge::for_generated::SseCodec,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        unimplemented!("")
    }
}

impl SseEncode
    for StreamSink<(), flutter_rust_bridge::for_generated::SseCodec>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        unimplemented!("")
    }
}

impl SseEncode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <Vec<u8>>::sse_encode(self.into_bytes(), serializer);
    }
}

impl SseEncode for crate::api::AudioConstraints {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <Option<String>>::sse_encode(self.device_id, serializer);
        <crate::api::AudioProcessingConstraints>::sse_encode(
            self.processing,
            serializer,
        );
    }
}

impl SseEncode for crate::api::AudioProcessingConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <bool>::sse_encode(self.auto_gain_control, serializer);
        <bool>::sse_encode(self.high_pass_filter, serializer);
        <bool>::sse_encode(self.noise_suppression, serializer);
        <crate::api::NoiseSuppressionLevel>::sse_encode(
            self.noise_suppression_level,
            serializer,
        );
        <bool>::sse_encode(self.echo_cancellation, serializer);
    }
}

impl SseEncode for crate::api::AudioProcessingConstraints {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <Option<bool>>::sse_encode(self.auto_gain_control, serializer);
        <Option<bool>>::sse_encode(self.high_pass_filter, serializer);
        <Option<bool>>::sse_encode(self.noise_suppression, serializer);
        <Option<crate::api::NoiseSuppressionLevel>>::sse_encode(
            self.noise_suppression_level,
            serializer,
        );
        <Option<bool>>::sse_encode(self.echo_cancellation, serializer);
    }
}

impl SseEncode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        serializer.cursor.write_u8(self as _).unwrap();
    }
}

impl SseEncode for crate::api::BundlePolicy {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(
            match self {
                crate::api::BundlePolicy::Balanced => 0,
                crate::api::BundlePolicy::MaxBundle => 1,
                crate::api::BundlePolicy::MaxCompat => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::CandidateType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(
            match self {
                crate::api::CandidateType::Host => 0,
                crate::api::CandidateType::Srflx => 1,
                crate::api::CandidateType::Prflx => 2,
                crate::api::CandidateType::Relay => 3,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for f64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        serializer.cursor.write_f64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for crate::api::GetMediaError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        match self {
            crate::api::GetMediaError::Audio(field0) => {
                <i32>::sse_encode(0, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::api::GetMediaError::Video(field0) => {
                <i32>::sse_encode(1, serializer);
                <String>::sse_encode(field0, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::GetMediaResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        match self {
            crate::api::GetMediaResult::Ok(field0) => {
                <i32>::sse_encode(0, serializer);
                <Vec<crate::api::MediaStreamTrack>>::sse_encode(
                    field0, serializer,
                );
            }
            crate::api::GetMediaResult::Err(field0) => {
                <i32>::sse_encode(1, serializer);
                <crate::api::GetMediaError>::sse_encode(field0, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        serializer.cursor.write_i32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for i64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        serializer.cursor.write_i64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for crate::api::IceCandidateStats {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <Option<String>>::sse_encode(self.transport_id, serializer);
        <Option<String>>::sse_encode(self.address, serializer);
        <Option<i32>>::sse_encode(self.port, serializer);
        <crate::api::Protocol>::sse_encode(self.protocol, serializer);
        <crate::api::CandidateType>::sse_encode(
            self.candidate_type,
            serializer,
        );
        <Option<i32>>::sse_encode(self.priority, serializer);
        <Option<String>>::sse_encode(self.url, serializer);
        <Option<crate::api::Protocol>>::sse_encode(
            self.relay_protocol,
            serializer,
        );
    }
}

impl SseEncode for crate::api::IceConnectionState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(
            match self {
                crate::api::IceConnectionState::New => 0,
                crate::api::IceConnectionState::Checking => 1,
                crate::api::IceConnectionState::Connected => 2,
                crate::api::IceConnectionState::Completed => 3,
                crate::api::IceConnectionState::Failed => 4,
                crate::api::IceConnectionState::Disconnected => 5,
                crate::api::IceConnectionState::Closed => 6,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::IceGatheringState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(
            match self {
                crate::api::IceGatheringState::New => 0,
                crate::api::IceGatheringState::Gathering => 1,
                crate::api::IceGatheringState::Complete => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::IceRole {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(
            match self {
                crate::api::IceRole::Unknown => 0,
                crate::api::IceRole::Controlling => 1,
                crate::api::IceRole::Controlled => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::IceTransportsType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(
            match self {
                crate::api::IceTransportsType::All => 0,
                crate::api::IceTransportsType::Relay => 1,
                crate::api::IceTransportsType::NoHost => 2,
                crate::api::IceTransportsType::None => 3,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for Vec<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <String>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::media_info::MediaDeviceInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::media_info::MediaDeviceInfo>::sse_encode(
                item, serializer,
            );
        }
    }
}

impl SseEncode for Vec<crate::api::media_info::MediaDisplayInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::media_info::MediaDisplayInfo>::sse_encode(
                item, serializer,
            );
        }
    }
}

impl SseEncode for Vec<crate::api::MediaStreamTrack> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::MediaStreamTrack>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u8>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode
    for Vec<(
        crate::api::RtcRtpEncodingParameters,
        RustOpaqueMoi<Arc<RtpEncodingParameters>>,
    )>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(
                crate::api::RtcRtpEncodingParameters,
                RustOpaqueMoi<Arc<RtpEncodingParameters>>,
            )>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<(String, String)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(String, String)>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::RtcIceServer> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::RtcIceServer>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::RtcRtpEncodingParameters> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::RtcRtpEncodingParameters>::sse_encode(
                item, serializer,
            );
        }
    }
}

impl SseEncode for Vec<crate::api::RtcRtpTransceiver> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::RtcRtpTransceiver>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::RtcStats> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::RtcStats>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::RtcpFeedback> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::RtcpFeedback>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::RtpCodecCapability> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::RtpCodecCapability>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::RtpHeaderExtensionCapability> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::RtpHeaderExtensionCapability>::sse_encode(
                item, serializer,
            );
        }
    }
}

impl SseEncode for Vec<crate::api::ScalabilityMode> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::ScalabilityMode>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::VideoCodecInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::VideoCodecInfo>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for crate::api::media_info::MediaDeviceInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <String>::sse_encode(self.device_id, serializer);
        <crate::api::media_info::MediaDeviceKind>::sse_encode(
            self.kind, serializer,
        );
        <String>::sse_encode(self.label, serializer);
    }
}

impl SseEncode for crate::api::media_info::MediaDeviceKind {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(
            match self {
                crate::api::media_info::MediaDeviceKind::AudioInput => 0,
                crate::api::media_info::MediaDeviceKind::AudioOutput => 1,
                crate::api::media_info::MediaDeviceKind::VideoInput => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::media_info::MediaDisplayInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <String>::sse_encode(self.device_id, serializer);
        <Option<String>>::sse_encode(self.title, serializer);
    }
}

impl SseEncode for crate::api::MediaStreamConstraints {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <Option<crate::api::AudioConstraints>>::sse_encode(
            self.audio, serializer,
        );
        <Option<crate::api::VideoConstraints>>::sse_encode(
            self.video, serializer,
        );
    }
}

impl SseEncode for crate::api::MediaStreamTrack {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <String>::sse_encode(self.id, serializer);
        <Option<u32>>::sse_encode(self.peer_id, serializer);
        <String>::sse_encode(self.device_id, serializer);
        <crate::api::MediaType>::sse_encode(self.kind, serializer);
        <bool>::sse_encode(self.enabled, serializer);
    }
}

impl SseEncode for crate::api::MediaType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(
            match self {
                crate::api::MediaType::Audio => 0,
                crate::api::MediaType::Video => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::NoiseSuppressionLevel {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(
            match self {
                crate::api::NoiseSuppressionLevel::Low => 0,
                crate::api::NoiseSuppressionLevel::Moderate => 1,
                crate::api::NoiseSuppressionLevel::High => 2,
                crate::api::NoiseSuppressionLevel::VeryHigh => 3,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <String>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::AudioConstraints> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::AudioConstraints>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<bool> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <bool>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<f64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <f64>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<i32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <i32>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::IceRole> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::IceRole>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::MediaStreamTrack> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::MediaStreamTrack>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::NoiseSuppressionLevel> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::NoiseSuppressionLevel>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::Protocol> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::Protocol>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::RtcInboundRtpStreamMediaType> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::RtcInboundRtpStreamMediaType>::sse_encode(
                value, serializer,
            );
        }
    }
}

impl SseEncode for Option<crate::api::RtcpFeedbackMessageType> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::RtcpFeedbackMessageType>::sse_encode(
                value, serializer,
            );
        }
    }
}

impl SseEncode for Option<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u32>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u64>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::VideoConstraints> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::VideoConstraints>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for crate::api::PeerConnectionEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        match self {
            crate::api::PeerConnectionEvent::PeerCreated { peer } => {
                <i32>::sse_encode(0, serializer);
                <RustOpaqueMoi<Arc<PeerConnection>>>::sse_encode(
                    peer, serializer,
                );
            }
            crate::api::PeerConnectionEvent::IceCandidate {
                sdp_mid,
                sdp_mline_index,
                candidate,
            } => {
                <i32>::sse_encode(1, serializer);
                <String>::sse_encode(sdp_mid, serializer);
                <i32>::sse_encode(sdp_mline_index, serializer);
                <String>::sse_encode(candidate, serializer);
            }
            crate::api::PeerConnectionEvent::IceGatheringStateChange(
                field0,
            ) => {
                <i32>::sse_encode(2, serializer);
                <crate::api::IceGatheringState>::sse_encode(field0, serializer);
            }
            crate::api::PeerConnectionEvent::IceCandidateError {
                address,
                port,
                url,
                error_code,
                error_text,
            } => {
                <i32>::sse_encode(3, serializer);
                <String>::sse_encode(address, serializer);
                <i32>::sse_encode(port, serializer);
                <String>::sse_encode(url, serializer);
                <i32>::sse_encode(error_code, serializer);
                <String>::sse_encode(error_text, serializer);
            }
            crate::api::PeerConnectionEvent::NegotiationNeeded => {
                <i32>::sse_encode(4, serializer);
            }
            crate::api::PeerConnectionEvent::SignallingChange(field0) => {
                <i32>::sse_encode(5, serializer);
                <crate::api::SignalingState>::sse_encode(field0, serializer);
            }
            crate::api::PeerConnectionEvent::IceConnectionStateChange(
                field0,
            ) => {
                <i32>::sse_encode(6, serializer);
                <crate::api::IceConnectionState>::sse_encode(
                    field0, serializer,
                );
            }
            crate::api::PeerConnectionEvent::ConnectionStateChange(field0) => {
                <i32>::sse_encode(7, serializer);
                <crate::api::PeerConnectionState>::sse_encode(
                    field0, serializer,
                );
            }
            crate::api::PeerConnectionEvent::Track(field0) => {
                <i32>::sse_encode(8, serializer);
                <crate::api::RtcTrackEvent>::sse_encode(field0, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::PeerConnectionState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(
            match self {
                crate::api::PeerConnectionState::New => 0,
                crate::api::PeerConnectionState::Connecting => 1,
                crate::api::PeerConnectionState::Connected => 2,
                crate::api::PeerConnectionState::Disconnected => 3,
                crate::api::PeerConnectionState::Failed => 4,
                crate::api::PeerConnectionState::Closed => 5,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::Protocol {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(
            match self {
                crate::api::Protocol::Tcp => 0,
                crate::api::Protocol::Udp => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode
    for (
        crate::api::RtcRtpEncodingParameters,
        RustOpaqueMoi<Arc<RtpEncodingParameters>>,
    )
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <crate::api::RtcRtpEncodingParameters>::sse_encode(self.0, serializer);
        <RustOpaqueMoi<Arc<RtpEncodingParameters>>>::sse_encode(
            self.1, serializer,
        );
    }
}

impl SseEncode for (String, String) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <String>::sse_encode(self.0, serializer);
        <String>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for crate::api::RtcConfiguration {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <crate::api::IceTransportsType>::sse_encode(
            self.ice_transport_policy,
            serializer,
        );
        <crate::api::BundlePolicy>::sse_encode(self.bundle_policy, serializer);
        <Vec<crate::api::RtcIceServer>>::sse_encode(
            self.ice_servers,
            serializer,
        );
    }
}

impl SseEncode for crate::api::RtcIceCandidateStats {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        match self {
            crate::api::RtcIceCandidateStats::Local(field0) => {
                <i32>::sse_encode(0, serializer);
                <crate::api::IceCandidateStats>::sse_encode(field0, serializer);
            }
            crate::api::RtcIceCandidateStats::Remote(field0) => {
                <i32>::sse_encode(1, serializer);
                <crate::api::IceCandidateStats>::sse_encode(field0, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::RtcIceServer {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <Vec<String>>::sse_encode(self.urls, serializer);
        <String>::sse_encode(self.username, serializer);
        <String>::sse_encode(self.credential, serializer);
    }
}

impl SseEncode for crate::api::RtcInboundRtpStreamMediaType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        match self {
            crate::api::RtcInboundRtpStreamMediaType::Audio {
                voice_activity_flag,
                total_samples_received,
                concealed_samples,
                silent_concealed_samples,
                audio_level,
                total_audio_energy,
                total_samples_duration,
            } => {
                <i32>::sse_encode(0, serializer);
                <Option<bool>>::sse_encode(voice_activity_flag, serializer);
                <Option<u64>>::sse_encode(total_samples_received, serializer);
                <Option<u64>>::sse_encode(concealed_samples, serializer);
                <Option<u64>>::sse_encode(silent_concealed_samples, serializer);
                <Option<f64>>::sse_encode(audio_level, serializer);
                <Option<f64>>::sse_encode(total_audio_energy, serializer);
                <Option<f64>>::sse_encode(total_samples_duration, serializer);
            }
            crate::api::RtcInboundRtpStreamMediaType::Video {
                frames_decoded,
                key_frames_decoded,
                frame_width,
                frame_height,
                total_inter_frame_delay,
                frames_per_second,
                fir_count,
                pli_count,
                sli_count,
                concealment_events,
                frames_received,
            } => {
                <i32>::sse_encode(1, serializer);
                <Option<u32>>::sse_encode(frames_decoded, serializer);
                <Option<u32>>::sse_encode(key_frames_decoded, serializer);
                <Option<u32>>::sse_encode(frame_width, serializer);
                <Option<u32>>::sse_encode(frame_height, serializer);
                <Option<f64>>::sse_encode(total_inter_frame_delay, serializer);
                <Option<f64>>::sse_encode(frames_per_second, serializer);
                <Option<u32>>::sse_encode(fir_count, serializer);
                <Option<u32>>::sse_encode(pli_count, serializer);
                <Option<u32>>::sse_encode(sli_count, serializer);
                <Option<u64>>::sse_encode(concealment_events, serializer);
                <Option<i32>>::sse_encode(frames_received, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::RtcMediaSourceStatsMediaType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        match self {
            crate::api::RtcMediaSourceStatsMediaType::RtcVideoSourceStats {
                width,
                height,
                frames,
                frames_per_second,
            } => {
                <i32>::sse_encode(0, serializer);
                <Option<u32>>::sse_encode(width, serializer);
                <Option<u32>>::sse_encode(height, serializer);
                <Option<u32>>::sse_encode(frames, serializer);
                <Option<f64>>::sse_encode(frames_per_second, serializer);
            }
            crate::api::RtcMediaSourceStatsMediaType::RtcAudioSourceStats {
                audio_level,
                total_audio_energy,
                total_samples_duration,
                echo_return_loss,
                echo_return_loss_enhancement,
            } => {
                <i32>::sse_encode(1, serializer);
                <Option<f64>>::sse_encode(audio_level, serializer);
                <Option<f64>>::sse_encode(total_audio_energy, serializer);
                <Option<f64>>::sse_encode(total_samples_duration, serializer);
                <Option<f64>>::sse_encode(echo_return_loss, serializer);
                <Option<f64>>::sse_encode(
                    echo_return_loss_enhancement,
                    serializer,
                );
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::RtcOutboundRtpStreamStatsMediaType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        match self {
            crate::api::RtcOutboundRtpStreamStatsMediaType::Audio {
                total_samples_sent,
                voice_activity_flag,
            } => {
                <i32>::sse_encode(0, serializer);
                <Option<u64>>::sse_encode(total_samples_sent, serializer);
                <Option<bool>>::sse_encode(voice_activity_flag, serializer);
            }
            crate::api::RtcOutboundRtpStreamStatsMediaType::Video {
                frame_width,
                frame_height,
                frames_per_second,
            } => {
                <i32>::sse_encode(1, serializer);
                <Option<u32>>::sse_encode(frame_width, serializer);
                <Option<u32>>::sse_encode(frame_height, serializer);
                <Option<f64>>::sse_encode(frames_per_second, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::RtcRtpEncodingParameters {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <String>::sse_encode(self.rid, serializer);
        <bool>::sse_encode(self.active, serializer);
        <Option<i32>>::sse_encode(self.max_bitrate, serializer);
        <Option<f64>>::sse_encode(self.max_framerate, serializer);
        <Option<f64>>::sse_encode(self.scale_resolution_down_by, serializer);
        <Option<String>>::sse_encode(self.scalability_mode, serializer);
    }
}

impl SseEncode for crate::api::RtcRtpSendParameters {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <Vec<(
            crate::api::RtcRtpEncodingParameters,
            RustOpaqueMoi<Arc<RtpEncodingParameters>>,
        )>>::sse_encode(self.encodings, serializer);
        <RustOpaqueMoi<Arc<RtpParameters>>>::sse_encode(self.inner, serializer);
    }
}

impl SseEncode for crate::api::RtcRtpTransceiver {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <RustOpaqueMoi<Arc<PeerConnection>>>::sse_encode(self.peer, serializer);
        <RustOpaqueMoi<Arc<RtpTransceiver>>>::sse_encode(
            self.transceiver,
            serializer,
        );
        <Option<String>>::sse_encode(self.mid, serializer);
        <crate::api::RtpTransceiverDirection>::sse_encode(
            self.direction,
            serializer,
        );
    }
}

impl SseEncode for crate::api::RtcSessionDescription {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <String>::sse_encode(self.sdp, serializer);
        <crate::api::SdpType>::sse_encode(self.kind, serializer);
    }
}

impl SseEncode for crate::api::RtcStats {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <String>::sse_encode(self.id, serializer);
        <i64>::sse_encode(self.timestamp_us, serializer);
        <crate::api::RtcStatsType>::sse_encode(self.kind, serializer);
    }
}

impl SseEncode for crate::api::RtcStatsIceCandidatePairState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(
            match self {
                crate::api::RtcStatsIceCandidatePairState::Frozen => 0,
                crate::api::RtcStatsIceCandidatePairState::Waiting => 1,
                crate::api::RtcStatsIceCandidatePairState::InProgress => 2,
                crate::api::RtcStatsIceCandidatePairState::Failed => 3,
                crate::api::RtcStatsIceCandidatePairState::Succeeded => 4,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::RtcStatsType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        match self {
            crate::api::RtcStatsType::RtcMediaSourceStats {
                track_identifier,
                kind,
            } => {
                <i32>::sse_encode(0, serializer);
                <Option<String>>::sse_encode(track_identifier, serializer);
                <crate::api::RtcMediaSourceStatsMediaType>::sse_encode(
                    kind, serializer,
                );
            }
            crate::api::RtcStatsType::RtcIceCandidateStats(field0) => {
                <i32>::sse_encode(1, serializer);
                <crate::api::RtcIceCandidateStats>::sse_encode(
                    field0, serializer,
                );
            }
            crate::api::RtcStatsType::RtcOutboundRtpStreamStats {
                track_id,
                media_type,
                bytes_sent,
                packets_sent,
                media_source_id,
            } => {
                <i32>::sse_encode(2, serializer);
                <Option<String>>::sse_encode(track_id, serializer);
                <crate::api::RtcOutboundRtpStreamStatsMediaType>::sse_encode(
                    media_type, serializer,
                );
                <Option<u64>>::sse_encode(bytes_sent, serializer);
                <Option<u32>>::sse_encode(packets_sent, serializer);
                <Option<String>>::sse_encode(media_source_id, serializer);
            }
            crate::api::RtcStatsType::RtcInboundRtpStreamStats {
                remote_id,
                bytes_received,
                packets_received,
                packets_lost,
                jitter,
                total_decode_time,
                jitter_buffer_emitted_count,
                media_type,
            } => {
                <i32>::sse_encode(3, serializer);
                <Option<String>>::sse_encode(remote_id, serializer);
                <Option<u64>>::sse_encode(bytes_received, serializer);
                <Option<u32>>::sse_encode(packets_received, serializer);
                <Option<u64>>::sse_encode(packets_lost, serializer);
                <Option<f64>>::sse_encode(jitter, serializer);
                <Option<f64>>::sse_encode(total_decode_time, serializer);
                <Option<u64>>::sse_encode(
                    jitter_buffer_emitted_count,
                    serializer,
                );
                <Option<crate::api::RtcInboundRtpStreamMediaType>>::sse_encode(
                    media_type, serializer,
                );
            }
            crate::api::RtcStatsType::RtcIceCandidatePairStats {
                state,
                nominated,
                bytes_sent,
                bytes_received,
                total_round_trip_time,
                current_round_trip_time,
                available_outgoing_bitrate,
            } => {
                <i32>::sse_encode(4, serializer);
                <crate::api::RtcStatsIceCandidatePairState>::sse_encode(
                    state, serializer,
                );
                <Option<bool>>::sse_encode(nominated, serializer);
                <Option<u64>>::sse_encode(bytes_sent, serializer);
                <Option<u64>>::sse_encode(bytes_received, serializer);
                <Option<f64>>::sse_encode(total_round_trip_time, serializer);
                <Option<f64>>::sse_encode(current_round_trip_time, serializer);
                <Option<f64>>::sse_encode(
                    available_outgoing_bitrate,
                    serializer,
                );
            }
            crate::api::RtcStatsType::RtcTransportStats {
                packets_sent,
                packets_received,
                bytes_sent,
                bytes_received,
                ice_role,
            } => {
                <i32>::sse_encode(5, serializer);
                <Option<u64>>::sse_encode(packets_sent, serializer);
                <Option<u64>>::sse_encode(packets_received, serializer);
                <Option<u64>>::sse_encode(bytes_sent, serializer);
                <Option<u64>>::sse_encode(bytes_received, serializer);
                <Option<crate::api::IceRole>>::sse_encode(ice_role, serializer);
            }
            crate::api::RtcStatsType::RtcRemoteInboundRtpStreamStats {
                local_id,
                jitter,
                round_trip_time,
                fraction_lost,
                reports_received,
                round_trip_time_measurements,
            } => {
                <i32>::sse_encode(6, serializer);
                <Option<String>>::sse_encode(local_id, serializer);
                <Option<f64>>::sse_encode(jitter, serializer);
                <Option<f64>>::sse_encode(round_trip_time, serializer);
                <Option<f64>>::sse_encode(fraction_lost, serializer);
                <Option<u64>>::sse_encode(reports_received, serializer);
                <Option<i32>>::sse_encode(
                    round_trip_time_measurements,
                    serializer,
                );
            }
            crate::api::RtcStatsType::RtcRemoteOutboundRtpStreamStats {
                local_id,
                remote_timestamp,
                reports_sent,
            } => {
                <i32>::sse_encode(7, serializer);
                <Option<String>>::sse_encode(local_id, serializer);
                <Option<f64>>::sse_encode(remote_timestamp, serializer);
                <Option<u64>>::sse_encode(reports_sent, serializer);
            }
            crate::api::RtcStatsType::Unimplemented => {
                <i32>::sse_encode(8, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::RtcTrackEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <crate::api::MediaStreamTrack>::sse_encode(self.track, serializer);
        <crate::api::RtcRtpTransceiver>::sse_encode(
            self.transceiver,
            serializer,
        );
    }
}

impl SseEncode for crate::api::RtcpFeedback {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <Option<crate::api::RtcpFeedbackMessageType>>::sse_encode(
            self.message_type,
            serializer,
        );
        <crate::api::RtcpFeedbackType>::sse_encode(self.kind, serializer);
    }
}

impl SseEncode for crate::api::RtcpFeedbackMessageType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(
            match self {
                crate::api::RtcpFeedbackMessageType::GenericNACK => 0,
                crate::api::RtcpFeedbackMessageType::Pli => 1,
                crate::api::RtcpFeedbackMessageType::Fir => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::RtcpFeedbackType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(
            match self {
                crate::api::RtcpFeedbackType::Ccm => 0,
                crate::api::RtcpFeedbackType::Lntf => 1,
                crate::api::RtcpFeedbackType::Nack => 2,
                crate::api::RtcpFeedbackType::Remb => 3,
                crate::api::RtcpFeedbackType::TransportCC => 4,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::RtpCapabilities {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <Vec<crate::api::RtpCodecCapability>>::sse_encode(
            self.codecs,
            serializer,
        );
        <Vec<crate::api::RtpHeaderExtensionCapability>>::sse_encode(
            self.header_extensions,
            serializer,
        );
    }
}

impl SseEncode for crate::api::RtpCodecCapability {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <Option<i32>>::sse_encode(self.preferred_payload_type, serializer);
        <Vec<crate::api::ScalabilityMode>>::sse_encode(
            self.scalability_modes,
            serializer,
        );
        <String>::sse_encode(self.mime_type, serializer);
        <String>::sse_encode(self.name, serializer);
        <crate::api::MediaType>::sse_encode(self.kind, serializer);
        <Option<i32>>::sse_encode(self.clock_rate, serializer);
        <Option<i32>>::sse_encode(self.num_channels, serializer);
        <Vec<(String, String)>>::sse_encode(self.parameters, serializer);
        <Vec<crate::api::RtcpFeedback>>::sse_encode(self.feedback, serializer);
    }
}

impl SseEncode for crate::api::RtpHeaderExtensionCapability {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <String>::sse_encode(self.uri, serializer);
        <Option<i32>>::sse_encode(self.preferred_id, serializer);
        <bool>::sse_encode(self.preferred_encrypted, serializer);
        <crate::api::RtpTransceiverDirection>::sse_encode(
            self.direction,
            serializer,
        );
    }
}

impl SseEncode for crate::api::RtpTransceiverDirection {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(
            match self {
                crate::api::RtpTransceiverDirection::SendRecv => 0,
                crate::api::RtpTransceiverDirection::SendOnly => 1,
                crate::api::RtpTransceiverDirection::RecvOnly => 2,
                crate::api::RtpTransceiverDirection::Inactive => 3,
                crate::api::RtpTransceiverDirection::Stopped => 4,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::RtpTransceiverInit {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <crate::api::RtpTransceiverDirection>::sse_encode(
            self.direction,
            serializer,
        );
        <Vec<crate::api::RtcRtpEncodingParameters>>::sse_encode(
            self.send_encodings,
            serializer,
        );
    }
}

impl SseEncode for crate::api::ScalabilityMode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(
            match self {
                crate::api::ScalabilityMode::L1T1 => 0,
                crate::api::ScalabilityMode::L1T2 => 1,
                crate::api::ScalabilityMode::L1T3 => 2,
                crate::api::ScalabilityMode::L2T1 => 3,
                crate::api::ScalabilityMode::L2T1h => 4,
                crate::api::ScalabilityMode::L2t1Key => 5,
                crate::api::ScalabilityMode::L2T2 => 6,
                crate::api::ScalabilityMode::L2T2h => 7,
                crate::api::ScalabilityMode::L2T2Key => 8,
                crate::api::ScalabilityMode::L2T2KeyShift => 9,
                crate::api::ScalabilityMode::L2T3 => 10,
                crate::api::ScalabilityMode::L2T3h => 11,
                crate::api::ScalabilityMode::L2T3Key => 12,
                crate::api::ScalabilityMode::L3T1 => 13,
                crate::api::ScalabilityMode::L3T1h => 14,
                crate::api::ScalabilityMode::L3T1Key => 15,
                crate::api::ScalabilityMode::L3T2 => 16,
                crate::api::ScalabilityMode::L3T2h => 17,
                crate::api::ScalabilityMode::L3T2Key => 18,
                crate::api::ScalabilityMode::L3T3 => 19,
                crate::api::ScalabilityMode::L3T3h => 20,
                crate::api::ScalabilityMode::L3T3Key => 21,
                crate::api::ScalabilityMode::S2T1 => 22,
                crate::api::ScalabilityMode::S2T1h => 23,
                crate::api::ScalabilityMode::S2T2 => 24,
                crate::api::ScalabilityMode::S2T2h => 25,
                crate::api::ScalabilityMode::S2T3 => 26,
                crate::api::ScalabilityMode::S2T3h => 27,
                crate::api::ScalabilityMode::S3T1 => 28,
                crate::api::ScalabilityMode::S3T1h => 29,
                crate::api::ScalabilityMode::S3T2 => 30,
                crate::api::ScalabilityMode::S3T2h => 31,
                crate::api::ScalabilityMode::S3T3 => 32,
                crate::api::ScalabilityMode::S3T3h => 33,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::SdpType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(
            match self {
                crate::api::SdpType::Offer => 0,
                crate::api::SdpType::PrAnswer => 1,
                crate::api::SdpType::Answer => 2,
                crate::api::SdpType::Rollback => 3,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::SignalingState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(
            match self {
                crate::api::SignalingState::Stable => 0,
                crate::api::SignalingState::HaveLocalOffer => 1,
                crate::api::SignalingState::HaveLocalPrAnswer => 2,
                crate::api::SignalingState::HaveRemoteOffer => 3,
                crate::api::SignalingState::HaveRemotePrAnswer => 4,
                crate::api::SignalingState::Closed => 5,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::renderer::TextureEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        match self {
            crate::renderer::TextureEvent::OnTextureChange {
                texture_id,
                width,
                height,
                rotation,
            } => {
                <i32>::sse_encode(0, serializer);
                <i64>::sse_encode(texture_id, serializer);
                <i32>::sse_encode(width, serializer);
                <i32>::sse_encode(height, serializer);
                <i32>::sse_encode(rotation, serializer);
            }
            crate::renderer::TextureEvent::OnFirstFrameRendered {
                texture_id,
            } => {
                <i32>::sse_encode(1, serializer);
                <i64>::sse_encode(texture_id, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::TrackEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        match self {
            crate::api::TrackEvent::Ended => {
                <i32>::sse_encode(0, serializer);
            }
            crate::api::TrackEvent::AudioLevelUpdated(field0) => {
                <i32>::sse_encode(1, serializer);
                <u32>::sse_encode(field0, serializer);
            }
            crate::api::TrackEvent::TrackCreated => {
                <i32>::sse_encode(2, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::TrackState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(
            match self {
                crate::api::TrackState::Live => 0,
                crate::api::TrackState::Ended => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        serializer.cursor.write_u32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        serializer.cursor.write_u64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        serializer.cursor.write_u8(self).unwrap();
    }
}

impl SseEncode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
    }
}

impl SseEncode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        serializer.cursor.write_u64::<NativeEndian>(self as _).unwrap();
    }
}

impl SseEncode for crate::api::VideoCodec {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(
            match self {
                crate::api::VideoCodec::AV1 => 0,
                crate::api::VideoCodec::H264 => 1,
                crate::api::VideoCodec::H265 => 2,
                crate::api::VideoCodec::VP8 => 3,
                crate::api::VideoCodec::VP9 => 4,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::VideoCodecInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <bool>::sse_encode(self.is_hardware_accelerated, serializer);
        <crate::api::VideoCodec>::sse_encode(self.codec, serializer);
    }
}

impl SseEncode for crate::api::VideoConstraints {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <Option<String>>::sse_encode(self.device_id, serializer);
        <u32>::sse_encode(self.width, serializer);
        <u32>::sse_encode(self.height, serializer);
        <u32>::sse_encode(self.frame_rate, serializer);
        <bool>::sse_encode(self.is_display, serializer);
    }
}

#[cfg(not(target_family = "wasm"))]
mod io {
    // This file is automatically generated, so please do not edit it.
    // @generated by `flutter_rust_bridge`@ 2.10.0.

    // Section: imports

    use super::*;
    use crate::*;
    use flutter_rust_bridge::for_generated::byteorder::{
        NativeEndian, ReadBytesExt, WriteBytesExt,
    };
    use flutter_rust_bridge::for_generated::{
        transform_result_dco, Lifetimeable, Lockable,
    };
    use flutter_rust_bridge::{Handler, IntoIntoDart};

    // Section: boilerplate

    flutter_rust_bridge::frb_generated_boilerplate_io!();

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_medea_flutter_webrtc_rust_arc_increment_strong_count_RustOpaque_ArcPeerConnection(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<Arc<PeerConnection>>::increment_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_medea_flutter_webrtc_rust_arc_decrement_strong_count_RustOpaque_ArcPeerConnection(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<Arc<PeerConnection>>::decrement_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_medea_flutter_webrtc_rust_arc_increment_strong_count_RustOpaque_ArcRtpEncodingParameters(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<Arc<RtpEncodingParameters>>::increment_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_medea_flutter_webrtc_rust_arc_decrement_strong_count_RustOpaque_ArcRtpEncodingParameters(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<Arc<RtpEncodingParameters>>::decrement_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_medea_flutter_webrtc_rust_arc_increment_strong_count_RustOpaque_ArcRtpParameters(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<Arc<RtpParameters>>::increment_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_medea_flutter_webrtc_rust_arc_decrement_strong_count_RustOpaque_ArcRtpParameters(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<Arc<RtpParameters>>::decrement_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_medea_flutter_webrtc_rust_arc_increment_strong_count_RustOpaque_ArcRtpTransceiver(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<Arc<RtpTransceiver>>::increment_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_medea_flutter_webrtc_rust_arc_decrement_strong_count_RustOpaque_ArcRtpTransceiver(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<Arc<RtpTransceiver>>::decrement_strong_count(ptr as _);
    }
}
#[cfg(not(target_family = "wasm"))]
pub use io::*;
