// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

#![allow(
    non_camel_case_types,
    unused,
    non_snake_case,
    clippy::needless_return,
    clippy::redundant_closure_call,
    clippy::redundant_closure,
    clippy::useless_conversion,
    clippy::unit_arg,
    clippy::unused_unit,
    clippy::double_parens,
    clippy::let_and_return,
    clippy::too_many_arguments,
    clippy::match_single_binding,
    clippy::clone_on_copy,
    clippy::let_unit_value,
    clippy::deref_addrof,
    clippy::explicit_auto_deref,
    clippy::borrow_deref_ref,
    clippy::needless_borrow
)]

// Section: imports

use crate::*;
use flutter_rust_bridge::for_generated::byteorder::{
    NativeEndian, ReadBytesExt, WriteBytesExt,
};
use flutter_rust_bridge::for_generated::{
    transform_result_dco, Lifetimeable, Lockable,
};
use flutter_rust_bridge::{Handler, IntoIntoDart};

// Section: boilerplate

flutter_rust_bridge::frb_generated_boilerplate!(
    default_stream_sink_codec = SseCodec,
    default_rust_opaque = RustOpaqueMoi,
    default_rust_auto_opaque = RustAutoOpaqueMoi,
);
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_VERSION: &str = "2.11.1";
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_CONTENT_HASH: i32 = 1851697459;

// Section: executor

pub use crate::api::FLUTTER_RUST_BRIDGE_HANDLER;

// Section: wire_funcs

fn wire__crate__api__peer__add_ice_candidate_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "add_ice_candidate", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_peer = <RustOpaqueMoi<Arc < PeerConnection >>>::sse_decode(&mut deserializer);
let api_candidate = <String>::sse_decode(&mut deserializer);
let api_sdp_mid = <String>::sse_decode(&mut deserializer);
let api_sdp_mline_index = <i32>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>((move ||  {
                         let output_ok = crate::api::peer::add_ice_candidate(api_peer, api_candidate, api_sdp_mid, api_sdp_mline_index)?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__transceiver__add_transceiver_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "add_transceiver", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_peer = <RustOpaqueMoi<Arc < PeerConnection >>>::sse_decode(&mut deserializer);
let api_media_type = <crate::api::media_stream_track::media_type::MediaType>::sse_decode(&mut deserializer);
let api_init = <crate::api::transceiver::init::RtpTransceiverInit>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>((move ||  {
                         let output_ok = crate::api::transceiver::add_transceiver(api_peer, api_media_type, api_init)?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__media__constraints__audio__audio_processing_constraints_default_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "audio_processing_constraints_default", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok(crate::api::media::constraints::audio::AudioProcessingConstraints::default())?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__media_stream_track__clone_track_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "clone_track", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_track_id = <String>::sse_decode(&mut deserializer);
let api_peer_id = <Option<u32>>::sse_decode(&mut deserializer);
let api_kind = <crate::api::media_stream_track::media_type::MediaType>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok(crate::api::media_stream_track::clone_track(api_track_id, api_peer_id, api_kind))?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__peer__create_answer_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "create_answer", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_peer = <RustOpaqueMoi<Arc < PeerConnection >>>::sse_decode(&mut deserializer);
let api_voice_activity_detection = <bool>::sse_decode(&mut deserializer);
let api_ice_restart = <bool>::sse_decode(&mut deserializer);
let api_use_rtp_mux = <bool>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>((move ||  {
                         let output_ok = crate::api::peer::create_answer(api_peer, api_voice_activity_detection, api_ice_restart, api_use_rtp_mux)?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__peer__create_offer_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "create_offer", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_peer = <RustOpaqueMoi<Arc < PeerConnection >>>::sse_decode(&mut deserializer);
let api_voice_activity_detection = <bool>::sse_decode(&mut deserializer);
let api_ice_restart = <bool>::sse_decode(&mut deserializer);
let api_use_rtp_mux = <bool>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>((move ||  {
                         let output_ok = crate::api::peer::create_offer(api_peer, api_voice_activity_detection, api_ice_restart, api_use_rtp_mux)?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__peer__create_peer_connection_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "create_peer_connection", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_cb = <StreamSink<crate::api::peer::events::PeerConnectionEvent,flutter_rust_bridge::for_generated::SseCodec>>::sse_decode(&mut deserializer);
let api_configuration = <crate::api::peer::rtc_configuration::RtcConfiguration>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>((move ||  {
                         let output_ok = crate::api::peer::create_peer_connection(api_cb, api_configuration)?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__media_stream_track__create_video_sink_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "create_video_sink", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_cb = <StreamSink<crate::renderer::TextureEvent,flutter_rust_bridge::for_generated::SseCodec>>::sse_decode(&mut deserializer);
let api_sink_id = <i64>::sse_decode(&mut deserializer);
let api_peer_id = <Option<u32>>::sse_decode(&mut deserializer);
let api_track_id = <String>::sse_decode(&mut deserializer);
let api_callback_ptr = <i64>::sse_decode(&mut deserializer);
let api_texture_id = <i64>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok({ crate::api::media_stream_track::create_video_sink(api_cb, api_sink_id, api_peer_id, api_track_id, api_callback_ptr, api_texture_id); })?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__peer__dispose_peer_connection_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "dispose_peer_connection", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_peer = <RustOpaqueMoi<Arc < PeerConnection >>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok({ crate::api::peer::dispose_peer_connection(api_peer); })?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__media_stream_track__dispose_track_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "dispose_track", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_track_id = <String>::sse_decode(&mut deserializer);
let api_peer_id = <Option<u32>>::sse_decode(&mut deserializer);
let api_kind = <crate::api::media_stream_track::media_type::MediaType>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok({ crate::api::media_stream_track::dispose_track(api_track_id, api_peer_id, api_kind); })?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__media_stream_track__dispose_video_sink_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "dispose_video_sink", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_sink_id = <i64>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok({ crate::api::media_stream_track::dispose_video_sink(api_sink_id); })?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__media__enable_fake_media_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "enable_fake_media", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok({ crate::api::media::enable_fake_media(); })?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__media__enumerate_devices_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "enumerate_devices", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end(); move |context|  {
                    transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>((move ||  {
                         let output_ok = crate::api::media::enumerate_devices()?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__media__enumerate_displays_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "enumerate_displays", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok(crate::api::media::enumerate_displays())?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__media_stream_track__audio_processing_config__get_audio_processing_config_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "get_audio_processing_config", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_track_id = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>((move ||  {
                         let output_ok = crate::api::media_stream_track::audio_processing_config::get_audio_processing_config(api_track_id)?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__media_stream_track__get_media_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "get_media", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_constraints = <crate::api::media::constraints::MediaStreamConstraints>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok(crate::api::media_stream_track::get_media(api_constraints))?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__stats__get_peer_stats_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "get_peer_stats", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_peer = <RustOpaqueMoi<Arc < PeerConnection >>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>((move ||  {
                         let output_ok = crate::api::stats::get_peer_stats(api_peer)?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__capability__get_rtp_receiver_capabilities_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "get_rtp_receiver_capabilities", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_kind = <crate::api::media_stream_track::media_type::MediaType>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok(crate::api::capability::get_rtp_receiver_capabilities(api_kind))?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__capability__get_rtp_sender_capabilities_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "get_rtp_sender_capabilities", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_kind = <crate::api::media_stream_track::media_type::MediaType>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok(crate::api::capability::get_rtp_sender_capabilities(api_kind))?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__transceiver__get_transceiver_direction_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "get_transceiver_direction", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_transceiver = <RustOpaqueMoi<Arc < RtpTransceiver >>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok(crate::api::transceiver::get_transceiver_direction(api_transceiver))?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__transceiver__get_transceiver_mid_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "get_transceiver_mid", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_transceiver = <RustOpaqueMoi<Arc < RtpTransceiver >>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok(crate::api::transceiver::get_transceiver_mid(api_transceiver))?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__transceiver__get_transceivers_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "get_transceivers", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_peer = <RustOpaqueMoi<Arc < PeerConnection >>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok(crate::api::transceiver::get_transceivers(api_peer))?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__media__is_fake_media_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "is_fake_media", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok(crate::api::media::is_fake_media())?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__media__microphone_volume_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "microphone_volume", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end(); move |context|  {
                    transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>((move ||  {
                         let output_ok = crate::api::media::microphone_volume()?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__media__microphone_volume_is_available_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "microphone_volume_is_available", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end(); move |context|  {
                    transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>((move ||  {
                         let output_ok = crate::api::media::microphone_volume_is_available()?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__media_stream_track__register_track_observer_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "register_track_observer", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_cb = <StreamSink<crate::api::media_stream_track::track_event::TrackEvent,flutter_rust_bridge::for_generated::SseCodec>>::sse_decode(&mut deserializer);
let api_peer_id = <Option<u32>>::sse_decode(&mut deserializer);
let api_track_id = <String>::sse_decode(&mut deserializer);
let api_kind = <crate::api::media_stream_track::media_type::MediaType>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok({ crate::api::media_stream_track::register_track_observer(api_cb, api_peer_id, api_track_id, api_kind); })?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__peer__restart_ice_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "restart_ice", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_peer = <RustOpaqueMoi<Arc < PeerConnection >>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok({ crate::api::peer::restart_ice(api_peer); })?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__sender_get_parameters_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "sender_get_parameters", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_transceiver = <RustOpaqueMoi<Arc < RtpTransceiver >>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok(crate::api::sender_get_parameters(api_transceiver))?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__sender_replace_track_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "sender_replace_track", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_peer = <RustOpaqueMoi<Arc < PeerConnection >>>::sse_decode(&mut deserializer);
let api_transceiver = <RustOpaqueMoi<Arc < RtpTransceiver >>>::sse_decode(&mut deserializer);
let api_track_id = <Option<String>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>((move ||  {
                         let output_ok = crate::api::sender_replace_track(api_peer, api_transceiver, api_track_id)?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__sender_set_parameters_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "sender_set_parameters", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_transceiver = <RustOpaqueMoi<Arc < RtpTransceiver >>>::sse_decode(&mut deserializer);
let api_params = <crate::api::rtc_rtp_send_parameters::RtcRtpSendParameters>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>((move ||  {
                         let output_ok = crate::api::sender_set_parameters(api_transceiver, api_params)?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__media_stream_track__set_audio_level_observer_enabled_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "set_audio_level_observer_enabled", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_track_id = <String>::sse_decode(&mut deserializer);
let api_peer_id = <Option<u32>>::sse_decode(&mut deserializer);
let api_enabled = <bool>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok({ crate::api::media_stream_track::set_audio_level_observer_enabled(api_track_id, api_peer_id, api_enabled); })?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__media__set_audio_playout_device_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "set_audio_playout_device", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_device_id = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>((move ||  {
                         let output_ok = crate::api::media::set_audio_playout_device(api_device_id)?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__capability__rtp_codec__set_codec_preferences_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "set_codec_preferences", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_transceiver = <RustOpaqueMoi<Arc < RtpTransceiver >>>::sse_decode(&mut deserializer);
let api_codecs = <Vec<crate::api::capability::rtp_codec::RtpCodecCapability>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok({ crate::api::capability::rtp_codec::set_codec_preferences(api_transceiver, api_codecs); })?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__peer__rtc_session_description__set_local_description_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "set_local_description", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_peer = <RustOpaqueMoi<Arc < PeerConnection >>>::sse_decode(&mut deserializer);
let api_kind = <crate::api::peer::rtc_session_description::SdpType>::sse_decode(&mut deserializer);
let api_sdp = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>((move ||  {
                         let output_ok = crate::api::peer::rtc_session_description::set_local_description(api_peer, api_kind, api_sdp)?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__media__set_microphone_volume_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "set_microphone_volume", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_level = <u8>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>((move ||  {
                         let output_ok = crate::api::media::set_microphone_volume(api_level)?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__media__set_on_device_changed_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "set_on_device_changed", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_cb = <StreamSink<(),flutter_rust_bridge::for_generated::SseCodec>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok({ crate::api::media::set_on_device_changed(api_cb); })?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__peer__rtc_session_description__set_remote_description_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "set_remote_description", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_peer = <RustOpaqueMoi<Arc < PeerConnection >>>::sse_decode(&mut deserializer);
let api_kind = <crate::api::peer::rtc_session_description::SdpType>::sse_decode(&mut deserializer);
let api_sdp = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>((move ||  {
                         let output_ok = crate::api::peer::rtc_session_description::set_remote_description(api_peer, api_kind, api_sdp)?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__media_stream_track__set_track_enabled_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "set_track_enabled", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_track_id = <String>::sse_decode(&mut deserializer);
let api_peer_id = <Option<u32>>::sse_decode(&mut deserializer);
let api_kind = <crate::api::media_stream_track::media_type::MediaType>::sse_decode(&mut deserializer);
let api_enabled = <bool>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok({ crate::api::media_stream_track::set_track_enabled(api_track_id, api_peer_id, api_kind, api_enabled); })?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__transceiver__set_transceiver_direction_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "set_transceiver_direction", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_transceiver = <RustOpaqueMoi<Arc < RtpTransceiver >>>::sse_decode(&mut deserializer);
let api_direction = <crate::api::transceiver::direction::RtpTransceiverDirection>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>((move ||  {
                         let output_ok = crate::api::transceiver::set_transceiver_direction(api_transceiver, api_direction)?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__transceiver__set_transceiver_recv_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "set_transceiver_recv", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_transceiver = <RustOpaqueMoi<Arc < RtpTransceiver >>>::sse_decode(&mut deserializer);
let api_recv = <bool>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>((move ||  {
                         let output_ok = crate::api::transceiver::set_transceiver_recv(api_transceiver, api_recv)?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__transceiver__set_transceiver_send_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "set_transceiver_send", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_transceiver = <RustOpaqueMoi<Arc < RtpTransceiver >>>::sse_decode(&mut deserializer);
let api_send = <bool>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>((move ||  {
                         let output_ok = crate::api::transceiver::set_transceiver_send(api_transceiver, api_send)?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__transceiver__stop_transceiver_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "stop_transceiver", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_transceiver = <RustOpaqueMoi<Arc < RtpTransceiver >>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>((move ||  {
                         let output_ok = crate::api::transceiver::stop_transceiver(api_transceiver)?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__media_stream_track__track_height_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "track_height", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_track_id = <String>::sse_decode(&mut deserializer);
let api_peer_id = <Option<u32>>::sse_decode(&mut deserializer);
let api_kind = <crate::api::media_stream_track::media_type::MediaType>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok(crate::api::media_stream_track::track_height(api_track_id, api_peer_id, api_kind))?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__media_stream_track__track_state_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "track_state", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_track_id = <String>::sse_decode(&mut deserializer);
let api_peer_id = <Option<u32>>::sse_decode(&mut deserializer);
let api_kind = <crate::api::media_stream_track::media_type::MediaType>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok(crate::api::media_stream_track::track_state(api_track_id, api_peer_id, api_kind))?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__media_stream_track__track_width_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "track_width", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_track_id = <String>::sse_decode(&mut deserializer);
let api_peer_id = <Option<u32>>::sse_decode(&mut deserializer);
let api_kind = <crate::api::media_stream_track::media_type::MediaType>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok(crate::api::media_stream_track::track_width(api_track_id, api_peer_id, api_kind))?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__media_stream_track__update_audio_processing_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "update_audio_processing", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_track_id = <String>::sse_decode(&mut deserializer);
let api_conf = <crate::api::media::constraints::audio::AudioProcessingConstraints>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>((move ||  {
                         let output_ok = crate::api::media_stream_track::update_audio_processing(api_track_id, api_conf)?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__peer__video_codec_info__video_decoders_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "video_decoders", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok(crate::api::peer::video_codec_info::video_decoders())?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__peer__video_codec_info__video_encoders_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "video_encoders", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok(crate::api::peer::video_codec_info::video_encoders())?;   Ok(output_ok)
                    })())
                } })
}

// Section: related_funcs

flutter_rust_bridge::frb_generated_moi_arc_impl_value!(Arc<PeerConnection>);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    Arc<RtpEncodingParameters>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(Arc<RtpParameters>);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(Arc<RtpTransceiver>);

// Section: dart2rust

impl SseDecode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::anyhow::anyhow!(
            "{}", inner
        );
    }
}

impl SseDecode for RustOpaqueMoi<Arc<PeerConnection>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode for RustOpaqueMoi<Arc<RtpEncodingParameters>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode for RustOpaqueMoi<Arc<RtpParameters>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode for RustOpaqueMoi<Arc<RtpTransceiver>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for StreamSink<
        crate::api::peer::events::PeerConnectionEvent,
        flutter_rust_bridge::for_generated::SseCodec,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return StreamSink::deserialize(inner);
    }
}

impl SseDecode
    for StreamSink<
        crate::renderer::TextureEvent,
        flutter_rust_bridge::for_generated::SseCodec,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return StreamSink::deserialize(inner);
    }
}

impl SseDecode
    for StreamSink<
        crate::api::media_stream_track::track_event::TrackEvent,
        flutter_rust_bridge::for_generated::SseCodec,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return StreamSink::deserialize(inner);
    }
}

impl SseDecode
    for StreamSink<(), flutter_rust_bridge::for_generated::SseCodec>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return StreamSink::deserialize(inner);
    }
}

impl SseDecode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return String::from_utf8(inner).unwrap();
    }
}

impl SseDecode for crate::api::media::constraints::audio::AudioConstraints {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut var_deviceId = <Option<String>>::sse_decode(deserializer);
        let mut var_processing = <crate::api::media::constraints::audio::AudioProcessingConstraints>::sse_decode(deserializer);
        return crate::api::media::constraints::audio::AudioConstraints {
            device_id: var_deviceId,
            processing: var_processing,
        };
    }
}

impl SseDecode for crate::api::media_stream_track::audio_processing_config::AudioProcessingConfig {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut var_autoGainControl = <bool>::sse_decode(deserializer);
let mut var_highPassFilter = <bool>::sse_decode(deserializer);
let mut var_noiseSuppression = <bool>::sse_decode(deserializer);
let mut var_noiseSuppressionLevel = <crate::api::media_stream_track::audio_processing_config::NoiseSuppressionLevel>::sse_decode(deserializer);
let mut var_echoCancellation = <bool>::sse_decode(deserializer);
return crate::api::media_stream_track::audio_processing_config::AudioProcessingConfig{auto_gain_control: var_autoGainControl, high_pass_filter: var_highPassFilter, noise_suppression: var_noiseSuppression, noise_suppression_level: var_noiseSuppressionLevel, echo_cancellation: var_echoCancellation};}
                }

impl SseDecode
    for crate::api::media::constraints::audio::AudioProcessingConstraints
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut var_autoGainControl = <Option<bool>>::sse_decode(deserializer);
        let mut var_highPassFilter = <Option<bool>>::sse_decode(deserializer);
        let mut var_noiseSuppression = <Option<bool>>::sse_decode(deserializer);
        let mut var_noiseSuppressionLevel = <Option<crate::api::media_stream_track::audio_processing_config::NoiseSuppressionLevel>>::sse_decode(deserializer);
        let mut var_echoCancellation = <Option<bool>>::sse_decode(deserializer);
        return crate::api::media::constraints::audio::AudioProcessingConstraints{auto_gain_control: var_autoGainControl, high_pass_filter: var_highPassFilter, noise_suppression: var_noiseSuppression, noise_suppression_level: var_noiseSuppressionLevel, echo_cancellation: var_echoCancellation};
    }
}

impl SseDecode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        deserializer.cursor.read_u8().unwrap() != 0
    }
}

impl SseDecode
    for crate::api::peer::rtc_configuration::bundle_policy::BundlePolicy
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::peer::rtc_configuration::bundle_policy::BundlePolicy::Balanced,
1 => crate::api::peer::rtc_configuration::bundle_policy::BundlePolicy::MaxBundle,
2 => crate::api::peer::rtc_configuration::bundle_policy::BundlePolicy::MaxCompat,
            _ => unreachable!("Invalid variant for BundlePolicy: {}", inner),
        };
    }
}

impl SseDecode for crate::api::stats::rtc_ice_candidate_stats::CandidateType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => {
                crate::api::stats::rtc_ice_candidate_stats::CandidateType::Host
            }
            1 => {
                crate::api::stats::rtc_ice_candidate_stats::CandidateType::Srflx
            }
            2 => {
                crate::api::stats::rtc_ice_candidate_stats::CandidateType::Prflx
            }
            3 => {
                crate::api::stats::rtc_ice_candidate_stats::CandidateType::Relay
            }
            _ => unreachable!("Invalid variant for CandidateType: {}", inner),
        };
    }
}

impl SseDecode for f64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        deserializer.cursor.read_f64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for crate::api::media_stream_track::GetMediaError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::media_stream_track::GetMediaError::Audio(
                    var_field0,
                );
            }
            1 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::media_stream_track::GetMediaError::Video(
                    var_field0,
                );
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::media_stream_track::GetMediaResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 = <Vec<
                    crate::api::media_stream_track::MediaStreamTrack,
                >>::sse_decode(
                    deserializer
                );
                return crate::api::media_stream_track::GetMediaResult::Ok(
                    var_field0,
                );
            }
            1 => {
                let mut var_field0 =
                    <crate::api::media_stream_track::GetMediaError>::sse_decode(
                        deserializer,
                    );
                return crate::api::media_stream_track::GetMediaResult::Err(
                    var_field0,
                );
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        deserializer.cursor.read_i32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for i64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        deserializer.cursor.read_i64::<NativeEndian>().unwrap()
    }
}

impl SseDecode
    for crate::api::stats::rtc_ice_candidate_stats::IceCandidateStats
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut var_transportId = <Option<String>>::sse_decode(deserializer);
        let mut var_address = <Option<String>>::sse_decode(deserializer);
        let mut var_port = <Option<i32>>::sse_decode(deserializer);
        let mut var_protocol =
            <crate::api::stats::rtc_ice_candidate_stats::Protocol>::sse_decode(
                deserializer,
            );
        let mut var_candidateType = <crate::api::stats::rtc_ice_candidate_stats::CandidateType>::sse_decode(deserializer);
        let mut var_priority = <Option<i32>>::sse_decode(deserializer);
        let mut var_url = <Option<String>>::sse_decode(deserializer);
        let mut var_relayProtocol = <Option<
            crate::api::stats::rtc_ice_candidate_stats::Protocol,
        >>::sse_decode(deserializer);
        return crate::api::stats::rtc_ice_candidate_stats::IceCandidateStats {
            transport_id: var_transportId,
            address: var_address,
            port: var_port,
            protocol: var_protocol,
            candidate_type: var_candidateType,
            priority: var_priority,
            url: var_url,
            relay_protocol: var_relayProtocol,
        };
    }
}

impl SseDecode
    for crate::api::peer::events::ice_connection_state::IceConnectionState
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::peer::events::ice_connection_state::IceConnectionState::New,
1 => crate::api::peer::events::ice_connection_state::IceConnectionState::Checking,
2 => crate::api::peer::events::ice_connection_state::IceConnectionState::Connected,
3 => crate::api::peer::events::ice_connection_state::IceConnectionState::Completed,
4 => crate::api::peer::events::ice_connection_state::IceConnectionState::Failed,
5 => crate::api::peer::events::ice_connection_state::IceConnectionState::Disconnected,
6 => crate::api::peer::events::ice_connection_state::IceConnectionState::Closed,
            _ => unreachable!("Invalid variant for IceConnectionState: {}", inner),
        };
    }
}

impl SseDecode
    for crate::api::peer::events::ice_gathering_state::IceGatheringState
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::peer::events::ice_gathering_state::IceGatheringState::New,
1 => crate::api::peer::events::ice_gathering_state::IceGatheringState::Gathering,
2 => crate::api::peer::events::ice_gathering_state::IceGatheringState::Complete,
            _ => unreachable!("Invalid variant for IceGatheringState: {}", inner),
        };
    }
}

impl SseDecode for crate::api::stats::ice_role::IceRole {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::stats::ice_role::IceRole::Unknown,
            1 => crate::api::stats::ice_role::IceRole::Controlling,
            2 => crate::api::stats::ice_role::IceRole::Controlled,
            _ => unreachable!("Invalid variant for IceRole: {}", inner),
        };
    }
}

impl SseDecode for crate::api::peer::rtc_configuration::ice_transports_type::IceTransportsType {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::peer::rtc_configuration::ice_transports_type::IceTransportsType::All,
1 => crate::api::peer::rtc_configuration::ice_transports_type::IceTransportsType::Relay,
2 => crate::api::peer::rtc_configuration::ice_transports_type::IceTransportsType::NoHost,
3 => crate::api::peer::rtc_configuration::ice_transports_type::IceTransportsType::None,
            _ => unreachable!("Invalid variant for IceTransportsType: {}", inner),
        };}
                }

impl SseDecode for Vec<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<String>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::media_info::MediaDeviceInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::media_info::MediaDeviceInfo>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::media_info::MediaDisplayInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::media_info::MediaDisplayInfo>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::media_stream_track::MediaStreamTrack> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(
                <crate::api::media_stream_track::MediaStreamTrack>::sse_decode(
                    deserializer,
                ),
            );
        }
        return ans_;
    }
}

impl SseDecode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u8>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode
    for Vec<(
        crate::api::rtc_rtp_encoding_parameters::RtcRtpEncodingParameters,
        RustOpaqueMoi<Arc<RtpEncodingParameters>>,
    )>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(crate::api::rtc_rtp_encoding_parameters::RtcRtpEncodingParameters,RustOpaqueMoi<Arc < RtpEncodingParameters >>,)>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<(String, String)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(String, String)>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode
    for Vec<crate::api::peer::rtc_configuration::rtc_ice_server::RtcIceServer>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::peer::rtc_configuration::rtc_ice_server::RtcIceServer>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode
    for Vec<crate::api::rtc_rtp_encoding_parameters::RtcRtpEncodingParameters>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::rtc_rtp_encoding_parameters::RtcRtpEncodingParameters>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::transceiver::RtcRtpTransceiver> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(
                <crate::api::transceiver::RtcRtpTransceiver>::sse_decode(
                    deserializer,
                ),
            );
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::stats::RtcStats> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::stats::RtcStats>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode
    for Vec<crate::api::capability::rtp_codec::rtcp_feedback::RtcpFeedback>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::capability::rtp_codec::rtcp_feedback::RtcpFeedback>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::capability::rtp_codec::RtpCodecCapability> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::capability::rtp_codec::RtpCodecCapability>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::capability::rtp_header_extension_capability::RtpHeaderExtensionCapability> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ { ans_.push(<crate::api::capability::rtp_header_extension_capability::RtpHeaderExtensionCapability>::sse_decode(deserializer)); }
        return ans_;}
                }

impl SseDecode
    for Vec<
        crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::peer::video_codec_info::VideoCodecInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::peer::video_codec_info::VideoCodecInfo>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for crate::api::media_info::MediaDeviceInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut var_deviceId = <String>::sse_decode(deserializer);
        let mut var_kind =
            <crate::api::media_info::MediaDeviceKind>::sse_decode(deserializer);
        let mut var_label = <String>::sse_decode(deserializer);
        return crate::api::media_info::MediaDeviceInfo {
            device_id: var_deviceId,
            kind: var_kind,
            label: var_label,
        };
    }
}

impl SseDecode for crate::api::media_info::MediaDeviceKind {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::media_info::MediaDeviceKind::AudioInput,
            1 => crate::api::media_info::MediaDeviceKind::AudioOutput,
            2 => crate::api::media_info::MediaDeviceKind::VideoInput,
            _ => unreachable!("Invalid variant for MediaDeviceKind: {}", inner),
        };
    }
}

impl SseDecode for crate::api::media_info::MediaDisplayInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut var_deviceId = <String>::sse_decode(deserializer);
        let mut var_title = <Option<String>>::sse_decode(deserializer);
        return crate::api::media_info::MediaDisplayInfo {
            device_id: var_deviceId,
            title: var_title,
        };
    }
}

impl SseDecode for crate::api::media::constraints::MediaStreamConstraints {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut var_audio = <Option<
            crate::api::media::constraints::audio::AudioConstraints,
        >>::sse_decode(deserializer);
        let mut var_video = <Option<
            crate::api::media::constraints::video::VideoConstraints,
        >>::sse_decode(deserializer);
        return crate::api::media::constraints::MediaStreamConstraints {
            audio: var_audio,
            video: var_video,
        };
    }
}

impl SseDecode for crate::api::media_stream_track::MediaStreamTrack {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_peerId = <Option<u32>>::sse_decode(deserializer);
        let mut var_deviceId = <String>::sse_decode(deserializer);
        let mut var_kind =
            <crate::api::media_stream_track::media_type::MediaType>::sse_decode(
                deserializer,
            );
        let mut var_enabled = <bool>::sse_decode(deserializer);
        return crate::api::media_stream_track::MediaStreamTrack {
            id: var_id,
            peer_id: var_peerId,
            device_id: var_deviceId,
            kind: var_kind,
            enabled: var_enabled,
        };
    }
}

impl SseDecode for crate::api::media_stream_track::media_type::MediaType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::media_stream_track::media_type::MediaType::Audio,
            1 => crate::api::media_stream_track::media_type::MediaType::Video,
            _ => unreachable!("Invalid variant for MediaType: {}", inner),
        };
    }
}

impl SseDecode for crate::api::media_stream_track::audio_processing_config::NoiseSuppressionLevel {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::media_stream_track::audio_processing_config::NoiseSuppressionLevel::Low,
1 => crate::api::media_stream_track::audio_processing_config::NoiseSuppressionLevel::Moderate,
2 => crate::api::media_stream_track::audio_processing_config::NoiseSuppressionLevel::High,
3 => crate::api::media_stream_track::audio_processing_config::NoiseSuppressionLevel::VeryHigh,
            _ => unreachable!("Invalid variant for NoiseSuppressionLevel: {}", inner),
        };}
                }

impl SseDecode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<String>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode
    for Option<crate::api::media::constraints::audio::AudioConstraints>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::media::constraints::audio::AudioConstraints>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<bool> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<bool>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<f64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<f64>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<i32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<i32>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::stats::ice_role::IceRole> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::stats::ice_role::IceRole>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::media_stream_track::MediaStreamTrack> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <crate::api::media_stream_track::MediaStreamTrack>::sse_decode(
                    deserializer,
                ),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::media_stream_track::audio_processing_config::NoiseSuppressionLevel> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {if (<bool>::sse_decode(deserializer)) {
                return Some(<crate::api::media_stream_track::audio_processing_config::NoiseSuppressionLevel>::sse_decode(deserializer));
            } else {
                return None;
            }}
                }

impl SseDecode
    for Option<crate::api::stats::rtc_ice_candidate_stats::Protocol>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::stats::rtc_ice_candidate_stats::Protocol>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::stats::rtc_inbound_rtp_stream_media_type::RtcInboundRtpStreamMediaType> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {if (<bool>::sse_decode(deserializer)) {
                return Some(<crate::api::stats::rtc_inbound_rtp_stream_media_type::RtcInboundRtpStreamMediaType>::sse_decode(deserializer));
            } else {
                return None;
            }}
                }

impl SseDecode for Option<crate::api::capability::rtp_codec::rtcp_feedback::RtcpFeedbackMessageType> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {if (<bool>::sse_decode(deserializer)) {
                return Some(<crate::api::capability::rtp_codec::rtcp_feedback::RtcpFeedbackMessageType>::sse_decode(deserializer));
            } else {
                return None;
            }}
                }

impl SseDecode for Option<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u32>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u64>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode
    for Option<crate::api::media::constraints::video::VideoConstraints>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::media::constraints::video::VideoConstraints>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for crate::api::peer::events::PeerConnectionEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_peer =
                    <RustOpaqueMoi<Arc<PeerConnection>>>::sse_decode(
                        deserializer,
                    );
                return crate::api::peer::events::PeerConnectionEvent::PeerCreated{peer: var_peer};
            }
            1 => {
                let mut var_sdpMid = <String>::sse_decode(deserializer);
                let mut var_sdpMlineIndex = <i32>::sse_decode(deserializer);
                let mut var_candidate = <String>::sse_decode(deserializer);
                return crate::api::peer::events::PeerConnectionEvent::IceCandidate{sdp_mid: var_sdpMid, sdp_mline_index: var_sdpMlineIndex, candidate: var_candidate};
            }
            2 => {
                let mut var_field0 = <crate::api::peer::events::ice_gathering_state::IceGatheringState>::sse_decode(deserializer);
                return crate::api::peer::events::PeerConnectionEvent::IceGatheringStateChange(var_field0);
            }
            3 => {
                let mut var_address = <String>::sse_decode(deserializer);
                let mut var_port = <i32>::sse_decode(deserializer);
                let mut var_url = <String>::sse_decode(deserializer);
                let mut var_errorCode = <i32>::sse_decode(deserializer);
                let mut var_errorText = <String>::sse_decode(deserializer);
                return crate::api::peer::events::PeerConnectionEvent::IceCandidateError{address: var_address, port: var_port, url: var_url, error_code: var_errorCode, error_text: var_errorText};
            }
            4 => {
                return crate::api::peer::events::PeerConnectionEvent::NegotiationNeeded;
            }
            5 => {
                let mut var_field0 = <crate::api::peer::events::signaling_state::SignalingState>::sse_decode(deserializer);
                return crate::api::peer::events::PeerConnectionEvent::SignallingChange(var_field0);
            }
            6 => {
                let mut var_field0 = <crate::api::peer::events::ice_connection_state::IceConnectionState>::sse_decode(deserializer);
                return crate::api::peer::events::PeerConnectionEvent::IceConnectionStateChange(var_field0);
            }
            7 => {
                let mut var_field0 = <crate::api::peer::events::peer_connection_state::PeerConnectionState>::sse_decode(deserializer);
                return crate::api::peer::events::PeerConnectionEvent::ConnectionStateChange(var_field0);
            }
            8 => {
                let mut var_field0 = <crate::api::peer::events::rtc_track_event::RtcTrackEvent>::sse_decode(deserializer);
                return crate::api::peer::events::PeerConnectionEvent::Track(
                    var_field0,
                );
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode
    for crate::api::peer::events::peer_connection_state::PeerConnectionState
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::peer::events::peer_connection_state::PeerConnectionState::New,
1 => crate::api::peer::events::peer_connection_state::PeerConnectionState::Connecting,
2 => crate::api::peer::events::peer_connection_state::PeerConnectionState::Connected,
3 => crate::api::peer::events::peer_connection_state::PeerConnectionState::Disconnected,
4 => crate::api::peer::events::peer_connection_state::PeerConnectionState::Failed,
5 => crate::api::peer::events::peer_connection_state::PeerConnectionState::Closed,
            _ => unreachable!("Invalid variant for PeerConnectionState: {}", inner),
        };
    }
}

impl SseDecode for crate::api::stats::rtc_ice_candidate_stats::Protocol {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::stats::rtc_ice_candidate_stats::Protocol::Tcp,
            1 => crate::api::stats::rtc_ice_candidate_stats::Protocol::Udp,
            _ => unreachable!("Invalid variant for Protocol: {}", inner),
        };
    }
}

impl SseDecode
    for (
        crate::api::rtc_rtp_encoding_parameters::RtcRtpEncodingParameters,
        RustOpaqueMoi<Arc<RtpEncodingParameters>>,
    )
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut var_field0 = <crate::api::rtc_rtp_encoding_parameters::RtcRtpEncodingParameters>::sse_decode(deserializer);
        let mut var_field1 =
            <RustOpaqueMoi<Arc<RtpEncodingParameters>>>::sse_decode(
                deserializer,
            );
        return (var_field0, var_field1);
    }
}

impl SseDecode for (String, String) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut var_field0 = <String>::sse_decode(deserializer);
        let mut var_field1 = <String>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for crate::api::peer::rtc_configuration::RtcConfiguration {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut var_iceTransportPolicy = <crate::api::peer::rtc_configuration::ice_transports_type::IceTransportsType>::sse_decode(deserializer);
        let mut var_bundlePolicy = <crate::api::peer::rtc_configuration::bundle_policy::BundlePolicy>::sse_decode(deserializer);
        let mut var_iceServers = <Vec<
            crate::api::peer::rtc_configuration::rtc_ice_server::RtcIceServer,
        >>::sse_decode(deserializer);
        return crate::api::peer::rtc_configuration::RtcConfiguration {
            ice_transport_policy: var_iceTransportPolicy,
            bundle_policy: var_bundlePolicy,
            ice_servers: var_iceServers,
        };
    }
}

impl SseDecode
    for crate::api::stats::rtc_ice_candidate_stats::RtcIceCandidateStats
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 = <crate::api::stats::rtc_ice_candidate_stats::IceCandidateStats>::sse_decode(deserializer);
                return crate::api::stats::rtc_ice_candidate_stats::RtcIceCandidateStats::Local(var_field0);
            }
            1 => {
                let mut var_field0 = <crate::api::stats::rtc_ice_candidate_stats::IceCandidateStats>::sse_decode(deserializer);
                return crate::api::stats::rtc_ice_candidate_stats::RtcIceCandidateStats::Remote(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode
    for crate::api::peer::rtc_configuration::rtc_ice_server::RtcIceServer
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut var_urls = <Vec<String>>::sse_decode(deserializer);
        let mut var_username = <String>::sse_decode(deserializer);
        let mut var_credential = <String>::sse_decode(deserializer);
        return crate::api::peer::rtc_configuration::rtc_ice_server::RtcIceServer{urls: var_urls, username: var_username, credential: var_credential};
    }
}

impl SseDecode for crate::api::stats::rtc_inbound_rtp_stream_media_type::RtcInboundRtpStreamMediaType {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut tag_ = <i32>::sse_decode(deserializer);
            match tag_ {0 => { let mut var_voiceActivityFlag = <Option<bool>>::sse_decode(deserializer);
let mut var_totalSamplesReceived = <Option<u64>>::sse_decode(deserializer);
let mut var_concealedSamples = <Option<u64>>::sse_decode(deserializer);
let mut var_silentConcealedSamples = <Option<u64>>::sse_decode(deserializer);
let mut var_audioLevel = <Option<f64>>::sse_decode(deserializer);
let mut var_totalAudioEnergy = <Option<f64>>::sse_decode(deserializer);
let mut var_totalSamplesDuration = <Option<f64>>::sse_decode(deserializer);
return crate::api::stats::rtc_inbound_rtp_stream_media_type::RtcInboundRtpStreamMediaType::Audio{voice_activity_flag: var_voiceActivityFlag, total_samples_received: var_totalSamplesReceived, concealed_samples: var_concealedSamples, silent_concealed_samples: var_silentConcealedSamples, audio_level: var_audioLevel, total_audio_energy: var_totalAudioEnergy, total_samples_duration: var_totalSamplesDuration}; }
1 => { let mut var_framesDecoded = <Option<u32>>::sse_decode(deserializer);
let mut var_keyFramesDecoded = <Option<u32>>::sse_decode(deserializer);
let mut var_frameWidth = <Option<u32>>::sse_decode(deserializer);
let mut var_frameHeight = <Option<u32>>::sse_decode(deserializer);
let mut var_totalInterFrameDelay = <Option<f64>>::sse_decode(deserializer);
let mut var_framesPerSecond = <Option<f64>>::sse_decode(deserializer);
let mut var_firCount = <Option<u32>>::sse_decode(deserializer);
let mut var_pliCount = <Option<u32>>::sse_decode(deserializer);
let mut var_sliCount = <Option<u32>>::sse_decode(deserializer);
let mut var_concealmentEvents = <Option<u64>>::sse_decode(deserializer);
let mut var_framesReceived = <Option<i32>>::sse_decode(deserializer);
return crate::api::stats::rtc_inbound_rtp_stream_media_type::RtcInboundRtpStreamMediaType::Video{frames_decoded: var_framesDecoded, key_frames_decoded: var_keyFramesDecoded, frame_width: var_frameWidth, frame_height: var_frameHeight, total_inter_frame_delay: var_totalInterFrameDelay, frames_per_second: var_framesPerSecond, fir_count: var_firCount, pli_count: var_pliCount, sli_count: var_sliCount, concealment_events: var_concealmentEvents, frames_received: var_framesReceived}; }
 _ => { unimplemented!(""); }}}
                }

impl SseDecode for crate::api::stats::rtc_media_source_stats_media_type::RtcMediaSourceStatsMediaType {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut tag_ = <i32>::sse_decode(deserializer);
            match tag_ {0 => { let mut var_width = <Option<u32>>::sse_decode(deserializer);
let mut var_height = <Option<u32>>::sse_decode(deserializer);
let mut var_frames = <Option<u32>>::sse_decode(deserializer);
let mut var_framesPerSecond = <Option<f64>>::sse_decode(deserializer);
return crate::api::stats::rtc_media_source_stats_media_type::RtcMediaSourceStatsMediaType::RtcVideoSourceStats{width: var_width, height: var_height, frames: var_frames, frames_per_second: var_framesPerSecond}; }
1 => { let mut var_audioLevel = <Option<f64>>::sse_decode(deserializer);
let mut var_totalAudioEnergy = <Option<f64>>::sse_decode(deserializer);
let mut var_totalSamplesDuration = <Option<f64>>::sse_decode(deserializer);
let mut var_echoReturnLoss = <Option<f64>>::sse_decode(deserializer);
let mut var_echoReturnLossEnhancement = <Option<f64>>::sse_decode(deserializer);
return crate::api::stats::rtc_media_source_stats_media_type::RtcMediaSourceStatsMediaType::RtcAudioSourceStats{audio_level: var_audioLevel, total_audio_energy: var_totalAudioEnergy, total_samples_duration: var_totalSamplesDuration, echo_return_loss: var_echoReturnLoss, echo_return_loss_enhancement: var_echoReturnLossEnhancement}; }
 _ => { unimplemented!(""); }}}
                }

impl SseDecode for crate::api::stats::rtc_outbound_rtp_stream_media_type::RtcOutboundRtpStreamStatsMediaType {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut tag_ = <i32>::sse_decode(deserializer);
            match tag_ {0 => { let mut var_totalSamplesSent = <Option<u64>>::sse_decode(deserializer);
let mut var_voiceActivityFlag = <Option<bool>>::sse_decode(deserializer);
return crate::api::stats::rtc_outbound_rtp_stream_media_type::RtcOutboundRtpStreamStatsMediaType::Audio{total_samples_sent: var_totalSamplesSent, voice_activity_flag: var_voiceActivityFlag}; }
1 => { let mut var_frameWidth = <Option<u32>>::sse_decode(deserializer);
let mut var_frameHeight = <Option<u32>>::sse_decode(deserializer);
let mut var_framesPerSecond = <Option<f64>>::sse_decode(deserializer);
return crate::api::stats::rtc_outbound_rtp_stream_media_type::RtcOutboundRtpStreamStatsMediaType::Video{frame_width: var_frameWidth, frame_height: var_frameHeight, frames_per_second: var_framesPerSecond}; }
 _ => { unimplemented!(""); }}}
                }

impl SseDecode
    for crate::api::rtc_rtp_encoding_parameters::RtcRtpEncodingParameters
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut var_rid = <String>::sse_decode(deserializer);
        let mut var_active = <bool>::sse_decode(deserializer);
        let mut var_maxBitrate = <Option<i32>>::sse_decode(deserializer);
        let mut var_maxFramerate = <Option<f64>>::sse_decode(deserializer);
        let mut var_scaleResolutionDownBy =
            <Option<f64>>::sse_decode(deserializer);
        let mut var_scalabilityMode =
            <Option<String>>::sse_decode(deserializer);
        return crate::api::rtc_rtp_encoding_parameters::RtcRtpEncodingParameters{rid: var_rid, active: var_active, max_bitrate: var_maxBitrate, max_framerate: var_maxFramerate, scale_resolution_down_by: var_scaleResolutionDownBy, scalability_mode: var_scalabilityMode};
    }
}

impl SseDecode for crate::api::rtc_rtp_send_parameters::RtcRtpSendParameters {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut var_encodings = <Vec<(
            crate::api::rtc_rtp_encoding_parameters::RtcRtpEncodingParameters,
            RustOpaqueMoi<Arc<RtpEncodingParameters>>,
        )>>::sse_decode(deserializer);
        let mut var_inner =
            <RustOpaqueMoi<Arc<RtpParameters>>>::sse_decode(deserializer);
        return crate::api::rtc_rtp_send_parameters::RtcRtpSendParameters {
            encodings: var_encodings,
            inner: var_inner,
        };
    }
}

impl SseDecode for crate::api::transceiver::RtcRtpTransceiver {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut var_peer =
            <RustOpaqueMoi<Arc<PeerConnection>>>::sse_decode(deserializer);
        let mut var_transceiver =
            <RustOpaqueMoi<Arc<RtpTransceiver>>>::sse_decode(deserializer);
        let mut var_mid = <Option<String>>::sse_decode(deserializer);
        let mut var_direction = <crate::api::transceiver::direction::RtpTransceiverDirection>::sse_decode(deserializer);
        return crate::api::transceiver::RtcRtpTransceiver {
            peer: var_peer,
            transceiver: var_transceiver,
            mid: var_mid,
            direction: var_direction,
        };
    }
}

impl SseDecode
    for crate::api::peer::rtc_session_description::RtcSessionDescription
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut var_sdp = <String>::sse_decode(deserializer);
        let mut var_kind =
            <crate::api::peer::rtc_session_description::SdpType>::sse_decode(
                deserializer,
            );
        return crate::api::peer::rtc_session_description::RtcSessionDescription{sdp: var_sdp, kind: var_kind};
    }
}

impl SseDecode for crate::api::stats::RtcStats {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_timestampUs = <i64>::sse_decode(deserializer);
        let mut var_kind =
            <crate::api::stats::RtcStatsType>::sse_decode(deserializer);
        return crate::api::stats::RtcStats {
            id: var_id,
            timestamp_us: var_timestampUs,
            kind: var_kind,
        };
    }
}

impl SseDecode for crate::api::stats::rtc_stats_ice_candidate_pair_state::RtcStatsIceCandidatePairState {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::stats::rtc_stats_ice_candidate_pair_state::RtcStatsIceCandidatePairState::Frozen,
1 => crate::api::stats::rtc_stats_ice_candidate_pair_state::RtcStatsIceCandidatePairState::Waiting,
2 => crate::api::stats::rtc_stats_ice_candidate_pair_state::RtcStatsIceCandidatePairState::InProgress,
3 => crate::api::stats::rtc_stats_ice_candidate_pair_state::RtcStatsIceCandidatePairState::Failed,
4 => crate::api::stats::rtc_stats_ice_candidate_pair_state::RtcStatsIceCandidatePairState::Succeeded,
            _ => unreachable!("Invalid variant for RtcStatsIceCandidatePairState: {}", inner),
        };}
                }

impl SseDecode for crate::api::stats::RtcStatsType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_trackIdentifier =
                    <Option<String>>::sse_decode(deserializer);
                let mut var_kind = <crate::api::stats::rtc_media_source_stats_media_type::RtcMediaSourceStatsMediaType>::sse_decode(deserializer);
                return crate::api::stats::RtcStatsType::RtcMediaSourceStats {
                    track_identifier: var_trackIdentifier,
                    kind: var_kind,
                };
            }
            1 => {
                let mut var_field0 = <crate::api::stats::rtc_ice_candidate_stats::RtcIceCandidateStats>::sse_decode(deserializer);
                return crate::api::stats::RtcStatsType::RtcIceCandidateStats(
                    var_field0,
                );
            }
            2 => {
                let mut var_trackId =
                    <Option<String>>::sse_decode(deserializer);
                let mut var_mediaType = <crate::api::stats::rtc_outbound_rtp_stream_media_type::RtcOutboundRtpStreamStatsMediaType>::sse_decode(deserializer);
                let mut var_bytesSent = <Option<u64>>::sse_decode(deserializer);
                let mut var_packetsSent =
                    <Option<u32>>::sse_decode(deserializer);
                let mut var_mediaSourceId =
                    <Option<String>>::sse_decode(deserializer);
                return crate::api::stats::RtcStatsType::RtcOutboundRtpStreamStats{track_id: var_trackId, media_type: var_mediaType, bytes_sent: var_bytesSent, packets_sent: var_packetsSent, media_source_id: var_mediaSourceId};
            }
            3 => {
                let mut var_remoteId =
                    <Option<String>>::sse_decode(deserializer);
                let mut var_bytesReceived =
                    <Option<u64>>::sse_decode(deserializer);
                let mut var_packetsReceived =
                    <Option<u32>>::sse_decode(deserializer);
                let mut var_packetsLost =
                    <Option<u64>>::sse_decode(deserializer);
                let mut var_jitter = <Option<f64>>::sse_decode(deserializer);
                let mut var_totalDecodeTime =
                    <Option<f64>>::sse_decode(deserializer);
                let mut var_jitterBufferEmittedCount =
                    <Option<u64>>::sse_decode(deserializer);
                let mut var_mediaType = <Option<crate::api::stats::rtc_inbound_rtp_stream_media_type::RtcInboundRtpStreamMediaType>>::sse_decode(deserializer);
                return crate::api::stats::RtcStatsType::RtcInboundRtpStreamStats{remote_id: var_remoteId, bytes_received: var_bytesReceived, packets_received: var_packetsReceived, packets_lost: var_packetsLost, jitter: var_jitter, total_decode_time: var_totalDecodeTime, jitter_buffer_emitted_count: var_jitterBufferEmittedCount, media_type: var_mediaType};
            }
            4 => {
                let mut var_state = <crate::api::stats::rtc_stats_ice_candidate_pair_state::RtcStatsIceCandidatePairState>::sse_decode(deserializer);
                let mut var_nominated =
                    <Option<bool>>::sse_decode(deserializer);
                let mut var_bytesSent = <Option<u64>>::sse_decode(deserializer);
                let mut var_bytesReceived =
                    <Option<u64>>::sse_decode(deserializer);
                let mut var_totalRoundTripTime =
                    <Option<f64>>::sse_decode(deserializer);
                let mut var_currentRoundTripTime =
                    <Option<f64>>::sse_decode(deserializer);
                let mut var_availableOutgoingBitrate =
                    <Option<f64>>::sse_decode(deserializer);
                return crate::api::stats::RtcStatsType::RtcIceCandidatePairStats{state: var_state, nominated: var_nominated, bytes_sent: var_bytesSent, bytes_received: var_bytesReceived, total_round_trip_time: var_totalRoundTripTime, current_round_trip_time: var_currentRoundTripTime, available_outgoing_bitrate: var_availableOutgoingBitrate};
            }
            5 => {
                let mut var_packetsSent =
                    <Option<u64>>::sse_decode(deserializer);
                let mut var_packetsReceived =
                    <Option<u64>>::sse_decode(deserializer);
                let mut var_bytesSent = <Option<u64>>::sse_decode(deserializer);
                let mut var_bytesReceived =
                    <Option<u64>>::sse_decode(deserializer);
                let mut var_iceRole =
                    <Option<crate::api::stats::ice_role::IceRole>>::sse_decode(
                        deserializer,
                    );
                return crate::api::stats::RtcStatsType::RtcTransportStats {
                    packets_sent: var_packetsSent,
                    packets_received: var_packetsReceived,
                    bytes_sent: var_bytesSent,
                    bytes_received: var_bytesReceived,
                    ice_role: var_iceRole,
                };
            }
            6 => {
                let mut var_localId =
                    <Option<String>>::sse_decode(deserializer);
                let mut var_jitter = <Option<f64>>::sse_decode(deserializer);
                let mut var_roundTripTime =
                    <Option<f64>>::sse_decode(deserializer);
                let mut var_fractionLost =
                    <Option<f64>>::sse_decode(deserializer);
                let mut var_reportsReceived =
                    <Option<u64>>::sse_decode(deserializer);
                let mut var_roundTripTimeMeasurements =
                    <Option<i32>>::sse_decode(deserializer);
                return crate::api::stats::RtcStatsType::RtcRemoteInboundRtpStreamStats{local_id: var_localId, jitter: var_jitter, round_trip_time: var_roundTripTime, fraction_lost: var_fractionLost, reports_received: var_reportsReceived, round_trip_time_measurements: var_roundTripTimeMeasurements};
            }
            7 => {
                let mut var_localId =
                    <Option<String>>::sse_decode(deserializer);
                let mut var_remoteTimestamp =
                    <Option<f64>>::sse_decode(deserializer);
                let mut var_reportsSent =
                    <Option<u64>>::sse_decode(deserializer);
                return crate::api::stats::RtcStatsType::RtcRemoteOutboundRtpStreamStats{local_id: var_localId, remote_timestamp: var_remoteTimestamp, reports_sent: var_reportsSent};
            }
            8 => {
                return crate::api::stats::RtcStatsType::Unimplemented;
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::peer::events::rtc_track_event::RtcTrackEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut var_track =
            <crate::api::media_stream_track::MediaStreamTrack>::sse_decode(
                deserializer,
            );
        let mut var_transceiver =
            <crate::api::transceiver::RtcRtpTransceiver>::sse_decode(
                deserializer,
            );
        return crate::api::peer::events::rtc_track_event::RtcTrackEvent {
            track: var_track,
            transceiver: var_transceiver,
        };
    }
}

impl SseDecode
    for crate::api::capability::rtp_codec::rtcp_feedback::RtcpFeedback
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut var_messageType = <Option<crate::api::capability::rtp_codec::rtcp_feedback::RtcpFeedbackMessageType>>::sse_decode(deserializer);
        let mut var_kind = <crate::api::capability::rtp_codec::rtcp_feedback::RtcpFeedbackType>::sse_decode(deserializer);
        return crate::api::capability::rtp_codec::rtcp_feedback::RtcpFeedback{message_type: var_messageType, kind: var_kind};
    }
}

impl SseDecode for crate::api::capability::rtp_codec::rtcp_feedback::RtcpFeedbackMessageType {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::capability::rtp_codec::rtcp_feedback::RtcpFeedbackMessageType::GenericNACK,
1 => crate::api::capability::rtp_codec::rtcp_feedback::RtcpFeedbackMessageType::Pli,
2 => crate::api::capability::rtp_codec::rtcp_feedback::RtcpFeedbackMessageType::Fir,
            _ => unreachable!("Invalid variant for RtcpFeedbackMessageType: {}", inner),
        };}
                }

impl SseDecode
    for crate::api::capability::rtp_codec::rtcp_feedback::RtcpFeedbackType
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::capability::rtp_codec::rtcp_feedback::RtcpFeedbackType::Ccm,
1 => crate::api::capability::rtp_codec::rtcp_feedback::RtcpFeedbackType::Lntf,
2 => crate::api::capability::rtp_codec::rtcp_feedback::RtcpFeedbackType::Nack,
3 => crate::api::capability::rtp_codec::rtcp_feedback::RtcpFeedbackType::Remb,
4 => crate::api::capability::rtp_codec::rtcp_feedback::RtcpFeedbackType::TransportCC,
            _ => unreachable!("Invalid variant for RtcpFeedbackType: {}", inner),
        };
    }
}

impl SseDecode for crate::api::capability::RtpCapabilities {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut var_codecs = <Vec<
            crate::api::capability::rtp_codec::RtpCodecCapability,
        >>::sse_decode(deserializer);
        let mut var_headerExtensions = <Vec<crate::api::capability::rtp_header_extension_capability::RtpHeaderExtensionCapability>>::sse_decode(deserializer);
        return crate::api::capability::RtpCapabilities {
            codecs: var_codecs,
            header_extensions: var_headerExtensions,
        };
    }
}

impl SseDecode for crate::api::capability::rtp_codec::RtpCodecCapability {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut var_preferredPayloadType =
            <Option<i32>>::sse_decode(deserializer);
        let mut var_scalabilityModes = <Vec<crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode>>::sse_decode(deserializer);
        let mut var_mimeType = <String>::sse_decode(deserializer);
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_kind =
            <crate::api::media_stream_track::media_type::MediaType>::sse_decode(
                deserializer,
            );
        let mut var_clockRate = <Option<i32>>::sse_decode(deserializer);
        let mut var_numChannels = <Option<i32>>::sse_decode(deserializer);
        let mut var_parameters =
            <Vec<(String, String)>>::sse_decode(deserializer);
        let mut var_feedback = <Vec<
            crate::api::capability::rtp_codec::rtcp_feedback::RtcpFeedback,
        >>::sse_decode(deserializer);
        return crate::api::capability::rtp_codec::RtpCodecCapability {
            preferred_payload_type: var_preferredPayloadType,
            scalability_modes: var_scalabilityModes,
            mime_type: var_mimeType,
            name: var_name,
            kind: var_kind,
            clock_rate: var_clockRate,
            num_channels: var_numChannels,
            parameters: var_parameters,
            feedback: var_feedback,
        };
    }
}

impl SseDecode for crate::api::capability::rtp_header_extension_capability::RtpHeaderExtensionCapability {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {let mut var_uri = <String>::sse_decode(deserializer);
let mut var_preferredId = <Option<i32>>::sse_decode(deserializer);
let mut var_preferredEncrypted = <bool>::sse_decode(deserializer);
let mut var_direction = <crate::api::transceiver::direction::RtpTransceiverDirection>::sse_decode(deserializer);
return crate::api::capability::rtp_header_extension_capability::RtpHeaderExtensionCapability{uri: var_uri, preferred_id: var_preferredId, preferred_encrypted: var_preferredEncrypted, direction: var_direction};}
                }

impl SseDecode for crate::api::transceiver::direction::RtpTransceiverDirection {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::transceiver::direction::RtpTransceiverDirection::SendRecv,
1 => crate::api::transceiver::direction::RtpTransceiverDirection::SendOnly,
2 => crate::api::transceiver::direction::RtpTransceiverDirection::RecvOnly,
3 => crate::api::transceiver::direction::RtpTransceiverDirection::Inactive,
4 => crate::api::transceiver::direction::RtpTransceiverDirection::Stopped,
            _ => unreachable!("Invalid variant for RtpTransceiverDirection: {}", inner),
        };
    }
}

impl SseDecode for crate::api::transceiver::init::RtpTransceiverInit {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut var_direction = <crate::api::transceiver::direction::RtpTransceiverDirection>::sse_decode(deserializer);
        let mut var_sendEncodings = <Vec<
            crate::api::rtc_rtp_encoding_parameters::RtcRtpEncodingParameters,
        >>::sse_decode(deserializer);
        return crate::api::transceiver::init::RtpTransceiverInit {
            direction: var_direction,
            send_encodings: var_sendEncodings,
        };
    }
}

impl SseDecode
    for crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::L1T1,
1 => crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::L1T2,
2 => crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::L1T3,
3 => crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::L2T1,
4 => crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::L2T1h,
5 => crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::L2t1Key,
6 => crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::L2T2,
7 => crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::L2T2h,
8 => crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::L2T2Key,
9 => crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::L2T2KeyShift,
10 => crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::L2T3,
11 => crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::L2T3h,
12 => crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::L2T3Key,
13 => crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::L3T1,
14 => crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::L3T1h,
15 => crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::L3T1Key,
16 => crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::L3T2,
17 => crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::L3T2h,
18 => crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::L3T2Key,
19 => crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::L3T3,
20 => crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::L3T3h,
21 => crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::L3T3Key,
22 => crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::S2T1,
23 => crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::S2T1h,
24 => crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::S2T2,
25 => crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::S2T2h,
26 => crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::S2T3,
27 => crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::S2T3h,
28 => crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::S3T1,
29 => crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::S3T1h,
30 => crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::S3T2,
31 => crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::S3T2h,
32 => crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::S3T3,
33 => crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::S3T3h,
            _ => unreachable!("Invalid variant for ScalabilityMode: {}", inner),
        };
    }
}

impl SseDecode for crate::api::peer::rtc_session_description::SdpType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::peer::rtc_session_description::SdpType::Offer,
            1 => crate::api::peer::rtc_session_description::SdpType::PrAnswer,
            2 => crate::api::peer::rtc_session_description::SdpType::Answer,
            3 => crate::api::peer::rtc_session_description::SdpType::Rollback,
            _ => unreachable!("Invalid variant for SdpType: {}", inner),
        };
    }
}

impl SseDecode for crate::api::peer::events::signaling_state::SignalingState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::peer::events::signaling_state::SignalingState::Stable,
1 => crate::api::peer::events::signaling_state::SignalingState::HaveLocalOffer,
2 => crate::api::peer::events::signaling_state::SignalingState::HaveLocalPrAnswer,
3 => crate::api::peer::events::signaling_state::SignalingState::HaveRemoteOffer,
4 => crate::api::peer::events::signaling_state::SignalingState::HaveRemotePrAnswer,
5 => crate::api::peer::events::signaling_state::SignalingState::Closed,
            _ => unreachable!("Invalid variant for SignalingState: {}", inner),
        };
    }
}

impl SseDecode for crate::renderer::TextureEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_textureId = <i64>::sse_decode(deserializer);
                let mut var_width = <i32>::sse_decode(deserializer);
                let mut var_height = <i32>::sse_decode(deserializer);
                let mut var_rotation = <i32>::sse_decode(deserializer);
                return crate::renderer::TextureEvent::OnTextureChange {
                    texture_id: var_textureId,
                    width: var_width,
                    height: var_height,
                    rotation: var_rotation,
                };
            }
            1 => {
                let mut var_textureId = <i64>::sse_decode(deserializer);
                return crate::renderer::TextureEvent::OnFirstFrameRendered {
                    texture_id: var_textureId,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::media_stream_track::track_event::TrackEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::api::media_stream_track::track_event::TrackEvent::Ended;
            }
            1 => {
                let mut var_field0 = <u32>::sse_decode(deserializer);
                return crate::api::media_stream_track::track_event::TrackEvent::AudioLevelUpdated(var_field0);
            }
            2 => {
                return crate::api::media_stream_track::track_event::TrackEvent::TrackCreated;
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::media_stream_track::track_state::TrackState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::media_stream_track::track_state::TrackState::Live,
            1 => crate::api::media_stream_track::track_state::TrackState::Ended,
            _ => unreachable!("Invalid variant for TrackState: {}", inner),
        };
    }
}

impl SseDecode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        deserializer.cursor.read_u32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        deserializer.cursor.read_u8().unwrap()
    }
}

impl SseDecode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
    }
}

impl SseDecode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap() as _
    }
}

impl SseDecode for crate::api::peer::video_codec_info::VideoCodec {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::peer::video_codec_info::VideoCodec::AV1,
            1 => crate::api::peer::video_codec_info::VideoCodec::H264,
            2 => crate::api::peer::video_codec_info::VideoCodec::H265,
            3 => crate::api::peer::video_codec_info::VideoCodec::VP8,
            4 => crate::api::peer::video_codec_info::VideoCodec::VP9,
            _ => unreachable!("Invalid variant for VideoCodec: {}", inner),
        };
    }
}

impl SseDecode for crate::api::peer::video_codec_info::VideoCodecInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut var_isHardwareAccelerated = <bool>::sse_decode(deserializer);
        let mut var_codec =
            <crate::api::peer::video_codec_info::VideoCodec>::sse_decode(
                deserializer,
            );
        return crate::api::peer::video_codec_info::VideoCodecInfo {
            is_hardware_accelerated: var_isHardwareAccelerated,
            codec: var_codec,
        };
    }
}

impl SseDecode for crate::api::media::constraints::video::VideoConstraints {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(
        deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer,
    ) -> Self {
        let mut var_deviceId = <Option<String>>::sse_decode(deserializer);
        let mut var_width = <u32>::sse_decode(deserializer);
        let mut var_height = <u32>::sse_decode(deserializer);
        let mut var_frameRate = <u32>::sse_decode(deserializer);
        let mut var_isDisplay = <bool>::sse_decode(deserializer);
        return crate::api::media::constraints::video::VideoConstraints {
            device_id: var_deviceId,
            width: var_width,
            height: var_height,
            frame_rate: var_frameRate,
            is_display: var_isDisplay,
        };
    }
}

fn pde_ffi_dispatcher_primary_impl(
    func_id: i32,
    port: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
                        1 => wire__crate__api__peer__add_ice_candidate_impl(port, ptr, rust_vec_len, data_len),
2 => wire__crate__api__transceiver__add_transceiver_impl(port, ptr, rust_vec_len, data_len),
3 => wire__crate__api__media__constraints__audio__audio_processing_constraints_default_impl(port, ptr, rust_vec_len, data_len),
4 => wire__crate__api__media_stream_track__clone_track_impl(port, ptr, rust_vec_len, data_len),
5 => wire__crate__api__peer__create_answer_impl(port, ptr, rust_vec_len, data_len),
6 => wire__crate__api__peer__create_offer_impl(port, ptr, rust_vec_len, data_len),
7 => wire__crate__api__peer__create_peer_connection_impl(port, ptr, rust_vec_len, data_len),
8 => wire__crate__api__media_stream_track__create_video_sink_impl(port, ptr, rust_vec_len, data_len),
9 => wire__crate__api__peer__dispose_peer_connection_impl(port, ptr, rust_vec_len, data_len),
10 => wire__crate__api__media_stream_track__dispose_track_impl(port, ptr, rust_vec_len, data_len),
11 => wire__crate__api__media_stream_track__dispose_video_sink_impl(port, ptr, rust_vec_len, data_len),
12 => wire__crate__api__media__enable_fake_media_impl(port, ptr, rust_vec_len, data_len),
13 => wire__crate__api__media__enumerate_devices_impl(port, ptr, rust_vec_len, data_len),
14 => wire__crate__api__media__enumerate_displays_impl(port, ptr, rust_vec_len, data_len),
15 => wire__crate__api__media_stream_track__audio_processing_config__get_audio_processing_config_impl(port, ptr, rust_vec_len, data_len),
16 => wire__crate__api__media_stream_track__get_media_impl(port, ptr, rust_vec_len, data_len),
17 => wire__crate__api__stats__get_peer_stats_impl(port, ptr, rust_vec_len, data_len),
18 => wire__crate__api__capability__get_rtp_receiver_capabilities_impl(port, ptr, rust_vec_len, data_len),
19 => wire__crate__api__capability__get_rtp_sender_capabilities_impl(port, ptr, rust_vec_len, data_len),
20 => wire__crate__api__transceiver__get_transceiver_direction_impl(port, ptr, rust_vec_len, data_len),
21 => wire__crate__api__transceiver__get_transceiver_mid_impl(port, ptr, rust_vec_len, data_len),
22 => wire__crate__api__transceiver__get_transceivers_impl(port, ptr, rust_vec_len, data_len),
23 => wire__crate__api__media__is_fake_media_impl(port, ptr, rust_vec_len, data_len),
24 => wire__crate__api__media__microphone_volume_impl(port, ptr, rust_vec_len, data_len),
25 => wire__crate__api__media__microphone_volume_is_available_impl(port, ptr, rust_vec_len, data_len),
26 => wire__crate__api__media_stream_track__register_track_observer_impl(port, ptr, rust_vec_len, data_len),
27 => wire__crate__api__peer__restart_ice_impl(port, ptr, rust_vec_len, data_len),
28 => wire__crate__api__sender_get_parameters_impl(port, ptr, rust_vec_len, data_len),
29 => wire__crate__api__sender_replace_track_impl(port, ptr, rust_vec_len, data_len),
30 => wire__crate__api__sender_set_parameters_impl(port, ptr, rust_vec_len, data_len),
31 => wire__crate__api__media_stream_track__set_audio_level_observer_enabled_impl(port, ptr, rust_vec_len, data_len),
32 => wire__crate__api__media__set_audio_playout_device_impl(port, ptr, rust_vec_len, data_len),
33 => wire__crate__api__capability__rtp_codec__set_codec_preferences_impl(port, ptr, rust_vec_len, data_len),
34 => wire__crate__api__peer__rtc_session_description__set_local_description_impl(port, ptr, rust_vec_len, data_len),
35 => wire__crate__api__media__set_microphone_volume_impl(port, ptr, rust_vec_len, data_len),
36 => wire__crate__api__media__set_on_device_changed_impl(port, ptr, rust_vec_len, data_len),
37 => wire__crate__api__peer__rtc_session_description__set_remote_description_impl(port, ptr, rust_vec_len, data_len),
38 => wire__crate__api__media_stream_track__set_track_enabled_impl(port, ptr, rust_vec_len, data_len),
39 => wire__crate__api__transceiver__set_transceiver_direction_impl(port, ptr, rust_vec_len, data_len),
40 => wire__crate__api__transceiver__set_transceiver_recv_impl(port, ptr, rust_vec_len, data_len),
41 => wire__crate__api__transceiver__set_transceiver_send_impl(port, ptr, rust_vec_len, data_len),
42 => wire__crate__api__transceiver__stop_transceiver_impl(port, ptr, rust_vec_len, data_len),
43 => wire__crate__api__media_stream_track__track_height_impl(port, ptr, rust_vec_len, data_len),
44 => wire__crate__api__media_stream_track__track_state_impl(port, ptr, rust_vec_len, data_len),
45 => wire__crate__api__media_stream_track__track_width_impl(port, ptr, rust_vec_len, data_len),
46 => wire__crate__api__media_stream_track__update_audio_processing_impl(port, ptr, rust_vec_len, data_len),
47 => wire__crate__api__peer__video_codec_info__video_decoders_impl(port, ptr, rust_vec_len, data_len),
48 => wire__crate__api__peer__video_codec_info__video_encoders_impl(port, ptr, rust_vec_len, data_len),
                        _ => unreachable!(),
                    }
}

fn pde_ffi_dispatcher_sync_impl(
    func_id: i32,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        _ => unreachable!(),
    }
}

// Section: rust2dart

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::media::constraints::audio::AudioConstraints
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.device_id.into_into_dart().into_dart(),
            self.processing.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::media::constraints::audio::AudioConstraints
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::api::media::constraints::audio::AudioConstraints,
    > for crate::api::media::constraints::audio::AudioConstraints
{
    fn into_into_dart(
        self,
    ) -> crate::api::media::constraints::audio::AudioConstraints {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::media_stream_track::audio_processing_config::AudioProcessingConfig {
                fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
                    [
                    self.auto_gain_control.into_into_dart().into_dart(),
self.high_pass_filter.into_into_dart().into_dart(),
self.noise_suppression.into_into_dart().into_dart(),
self.noise_suppression_level.into_into_dart().into_dart(),
self.echo_cancellation.into_into_dart().into_dart()
                ].into_dart()
                }
            }
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::media_stream_track::audio_processing_config::AudioProcessingConfig {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::media_stream_track::audio_processing_config::AudioProcessingConfig> for crate::api::media_stream_track::audio_processing_config::AudioProcessingConfig {
            fn into_into_dart(self) -> crate::api::media_stream_track::audio_processing_config::AudioProcessingConfig {
                self
            }
        }
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::media::constraints::audio::AudioProcessingConstraints
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.auto_gain_control.into_into_dart().into_dart(),
            self.high_pass_filter.into_into_dart().into_dart(),
            self.noise_suppression.into_into_dart().into_dart(),
            self.noise_suppression_level.into_into_dart().into_dart(),
            self.echo_cancellation.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::media::constraints::audio::AudioProcessingConstraints
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::api::media::constraints::audio::AudioProcessingConstraints,
    > for crate::api::media::constraints::audio::AudioProcessingConstraints
{
    fn into_into_dart(
        self,
    ) -> crate::api::media::constraints::audio::AudioProcessingConstraints {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::peer::rtc_configuration::bundle_policy::BundlePolicy
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Balanced => 0.into_dart(),
            Self::MaxBundle => 1.into_dart(),
            Self::MaxCompat => 2.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::peer::rtc_configuration::bundle_policy::BundlePolicy
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::api::peer::rtc_configuration::bundle_policy::BundlePolicy,
    > for crate::api::peer::rtc_configuration::bundle_policy::BundlePolicy
{
    fn into_into_dart(
        self,
    ) -> crate::api::peer::rtc_configuration::bundle_policy::BundlePolicy {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::stats::rtc_ice_candidate_stats::CandidateType
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Host => 0.into_dart(),
            Self::Srflx => 1.into_dart(),
            Self::Prflx => 2.into_dart(),
            Self::Relay => 3.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::stats::rtc_ice_candidate_stats::CandidateType
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::api::stats::rtc_ice_candidate_stats::CandidateType,
    > for crate::api::stats::rtc_ice_candidate_stats::CandidateType
{
    fn into_into_dart(
        self,
    ) -> crate::api::stats::rtc_ice_candidate_stats::CandidateType {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::media_stream_track::GetMediaError
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::media_stream_track::GetMediaError::Audio(field0) => {
                [0.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::media_stream_track::GetMediaError::Video(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::media_stream_track::GetMediaError
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::api::media_stream_track::GetMediaError,
    > for crate::api::media_stream_track::GetMediaError
{
    fn into_into_dart(self) -> crate::api::media_stream_track::GetMediaError {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::media_stream_track::GetMediaResult
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::media_stream_track::GetMediaResult::Ok(field0) => {
                [0.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::media_stream_track::GetMediaResult::Err(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::media_stream_track::GetMediaResult
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::api::media_stream_track::GetMediaResult,
    > for crate::api::media_stream_track::GetMediaResult
{
    fn into_into_dart(self) -> crate::api::media_stream_track::GetMediaResult {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::stats::rtc_ice_candidate_stats::IceCandidateStats
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.transport_id.into_into_dart().into_dart(),
            self.address.into_into_dart().into_dart(),
            self.port.into_into_dart().into_dart(),
            self.protocol.into_into_dart().into_dart(),
            self.candidate_type.into_into_dart().into_dart(),
            self.priority.into_into_dart().into_dart(),
            self.url.into_into_dart().into_dart(),
            self.relay_protocol.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::stats::rtc_ice_candidate_stats::IceCandidateStats
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::api::stats::rtc_ice_candidate_stats::IceCandidateStats,
    > for crate::api::stats::rtc_ice_candidate_stats::IceCandidateStats
{
    fn into_into_dart(
        self,
    ) -> crate::api::stats::rtc_ice_candidate_stats::IceCandidateStats {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::peer::events::ice_connection_state::IceConnectionState
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::New => 0.into_dart(),
            Self::Checking => 1.into_dart(),
            Self::Connected => 2.into_dart(),
            Self::Completed => 3.into_dart(),
            Self::Failed => 4.into_dart(),
            Self::Disconnected => 5.into_dart(),
            Self::Closed => 6.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::peer::events::ice_connection_state::IceConnectionState
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::api::peer::events::ice_connection_state::IceConnectionState,
    > for crate::api::peer::events::ice_connection_state::IceConnectionState
{
    fn into_into_dart(
        self,
    ) -> crate::api::peer::events::ice_connection_state::IceConnectionState
    {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::peer::events::ice_gathering_state::IceGatheringState
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::New => 0.into_dart(),
            Self::Gathering => 1.into_dart(),
            Self::Complete => 2.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::peer::events::ice_gathering_state::IceGatheringState
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::api::peer::events::ice_gathering_state::IceGatheringState,
    > for crate::api::peer::events::ice_gathering_state::IceGatheringState
{
    fn into_into_dart(
        self,
    ) -> crate::api::peer::events::ice_gathering_state::IceGatheringState {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::stats::ice_role::IceRole {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Unknown => 0.into_dart(),
            Self::Controlling => 1.into_dart(),
            Self::Controlled => 2.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::stats::ice_role::IceRole
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::stats::ice_role::IceRole>
    for crate::api::stats::ice_role::IceRole
{
    fn into_into_dart(self) -> crate::api::stats::ice_role::IceRole {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::peer::rtc_configuration::ice_transports_type::IceTransportsType {
                fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
                    match self {
                    Self::All => 0.into_dart(),
Self::Relay => 1.into_dart(),
Self::NoHost => 2.into_dart(),
Self::None => 3.into_dart(),
                    _ => unreachable!(),
                }
                }
            }
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::peer::rtc_configuration::ice_transports_type::IceTransportsType {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::peer::rtc_configuration::ice_transports_type::IceTransportsType> for crate::api::peer::rtc_configuration::ice_transports_type::IceTransportsType {
            fn into_into_dart(self) -> crate::api::peer::rtc_configuration::ice_transports_type::IceTransportsType {
                self
            }
        }
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::media_info::MediaDeviceInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.device_id.into_into_dart().into_dart(),
            self.kind.into_into_dart().into_dart(),
            self.label.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::media_info::MediaDeviceInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::media_info::MediaDeviceInfo>
    for crate::api::media_info::MediaDeviceInfo
{
    fn into_into_dart(self) -> crate::api::media_info::MediaDeviceInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::media_info::MediaDeviceKind {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::AudioInput => 0.into_dart(),
            Self::AudioOutput => 1.into_dart(),
            Self::VideoInput => 2.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::media_info::MediaDeviceKind
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::media_info::MediaDeviceKind>
    for crate::api::media_info::MediaDeviceKind
{
    fn into_into_dart(self) -> crate::api::media_info::MediaDeviceKind {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::media_info::MediaDisplayInfo
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.device_id.into_into_dart().into_dart(),
            self.title.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::media_info::MediaDisplayInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::media_info::MediaDisplayInfo>
    for crate::api::media_info::MediaDisplayInfo
{
    fn into_into_dart(self) -> crate::api::media_info::MediaDisplayInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::media::constraints::MediaStreamConstraints
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.audio.into_into_dart().into_dart(),
            self.video.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::media::constraints::MediaStreamConstraints
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::api::media::constraints::MediaStreamConstraints,
    > for crate::api::media::constraints::MediaStreamConstraints
{
    fn into_into_dart(
        self,
    ) -> crate::api::media::constraints::MediaStreamConstraints {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::media_stream_track::MediaStreamTrack
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.peer_id.into_into_dart().into_dart(),
            self.device_id.into_into_dart().into_dart(),
            self.kind.into_into_dart().into_dart(),
            self.enabled.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::media_stream_track::MediaStreamTrack
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::api::media_stream_track::MediaStreamTrack,
    > for crate::api::media_stream_track::MediaStreamTrack
{
    fn into_into_dart(
        self,
    ) -> crate::api::media_stream_track::MediaStreamTrack {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::media_stream_track::media_type::MediaType
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Audio => 0.into_dart(),
            Self::Video => 1.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::media_stream_track::media_type::MediaType
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::api::media_stream_track::media_type::MediaType,
    > for crate::api::media_stream_track::media_type::MediaType
{
    fn into_into_dart(
        self,
    ) -> crate::api::media_stream_track::media_type::MediaType {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::media_stream_track::audio_processing_config::NoiseSuppressionLevel {
                fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
                    match self {
                    Self::Low => 0.into_dart(),
Self::Moderate => 1.into_dart(),
Self::High => 2.into_dart(),
Self::VeryHigh => 3.into_dart(),
                    _ => unreachable!(),
                }
                }
            }
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::media_stream_track::audio_processing_config::NoiseSuppressionLevel {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::media_stream_track::audio_processing_config::NoiseSuppressionLevel> for crate::api::media_stream_track::audio_processing_config::NoiseSuppressionLevel {
            fn into_into_dart(self) -> crate::api::media_stream_track::audio_processing_config::NoiseSuppressionLevel {
                self
            }
        }
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::peer::events::PeerConnectionEvent
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {crate::api::peer::events::PeerConnectionEvent::PeerCreated{peer} => { [0.into_dart(),
peer.into_into_dart().into_dart()].into_dart() }
crate::api::peer::events::PeerConnectionEvent::IceCandidate{sdp_mid,sdp_mline_index,candidate} => { [1.into_dart(),
sdp_mid.into_into_dart().into_dart(),
sdp_mline_index.into_into_dart().into_dart(),
candidate.into_into_dart().into_dart()].into_dart() }
crate::api::peer::events::PeerConnectionEvent::IceGatheringStateChange(field0) => { [2.into_dart(),
field0.into_into_dart().into_dart()].into_dart() }
crate::api::peer::events::PeerConnectionEvent::IceCandidateError{address,port,url,error_code,error_text} => { [3.into_dart(),
address.into_into_dart().into_dart(),
port.into_into_dart().into_dart(),
url.into_into_dart().into_dart(),
error_code.into_into_dart().into_dart(),
error_text.into_into_dart().into_dart()].into_dart() }
crate::api::peer::events::PeerConnectionEvent::NegotiationNeeded => { [4.into_dart()].into_dart() }
crate::api::peer::events::PeerConnectionEvent::SignallingChange(field0) => { [5.into_dart(),
field0.into_into_dart().into_dart()].into_dart() }
crate::api::peer::events::PeerConnectionEvent::IceConnectionStateChange(field0) => { [6.into_dart(),
field0.into_into_dart().into_dart()].into_dart() }
crate::api::peer::events::PeerConnectionEvent::ConnectionStateChange(field0) => { [7.into_dart(),
field0.into_into_dart().into_dart()].into_dart() }
crate::api::peer::events::PeerConnectionEvent::Track(field0) => { [8.into_dart(),
field0.into_into_dart().into_dart()].into_dart() }
 _ => { unimplemented!(""); }}
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::peer::events::PeerConnectionEvent
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::api::peer::events::PeerConnectionEvent,
    > for crate::api::peer::events::PeerConnectionEvent
{
    fn into_into_dart(self) -> crate::api::peer::events::PeerConnectionEvent {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::peer::events::peer_connection_state::PeerConnectionState
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::New => 0.into_dart(),
            Self::Connecting => 1.into_dart(),
            Self::Connected => 2.into_dart(),
            Self::Disconnected => 3.into_dart(),
            Self::Failed => 4.into_dart(),
            Self::Closed => 5.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::peer::events::peer_connection_state::PeerConnectionState
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::api::peer::events::peer_connection_state::PeerConnectionState,
    > for crate::api::peer::events::peer_connection_state::PeerConnectionState
{
    fn into_into_dart(
        self,
    ) -> crate::api::peer::events::peer_connection_state::PeerConnectionState
    {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::stats::rtc_ice_candidate_stats::Protocol
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Tcp => 0.into_dart(),
            Self::Udp => 1.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::stats::rtc_ice_candidate_stats::Protocol
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::api::stats::rtc_ice_candidate_stats::Protocol,
    > for crate::api::stats::rtc_ice_candidate_stats::Protocol
{
    fn into_into_dart(
        self,
    ) -> crate::api::stats::rtc_ice_candidate_stats::Protocol {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::peer::rtc_configuration::RtcConfiguration
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.ice_transport_policy.into_into_dart().into_dart(),
            self.bundle_policy.into_into_dart().into_dart(),
            self.ice_servers.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::peer::rtc_configuration::RtcConfiguration
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::api::peer::rtc_configuration::RtcConfiguration,
    > for crate::api::peer::rtc_configuration::RtcConfiguration
{
    fn into_into_dart(
        self,
    ) -> crate::api::peer::rtc_configuration::RtcConfiguration {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::stats::rtc_ice_candidate_stats::RtcIceCandidateStats
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {crate::api::stats::rtc_ice_candidate_stats::RtcIceCandidateStats::Local(field0) => { [0.into_dart(),
field0.into_into_dart().into_dart()].into_dart() }
crate::api::stats::rtc_ice_candidate_stats::RtcIceCandidateStats::Remote(field0) => { [1.into_dart(),
field0.into_into_dart().into_dart()].into_dart() }
 _ => { unimplemented!(""); }}
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::stats::rtc_ice_candidate_stats::RtcIceCandidateStats
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::api::stats::rtc_ice_candidate_stats::RtcIceCandidateStats,
    > for crate::api::stats::rtc_ice_candidate_stats::RtcIceCandidateStats
{
    fn into_into_dart(
        self,
    ) -> crate::api::stats::rtc_ice_candidate_stats::RtcIceCandidateStats {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::peer::rtc_configuration::rtc_ice_server::RtcIceServer
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.urls.into_into_dart().into_dart(),
            self.username.into_into_dart().into_dart(),
            self.credential.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::peer::rtc_configuration::rtc_ice_server::RtcIceServer
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::api::peer::rtc_configuration::rtc_ice_server::RtcIceServer,
    > for crate::api::peer::rtc_configuration::rtc_ice_server::RtcIceServer
{
    fn into_into_dart(
        self,
    ) -> crate::api::peer::rtc_configuration::rtc_ice_server::RtcIceServer {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::stats::rtc_inbound_rtp_stream_media_type::RtcInboundRtpStreamMediaType {
                fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
                    match self {crate::api::stats::rtc_inbound_rtp_stream_media_type::RtcInboundRtpStreamMediaType::Audio{voice_activity_flag,total_samples_received,concealed_samples,silent_concealed_samples,audio_level,total_audio_energy,total_samples_duration} => { [0.into_dart(),
voice_activity_flag.into_into_dart().into_dart(),
total_samples_received.into_into_dart().into_dart(),
concealed_samples.into_into_dart().into_dart(),
silent_concealed_samples.into_into_dart().into_dart(),
audio_level.into_into_dart().into_dart(),
total_audio_energy.into_into_dart().into_dart(),
total_samples_duration.into_into_dart().into_dart()].into_dart() }
crate::api::stats::rtc_inbound_rtp_stream_media_type::RtcInboundRtpStreamMediaType::Video{frames_decoded,key_frames_decoded,frame_width,frame_height,total_inter_frame_delay,frames_per_second,fir_count,pli_count,sli_count,concealment_events,frames_received} => { [1.into_dart(),
frames_decoded.into_into_dart().into_dart(),
key_frames_decoded.into_into_dart().into_dart(),
frame_width.into_into_dart().into_dart(),
frame_height.into_into_dart().into_dart(),
total_inter_frame_delay.into_into_dart().into_dart(),
frames_per_second.into_into_dart().into_dart(),
fir_count.into_into_dart().into_dart(),
pli_count.into_into_dart().into_dart(),
sli_count.into_into_dart().into_dart(),
concealment_events.into_into_dart().into_dart(),
frames_received.into_into_dart().into_dart()].into_dart() }
 _ => { unimplemented!(""); }}
                }
            }
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::stats::rtc_inbound_rtp_stream_media_type::RtcInboundRtpStreamMediaType {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::stats::rtc_inbound_rtp_stream_media_type::RtcInboundRtpStreamMediaType> for crate::api::stats::rtc_inbound_rtp_stream_media_type::RtcInboundRtpStreamMediaType {
            fn into_into_dart(self) -> crate::api::stats::rtc_inbound_rtp_stream_media_type::RtcInboundRtpStreamMediaType {
                self
            }
        }
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::stats::rtc_media_source_stats_media_type::RtcMediaSourceStatsMediaType {
                fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
                    match self {crate::api::stats::rtc_media_source_stats_media_type::RtcMediaSourceStatsMediaType::RtcVideoSourceStats{width,height,frames,frames_per_second} => { [0.into_dart(),
width.into_into_dart().into_dart(),
height.into_into_dart().into_dart(),
frames.into_into_dart().into_dart(),
frames_per_second.into_into_dart().into_dart()].into_dart() }
crate::api::stats::rtc_media_source_stats_media_type::RtcMediaSourceStatsMediaType::RtcAudioSourceStats{audio_level,total_audio_energy,total_samples_duration,echo_return_loss,echo_return_loss_enhancement} => { [1.into_dart(),
audio_level.into_into_dart().into_dart(),
total_audio_energy.into_into_dart().into_dart(),
total_samples_duration.into_into_dart().into_dart(),
echo_return_loss.into_into_dart().into_dart(),
echo_return_loss_enhancement.into_into_dart().into_dart()].into_dart() }
 _ => { unimplemented!(""); }}
                }
            }
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::stats::rtc_media_source_stats_media_type::RtcMediaSourceStatsMediaType {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::stats::rtc_media_source_stats_media_type::RtcMediaSourceStatsMediaType> for crate::api::stats::rtc_media_source_stats_media_type::RtcMediaSourceStatsMediaType {
            fn into_into_dart(self) -> crate::api::stats::rtc_media_source_stats_media_type::RtcMediaSourceStatsMediaType {
                self
            }
        }
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::stats::rtc_outbound_rtp_stream_media_type::RtcOutboundRtpStreamStatsMediaType {
                fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
                    match self {crate::api::stats::rtc_outbound_rtp_stream_media_type::RtcOutboundRtpStreamStatsMediaType::Audio{total_samples_sent,voice_activity_flag} => { [0.into_dart(),
total_samples_sent.into_into_dart().into_dart(),
voice_activity_flag.into_into_dart().into_dart()].into_dart() }
crate::api::stats::rtc_outbound_rtp_stream_media_type::RtcOutboundRtpStreamStatsMediaType::Video{frame_width,frame_height,frames_per_second} => { [1.into_dart(),
frame_width.into_into_dart().into_dart(),
frame_height.into_into_dart().into_dart(),
frames_per_second.into_into_dart().into_dart()].into_dart() }
 _ => { unimplemented!(""); }}
                }
            }
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::stats::rtc_outbound_rtp_stream_media_type::RtcOutboundRtpStreamStatsMediaType {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::stats::rtc_outbound_rtp_stream_media_type::RtcOutboundRtpStreamStatsMediaType> for crate::api::stats::rtc_outbound_rtp_stream_media_type::RtcOutboundRtpStreamStatsMediaType {
            fn into_into_dart(self) -> crate::api::stats::rtc_outbound_rtp_stream_media_type::RtcOutboundRtpStreamStatsMediaType {
                self
            }
        }
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::rtc_rtp_encoding_parameters::RtcRtpEncodingParameters
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.rid.into_into_dart().into_dart(),
            self.active.into_into_dart().into_dart(),
            self.max_bitrate.into_into_dart().into_dart(),
            self.max_framerate.into_into_dart().into_dart(),
            self.scale_resolution_down_by.into_into_dart().into_dart(),
            self.scalability_mode.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::rtc_rtp_encoding_parameters::RtcRtpEncodingParameters
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::api::rtc_rtp_encoding_parameters::RtcRtpEncodingParameters,
    > for crate::api::rtc_rtp_encoding_parameters::RtcRtpEncodingParameters
{
    fn into_into_dart(
        self,
    ) -> crate::api::rtc_rtp_encoding_parameters::RtcRtpEncodingParameters {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::rtc_rtp_send_parameters::RtcRtpSendParameters
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.encodings.into_into_dart().into_dart(),
            self.inner.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::rtc_rtp_send_parameters::RtcRtpSendParameters
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::api::rtc_rtp_send_parameters::RtcRtpSendParameters,
    > for crate::api::rtc_rtp_send_parameters::RtcRtpSendParameters
{
    fn into_into_dart(
        self,
    ) -> crate::api::rtc_rtp_send_parameters::RtcRtpSendParameters {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::transceiver::RtcRtpTransceiver
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.peer.into_into_dart().into_dart(),
            self.transceiver.into_into_dart().into_dart(),
            self.mid.into_into_dart().into_dart(),
            self.direction.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::transceiver::RtcRtpTransceiver
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::api::transceiver::RtcRtpTransceiver,
    > for crate::api::transceiver::RtcRtpTransceiver
{
    fn into_into_dart(self) -> crate::api::transceiver::RtcRtpTransceiver {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::peer::rtc_session_description::RtcSessionDescription
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.sdp.into_into_dart().into_dart(),
            self.kind.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::peer::rtc_session_description::RtcSessionDescription
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::api::peer::rtc_session_description::RtcSessionDescription,
    > for crate::api::peer::rtc_session_description::RtcSessionDescription
{
    fn into_into_dart(
        self,
    ) -> crate::api::peer::rtc_session_description::RtcSessionDescription {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::stats::RtcStats {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.timestamp_us.into_into_dart().into_dart(),
            self.kind.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::stats::RtcStats
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::stats::RtcStats>
    for crate::api::stats::RtcStats
{
    fn into_into_dart(self) -> crate::api::stats::RtcStats {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::stats::rtc_stats_ice_candidate_pair_state::RtcStatsIceCandidatePairState {
                fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
                    match self {
                    Self::Frozen => 0.into_dart(),
Self::Waiting => 1.into_dart(),
Self::InProgress => 2.into_dart(),
Self::Failed => 3.into_dart(),
Self::Succeeded => 4.into_dart(),
                    _ => unreachable!(),
                }
                }
            }
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::stats::rtc_stats_ice_candidate_pair_state::RtcStatsIceCandidatePairState {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::stats::rtc_stats_ice_candidate_pair_state::RtcStatsIceCandidatePairState> for crate::api::stats::rtc_stats_ice_candidate_pair_state::RtcStatsIceCandidatePairState {
            fn into_into_dart(self) -> crate::api::stats::rtc_stats_ice_candidate_pair_state::RtcStatsIceCandidatePairState {
                self
            }
        }
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::stats::RtcStatsType {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {crate::api::stats::RtcStatsType::RtcMediaSourceStats{track_identifier,kind} => { [0.into_dart(),
track_identifier.into_into_dart().into_dart(),
kind.into_into_dart().into_dart()].into_dart() }
crate::api::stats::RtcStatsType::RtcIceCandidateStats(field0) => { [1.into_dart(),
field0.into_into_dart().into_dart()].into_dart() }
crate::api::stats::RtcStatsType::RtcOutboundRtpStreamStats{track_id,media_type,bytes_sent,packets_sent,media_source_id} => { [2.into_dart(),
track_id.into_into_dart().into_dart(),
media_type.into_into_dart().into_dart(),
bytes_sent.into_into_dart().into_dart(),
packets_sent.into_into_dart().into_dart(),
media_source_id.into_into_dart().into_dart()].into_dart() }
crate::api::stats::RtcStatsType::RtcInboundRtpStreamStats{remote_id,bytes_received,packets_received,packets_lost,jitter,total_decode_time,jitter_buffer_emitted_count,media_type} => { [3.into_dart(),
remote_id.into_into_dart().into_dart(),
bytes_received.into_into_dart().into_dart(),
packets_received.into_into_dart().into_dart(),
packets_lost.into_into_dart().into_dart(),
jitter.into_into_dart().into_dart(),
total_decode_time.into_into_dart().into_dart(),
jitter_buffer_emitted_count.into_into_dart().into_dart(),
media_type.into_into_dart().into_dart()].into_dart() }
crate::api::stats::RtcStatsType::RtcIceCandidatePairStats{state,nominated,bytes_sent,bytes_received,total_round_trip_time,current_round_trip_time,available_outgoing_bitrate} => { [4.into_dart(),
state.into_into_dart().into_dart(),
nominated.into_into_dart().into_dart(),
bytes_sent.into_into_dart().into_dart(),
bytes_received.into_into_dart().into_dart(),
total_round_trip_time.into_into_dart().into_dart(),
current_round_trip_time.into_into_dart().into_dart(),
available_outgoing_bitrate.into_into_dart().into_dart()].into_dart() }
crate::api::stats::RtcStatsType::RtcTransportStats{packets_sent,packets_received,bytes_sent,bytes_received,ice_role} => { [5.into_dart(),
packets_sent.into_into_dart().into_dart(),
packets_received.into_into_dart().into_dart(),
bytes_sent.into_into_dart().into_dart(),
bytes_received.into_into_dart().into_dart(),
ice_role.into_into_dart().into_dart()].into_dart() }
crate::api::stats::RtcStatsType::RtcRemoteInboundRtpStreamStats{local_id,jitter,round_trip_time,fraction_lost,reports_received,round_trip_time_measurements} => { [6.into_dart(),
local_id.into_into_dart().into_dart(),
jitter.into_into_dart().into_dart(),
round_trip_time.into_into_dart().into_dart(),
fraction_lost.into_into_dart().into_dart(),
reports_received.into_into_dart().into_dart(),
round_trip_time_measurements.into_into_dart().into_dart()].into_dart() }
crate::api::stats::RtcStatsType::RtcRemoteOutboundRtpStreamStats{local_id,remote_timestamp,reports_sent} => { [7.into_dart(),
local_id.into_into_dart().into_dart(),
remote_timestamp.into_into_dart().into_dart(),
reports_sent.into_into_dart().into_dart()].into_dart() }
crate::api::stats::RtcStatsType::Unimplemented => { [8.into_dart()].into_dart() }
 _ => { unimplemented!(""); }}
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::stats::RtcStatsType
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::stats::RtcStatsType>
    for crate::api::stats::RtcStatsType
{
    fn into_into_dart(self) -> crate::api::stats::RtcStatsType {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::peer::events::rtc_track_event::RtcTrackEvent
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.track.into_into_dart().into_dart(),
            self.transceiver.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::peer::events::rtc_track_event::RtcTrackEvent
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::api::peer::events::rtc_track_event::RtcTrackEvent,
    > for crate::api::peer::events::rtc_track_event::RtcTrackEvent
{
    fn into_into_dart(
        self,
    ) -> crate::api::peer::events::rtc_track_event::RtcTrackEvent {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::capability::rtp_codec::rtcp_feedback::RtcpFeedback
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.message_type.into_into_dart().into_dart(),
            self.kind.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::capability::rtp_codec::rtcp_feedback::RtcpFeedback
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::api::capability::rtp_codec::rtcp_feedback::RtcpFeedback,
    > for crate::api::capability::rtp_codec::rtcp_feedback::RtcpFeedback
{
    fn into_into_dart(
        self,
    ) -> crate::api::capability::rtp_codec::rtcp_feedback::RtcpFeedback {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::capability::rtp_codec::rtcp_feedback::RtcpFeedbackMessageType {
                fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
                    match self {
                    Self::GenericNACK => 0.into_dart(),
Self::Pli => 1.into_dart(),
Self::Fir => 2.into_dart(),
                    _ => unreachable!(),
                }
                }
            }
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::capability::rtp_codec::rtcp_feedback::RtcpFeedbackMessageType {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::capability::rtp_codec::rtcp_feedback::RtcpFeedbackMessageType> for crate::api::capability::rtp_codec::rtcp_feedback::RtcpFeedbackMessageType {
            fn into_into_dart(self) -> crate::api::capability::rtp_codec::rtcp_feedback::RtcpFeedbackMessageType {
                self
            }
        }
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::capability::rtp_codec::rtcp_feedback::RtcpFeedbackType
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Ccm => 0.into_dart(),
            Self::Lntf => 1.into_dart(),
            Self::Nack => 2.into_dart(),
            Self::Remb => 3.into_dart(),
            Self::TransportCC => 4.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::capability::rtp_codec::rtcp_feedback::RtcpFeedbackType
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::api::capability::rtp_codec::rtcp_feedback::RtcpFeedbackType,
    > for crate::api::capability::rtp_codec::rtcp_feedback::RtcpFeedbackType
{
    fn into_into_dart(
        self,
    ) -> crate::api::capability::rtp_codec::rtcp_feedback::RtcpFeedbackType
    {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::capability::RtpCapabilities {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.codecs.into_into_dart().into_dart(),
            self.header_extensions.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::capability::RtpCapabilities
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::capability::RtpCapabilities>
    for crate::api::capability::RtpCapabilities
{
    fn into_into_dart(self) -> crate::api::capability::RtpCapabilities {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::capability::rtp_codec::RtpCodecCapability
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.preferred_payload_type.into_into_dart().into_dart(),
            self.scalability_modes.into_into_dart().into_dart(),
            self.mime_type.into_into_dart().into_dart(),
            self.name.into_into_dart().into_dart(),
            self.kind.into_into_dart().into_dart(),
            self.clock_rate.into_into_dart().into_dart(),
            self.num_channels.into_into_dart().into_dart(),
            self.parameters.into_into_dart().into_dart(),
            self.feedback.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::capability::rtp_codec::RtpCodecCapability
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::api::capability::rtp_codec::RtpCodecCapability,
    > for crate::api::capability::rtp_codec::RtpCodecCapability
{
    fn into_into_dart(
        self,
    ) -> crate::api::capability::rtp_codec::RtpCodecCapability {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::capability::rtp_header_extension_capability::RtpHeaderExtensionCapability {
                fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
                    [
                    self.uri.into_into_dart().into_dart(),
self.preferred_id.into_into_dart().into_dart(),
self.preferred_encrypted.into_into_dart().into_dart(),
self.direction.into_into_dart().into_dart()
                ].into_dart()
                }
            }
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::capability::rtp_header_extension_capability::RtpHeaderExtensionCapability {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::capability::rtp_header_extension_capability::RtpHeaderExtensionCapability> for crate::api::capability::rtp_header_extension_capability::RtpHeaderExtensionCapability {
            fn into_into_dart(self) -> crate::api::capability::rtp_header_extension_capability::RtpHeaderExtensionCapability {
                self
            }
        }
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::transceiver::direction::RtpTransceiverDirection
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::SendRecv => 0.into_dart(),
            Self::SendOnly => 1.into_dart(),
            Self::RecvOnly => 2.into_dart(),
            Self::Inactive => 3.into_dart(),
            Self::Stopped => 4.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::transceiver::direction::RtpTransceiverDirection
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::api::transceiver::direction::RtpTransceiverDirection,
    > for crate::api::transceiver::direction::RtpTransceiverDirection
{
    fn into_into_dart(
        self,
    ) -> crate::api::transceiver::direction::RtpTransceiverDirection {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::transceiver::init::RtpTransceiverInit
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.direction.into_into_dart().into_dart(),
            self.send_encodings.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::transceiver::init::RtpTransceiverInit
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::api::transceiver::init::RtpTransceiverInit,
    > for crate::api::transceiver::init::RtpTransceiverInit
{
    fn into_into_dart(
        self,
    ) -> crate::api::transceiver::init::RtpTransceiverInit {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::L1T1 => 0.into_dart(),
            Self::L1T2 => 1.into_dart(),
            Self::L1T3 => 2.into_dart(),
            Self::L2T1 => 3.into_dart(),
            Self::L2T1h => 4.into_dart(),
            Self::L2t1Key => 5.into_dart(),
            Self::L2T2 => 6.into_dart(),
            Self::L2T2h => 7.into_dart(),
            Self::L2T2Key => 8.into_dart(),
            Self::L2T2KeyShift => 9.into_dart(),
            Self::L2T3 => 10.into_dart(),
            Self::L2T3h => 11.into_dart(),
            Self::L2T3Key => 12.into_dart(),
            Self::L3T1 => 13.into_dart(),
            Self::L3T1h => 14.into_dart(),
            Self::L3T1Key => 15.into_dart(),
            Self::L3T2 => 16.into_dart(),
            Self::L3T2h => 17.into_dart(),
            Self::L3T2Key => 18.into_dart(),
            Self::L3T3 => 19.into_dart(),
            Self::L3T3h => 20.into_dart(),
            Self::L3T3Key => 21.into_dart(),
            Self::S2T1 => 22.into_dart(),
            Self::S2T1h => 23.into_dart(),
            Self::S2T2 => 24.into_dart(),
            Self::S2T2h => 25.into_dart(),
            Self::S2T3 => 26.into_dart(),
            Self::S2T3h => 27.into_dart(),
            Self::S3T1 => 28.into_dart(),
            Self::S3T1h => 29.into_dart(),
            Self::S3T2 => 30.into_dart(),
            Self::S3T2h => 31.into_dart(),
            Self::S3T3 => 32.into_dart(),
            Self::S3T3h => 33.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode,
    > for crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode
{
    fn into_into_dart(
        self,
    ) -> crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode
    {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::peer::rtc_session_description::SdpType
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Offer => 0.into_dart(),
            Self::PrAnswer => 1.into_dart(),
            Self::Answer => 2.into_dart(),
            Self::Rollback => 3.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::peer::rtc_session_description::SdpType
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::api::peer::rtc_session_description::SdpType,
    > for crate::api::peer::rtc_session_description::SdpType
{
    fn into_into_dart(
        self,
    ) -> crate::api::peer::rtc_session_description::SdpType {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::peer::events::signaling_state::SignalingState
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Stable => 0.into_dart(),
            Self::HaveLocalOffer => 1.into_dart(),
            Self::HaveLocalPrAnswer => 2.into_dart(),
            Self::HaveRemoteOffer => 3.into_dart(),
            Self::HaveRemotePrAnswer => 4.into_dart(),
            Self::Closed => 5.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::peer::events::signaling_state::SignalingState
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::api::peer::events::signaling_state::SignalingState,
    > for crate::api::peer::events::signaling_state::SignalingState
{
    fn into_into_dart(
        self,
    ) -> crate::api::peer::events::signaling_state::SignalingState {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::renderer::TextureEvent {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::renderer::TextureEvent::OnTextureChange {
                texture_id,
                width,
                height,
                rotation,
            } => [
                0.into_dart(),
                texture_id.into_into_dart().into_dart(),
                width.into_into_dart().into_dart(),
                height.into_into_dart().into_dart(),
                rotation.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::renderer::TextureEvent::OnFirstFrameRendered {
                texture_id,
            } => [1.into_dart(), texture_id.into_into_dart().into_dart()]
                .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::renderer::TextureEvent
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::renderer::TextureEvent>
    for crate::renderer::TextureEvent
{
    fn into_into_dart(self) -> crate::renderer::TextureEvent {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::media_stream_track::track_event::TrackEvent
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {crate::api::media_stream_track::track_event::TrackEvent::Ended => { [0.into_dart()].into_dart() }
crate::api::media_stream_track::track_event::TrackEvent::AudioLevelUpdated(field0) => { [1.into_dart(),
field0.into_into_dart().into_dart()].into_dart() }
crate::api::media_stream_track::track_event::TrackEvent::TrackCreated => { [2.into_dart()].into_dart() }
 _ => { unimplemented!(""); }}
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::media_stream_track::track_event::TrackEvent
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::api::media_stream_track::track_event::TrackEvent,
    > for crate::api::media_stream_track::track_event::TrackEvent
{
    fn into_into_dart(
        self,
    ) -> crate::api::media_stream_track::track_event::TrackEvent {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::media_stream_track::track_state::TrackState
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Live => 0.into_dart(),
            Self::Ended => 1.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::media_stream_track::track_state::TrackState
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::api::media_stream_track::track_state::TrackState,
    > for crate::api::media_stream_track::track_state::TrackState
{
    fn into_into_dart(
        self,
    ) -> crate::api::media_stream_track::track_state::TrackState {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::peer::video_codec_info::VideoCodec
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::AV1 => 0.into_dart(),
            Self::H264 => 1.into_dart(),
            Self::H265 => 2.into_dart(),
            Self::VP8 => 3.into_dart(),
            Self::VP9 => 4.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::peer::video_codec_info::VideoCodec
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::api::peer::video_codec_info::VideoCodec,
    > for crate::api::peer::video_codec_info::VideoCodec
{
    fn into_into_dart(self) -> crate::api::peer::video_codec_info::VideoCodec {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::peer::video_codec_info::VideoCodecInfo
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.is_hardware_accelerated.into_into_dart().into_dart(),
            self.codec.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::peer::video_codec_info::VideoCodecInfo
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::api::peer::video_codec_info::VideoCodecInfo,
    > for crate::api::peer::video_codec_info::VideoCodecInfo
{
    fn into_into_dart(
        self,
    ) -> crate::api::peer::video_codec_info::VideoCodecInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::media::constraints::video::VideoConstraints
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.device_id.into_into_dart().into_dart(),
            self.width.into_into_dart().into_dart(),
            self.height.into_into_dart().into_dart(),
            self.frame_rate.into_into_dart().into_dart(),
            self.is_display.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::media::constraints::video::VideoConstraints
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::api::media::constraints::video::VideoConstraints,
    > for crate::api::media::constraints::video::VideoConstraints
{
    fn into_into_dart(
        self,
    ) -> crate::api::media::constraints::video::VideoConstraints {
        self
    }
}

impl SseEncode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <String>::sse_encode(format!("{:?}", self), serializer);
    }
}

impl SseEncode for RustOpaqueMoi<Arc<PeerConnection>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueMoi<Arc<RtpEncodingParameters>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueMoi<Arc<RtpParameters>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueMoi<Arc<RtpTransceiver>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for StreamSink<
        crate::api::peer::events::PeerConnectionEvent,
        flutter_rust_bridge::for_generated::SseCodec,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        unimplemented!("")
    }
}

impl SseEncode
    for StreamSink<
        crate::renderer::TextureEvent,
        flutter_rust_bridge::for_generated::SseCodec,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        unimplemented!("")
    }
}

impl SseEncode
    for StreamSink<
        crate::api::media_stream_track::track_event::TrackEvent,
        flutter_rust_bridge::for_generated::SseCodec,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        unimplemented!("")
    }
}

impl SseEncode
    for StreamSink<(), flutter_rust_bridge::for_generated::SseCodec>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        unimplemented!("")
    }
}

impl SseEncode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <Vec<u8>>::sse_encode(self.into_bytes(), serializer);
    }
}

impl SseEncode for crate::api::media::constraints::audio::AudioConstraints {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <Option<String>>::sse_encode(self.device_id, serializer);
        <crate::api::media::constraints::audio::AudioProcessingConstraints>::sse_encode(self.processing, serializer);
    }
}

impl SseEncode for crate::api::media_stream_track::audio_processing_config::AudioProcessingConfig {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {<bool>::sse_encode(self.auto_gain_control, serializer);
<bool>::sse_encode(self.high_pass_filter, serializer);
<bool>::sse_encode(self.noise_suppression, serializer);
<crate::api::media_stream_track::audio_processing_config::NoiseSuppressionLevel>::sse_encode(self.noise_suppression_level, serializer);
<bool>::sse_encode(self.echo_cancellation, serializer);}
                }

impl SseEncode
    for crate::api::media::constraints::audio::AudioProcessingConstraints
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <Option<bool>>::sse_encode(self.auto_gain_control, serializer);
        <Option<bool>>::sse_encode(self.high_pass_filter, serializer);
        <Option<bool>>::sse_encode(self.noise_suppression, serializer);
        <Option<crate::api::media_stream_track::audio_processing_config::NoiseSuppressionLevel>>::sse_encode(self.noise_suppression_level, serializer);
        <Option<bool>>::sse_encode(self.echo_cancellation, serializer);
    }
}

impl SseEncode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        serializer.cursor.write_u8(self as _).unwrap();
    }
}

impl SseEncode
    for crate::api::peer::rtc_configuration::bundle_policy::BundlePolicy
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(match self {crate::api::peer::rtc_configuration::bundle_policy::BundlePolicy::Balanced => { 0 }
crate::api::peer::rtc_configuration::bundle_policy::BundlePolicy::MaxBundle => { 1 }
crate::api::peer::rtc_configuration::bundle_policy::BundlePolicy::MaxCompat => { 2 }
 _ => { unimplemented!(""); }}, serializer);
    }
}

impl SseEncode for crate::api::stats::rtc_ice_candidate_stats::CandidateType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(match self {crate::api::stats::rtc_ice_candidate_stats::CandidateType::Host => { 0 }
crate::api::stats::rtc_ice_candidate_stats::CandidateType::Srflx => { 1 }
crate::api::stats::rtc_ice_candidate_stats::CandidateType::Prflx => { 2 }
crate::api::stats::rtc_ice_candidate_stats::CandidateType::Relay => { 3 }
 _ => { unimplemented!(""); }}, serializer);
    }
}

impl SseEncode for f64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        serializer.cursor.write_f64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for crate::api::media_stream_track::GetMediaError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        match self {
            crate::api::media_stream_track::GetMediaError::Audio(field0) => {
                <i32>::sse_encode(0, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::api::media_stream_track::GetMediaError::Video(field0) => {
                <i32>::sse_encode(1, serializer);
                <String>::sse_encode(field0, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::media_stream_track::GetMediaResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        match self {
            crate::api::media_stream_track::GetMediaResult::Ok(field0) => {
                <i32>::sse_encode(0, serializer);
                <Vec<crate::api::media_stream_track::MediaStreamTrack>>::sse_encode(field0, serializer);
            }
            crate::api::media_stream_track::GetMediaResult::Err(field0) => {
                <i32>::sse_encode(1, serializer);
                <crate::api::media_stream_track::GetMediaError>::sse_encode(
                    field0, serializer,
                );
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        serializer.cursor.write_i32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for i64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        serializer.cursor.write_i64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode
    for crate::api::stats::rtc_ice_candidate_stats::IceCandidateStats
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <Option<String>>::sse_encode(self.transport_id, serializer);
        <Option<String>>::sse_encode(self.address, serializer);
        <Option<i32>>::sse_encode(self.port, serializer);
        <crate::api::stats::rtc_ice_candidate_stats::Protocol>::sse_encode(
            self.protocol,
            serializer,
        );
        <crate::api::stats::rtc_ice_candidate_stats::CandidateType>::sse_encode(
            self.candidate_type,
            serializer,
        );
        <Option<i32>>::sse_encode(self.priority, serializer);
        <Option<String>>::sse_encode(self.url, serializer);
        <Option<crate::api::stats::rtc_ice_candidate_stats::Protocol>>::sse_encode(self.relay_protocol, serializer);
    }
}

impl SseEncode
    for crate::api::peer::events::ice_connection_state::IceConnectionState
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(match self {crate::api::peer::events::ice_connection_state::IceConnectionState::New => { 0 }
crate::api::peer::events::ice_connection_state::IceConnectionState::Checking => { 1 }
crate::api::peer::events::ice_connection_state::IceConnectionState::Connected => { 2 }
crate::api::peer::events::ice_connection_state::IceConnectionState::Completed => { 3 }
crate::api::peer::events::ice_connection_state::IceConnectionState::Failed => { 4 }
crate::api::peer::events::ice_connection_state::IceConnectionState::Disconnected => { 5 }
crate::api::peer::events::ice_connection_state::IceConnectionState::Closed => { 6 }
 _ => { unimplemented!(""); }}, serializer);
    }
}

impl SseEncode
    for crate::api::peer::events::ice_gathering_state::IceGatheringState
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(match self {crate::api::peer::events::ice_gathering_state::IceGatheringState::New => { 0 }
crate::api::peer::events::ice_gathering_state::IceGatheringState::Gathering => { 1 }
crate::api::peer::events::ice_gathering_state::IceGatheringState::Complete => { 2 }
 _ => { unimplemented!(""); }}, serializer);
    }
}

impl SseEncode for crate::api::stats::ice_role::IceRole {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(
            match self {
                crate::api::stats::ice_role::IceRole::Unknown => 0,
                crate::api::stats::ice_role::IceRole::Controlling => 1,
                crate::api::stats::ice_role::IceRole::Controlled => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::peer::rtc_configuration::ice_transports_type::IceTransportsType {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {<i32>::sse_encode(match self {crate::api::peer::rtc_configuration::ice_transports_type::IceTransportsType::All => { 0 }
crate::api::peer::rtc_configuration::ice_transports_type::IceTransportsType::Relay => { 1 }
crate::api::peer::rtc_configuration::ice_transports_type::IceTransportsType::NoHost => { 2 }
crate::api::peer::rtc_configuration::ice_transports_type::IceTransportsType::None => { 3 }
 _ => { unimplemented!(""); }}, serializer);}
                }

impl SseEncode for Vec<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <String>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::media_info::MediaDeviceInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::media_info::MediaDeviceInfo>::sse_encode(
                item, serializer,
            );
        }
    }
}

impl SseEncode for Vec<crate::api::media_info::MediaDisplayInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::media_info::MediaDisplayInfo>::sse_encode(
                item, serializer,
            );
        }
    }
}

impl SseEncode for Vec<crate::api::media_stream_track::MediaStreamTrack> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::media_stream_track::MediaStreamTrack>::sse_encode(
                item, serializer,
            );
        }
    }
}

impl SseEncode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u8>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode
    for Vec<(
        crate::api::rtc_rtp_encoding_parameters::RtcRtpEncodingParameters,
        RustOpaqueMoi<Arc<RtpEncodingParameters>>,
    )>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(crate::api::rtc_rtp_encoding_parameters::RtcRtpEncodingParameters,RustOpaqueMoi<Arc < RtpEncodingParameters >>,)>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<(String, String)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(String, String)>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode
    for Vec<crate::api::peer::rtc_configuration::rtc_ice_server::RtcIceServer>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::peer::rtc_configuration::rtc_ice_server::RtcIceServer>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode
    for Vec<crate::api::rtc_rtp_encoding_parameters::RtcRtpEncodingParameters>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::rtc_rtp_encoding_parameters::RtcRtpEncodingParameters>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::transceiver::RtcRtpTransceiver> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::transceiver::RtcRtpTransceiver>::sse_encode(
                item, serializer,
            );
        }
    }
}

impl SseEncode for Vec<crate::api::stats::RtcStats> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::stats::RtcStats>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode
    for Vec<crate::api::capability::rtp_codec::rtcp_feedback::RtcpFeedback>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::capability::rtp_codec::rtcp_feedback::RtcpFeedback>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::capability::rtp_codec::RtpCodecCapability> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::capability::rtp_codec::RtpCodecCapability>::sse_encode(
                item, serializer,
            );
        }
    }
}

impl SseEncode for Vec<crate::api::capability::rtp_header_extension_capability::RtpHeaderExtensionCapability> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {<i32>::sse_encode(self.len() as _, serializer);
        for item in self { <crate::api::capability::rtp_header_extension_capability::RtpHeaderExtensionCapability>::sse_encode(item, serializer); }}
                }

impl SseEncode
    for Vec<
        crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::peer::video_codec_info::VideoCodecInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::peer::video_codec_info::VideoCodecInfo>::sse_encode(
                item, serializer,
            );
        }
    }
}

impl SseEncode for crate::api::media_info::MediaDeviceInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <String>::sse_encode(self.device_id, serializer);
        <crate::api::media_info::MediaDeviceKind>::sse_encode(
            self.kind, serializer,
        );
        <String>::sse_encode(self.label, serializer);
    }
}

impl SseEncode for crate::api::media_info::MediaDeviceKind {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(
            match self {
                crate::api::media_info::MediaDeviceKind::AudioInput => 0,
                crate::api::media_info::MediaDeviceKind::AudioOutput => 1,
                crate::api::media_info::MediaDeviceKind::VideoInput => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::media_info::MediaDisplayInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <String>::sse_encode(self.device_id, serializer);
        <Option<String>>::sse_encode(self.title, serializer);
    }
}

impl SseEncode for crate::api::media::constraints::MediaStreamConstraints {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <Option<crate::api::media::constraints::audio::AudioConstraints>>::sse_encode(self.audio, serializer);
        <Option<crate::api::media::constraints::video::VideoConstraints>>::sse_encode(self.video, serializer);
    }
}

impl SseEncode for crate::api::media_stream_track::MediaStreamTrack {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <String>::sse_encode(self.id, serializer);
        <Option<u32>>::sse_encode(self.peer_id, serializer);
        <String>::sse_encode(self.device_id, serializer);
        <crate::api::media_stream_track::media_type::MediaType>::sse_encode(
            self.kind, serializer,
        );
        <bool>::sse_encode(self.enabled, serializer);
    }
}

impl SseEncode for crate::api::media_stream_track::media_type::MediaType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(match self {crate::api::media_stream_track::media_type::MediaType::Audio => { 0 }
crate::api::media_stream_track::media_type::MediaType::Video => { 1 }
 _ => { unimplemented!(""); }}, serializer);
    }
}

impl SseEncode for crate::api::media_stream_track::audio_processing_config::NoiseSuppressionLevel {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {<i32>::sse_encode(match self {crate::api::media_stream_track::audio_processing_config::NoiseSuppressionLevel::Low => { 0 }
crate::api::media_stream_track::audio_processing_config::NoiseSuppressionLevel::Moderate => { 1 }
crate::api::media_stream_track::audio_processing_config::NoiseSuppressionLevel::High => { 2 }
crate::api::media_stream_track::audio_processing_config::NoiseSuppressionLevel::VeryHigh => { 3 }
 _ => { unimplemented!(""); }}, serializer);}
                }

impl SseEncode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <String>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode
    for Option<crate::api::media::constraints::audio::AudioConstraints>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::media::constraints::audio::AudioConstraints>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<bool> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <bool>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<f64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <f64>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<i32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <i32>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::stats::ice_role::IceRole> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::stats::ice_role::IceRole>::sse_encode(
                value, serializer,
            );
        }
    }
}

impl SseEncode for Option<crate::api::media_stream_track::MediaStreamTrack> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::media_stream_track::MediaStreamTrack>::sse_encode(
                value, serializer,
            );
        }
    }
}

impl SseEncode for Option<crate::api::media_stream_track::audio_processing_config::NoiseSuppressionLevel> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {<bool>::sse_encode(self.is_some(), serializer);
                if let Some(value) = self {
                    <crate::api::media_stream_track::audio_processing_config::NoiseSuppressionLevel>::sse_encode(value, serializer);
                }}
                }

impl SseEncode
    for Option<crate::api::stats::rtc_ice_candidate_stats::Protocol>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::stats::rtc_ice_candidate_stats::Protocol>::sse_encode(
                value, serializer,
            );
        }
    }
}

impl SseEncode for Option<crate::api::stats::rtc_inbound_rtp_stream_media_type::RtcInboundRtpStreamMediaType> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {<bool>::sse_encode(self.is_some(), serializer);
                if let Some(value) = self {
                    <crate::api::stats::rtc_inbound_rtp_stream_media_type::RtcInboundRtpStreamMediaType>::sse_encode(value, serializer);
                }}
                }

impl SseEncode for Option<crate::api::capability::rtp_codec::rtcp_feedback::RtcpFeedbackMessageType> {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {<bool>::sse_encode(self.is_some(), serializer);
                if let Some(value) = self {
                    <crate::api::capability::rtp_codec::rtcp_feedback::RtcpFeedbackMessageType>::sse_encode(value, serializer);
                }}
                }

impl SseEncode for Option<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u32>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u64>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode
    for Option<crate::api::media::constraints::video::VideoConstraints>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::media::constraints::video::VideoConstraints>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for crate::api::peer::events::PeerConnectionEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        match self {crate::api::peer::events::PeerConnectionEvent::PeerCreated{peer} => { <i32>::sse_encode(0, serializer); <RustOpaqueMoi<Arc < PeerConnection >>>::sse_encode(peer, serializer);
 }
crate::api::peer::events::PeerConnectionEvent::IceCandidate{sdp_mid,sdp_mline_index,candidate} => { <i32>::sse_encode(1, serializer); <String>::sse_encode(sdp_mid, serializer);
<i32>::sse_encode(sdp_mline_index, serializer);
<String>::sse_encode(candidate, serializer);
 }
crate::api::peer::events::PeerConnectionEvent::IceGatheringStateChange(field0) => { <i32>::sse_encode(2, serializer); <crate::api::peer::events::ice_gathering_state::IceGatheringState>::sse_encode(field0, serializer);
 }
crate::api::peer::events::PeerConnectionEvent::IceCandidateError{address,port,url,error_code,error_text} => { <i32>::sse_encode(3, serializer); <String>::sse_encode(address, serializer);
<i32>::sse_encode(port, serializer);
<String>::sse_encode(url, serializer);
<i32>::sse_encode(error_code, serializer);
<String>::sse_encode(error_text, serializer);
 }
crate::api::peer::events::PeerConnectionEvent::NegotiationNeeded => { <i32>::sse_encode(4, serializer);  }
crate::api::peer::events::PeerConnectionEvent::SignallingChange(field0) => { <i32>::sse_encode(5, serializer); <crate::api::peer::events::signaling_state::SignalingState>::sse_encode(field0, serializer);
 }
crate::api::peer::events::PeerConnectionEvent::IceConnectionStateChange(field0) => { <i32>::sse_encode(6, serializer); <crate::api::peer::events::ice_connection_state::IceConnectionState>::sse_encode(field0, serializer);
 }
crate::api::peer::events::PeerConnectionEvent::ConnectionStateChange(field0) => { <i32>::sse_encode(7, serializer); <crate::api::peer::events::peer_connection_state::PeerConnectionState>::sse_encode(field0, serializer);
 }
crate::api::peer::events::PeerConnectionEvent::Track(field0) => { <i32>::sse_encode(8, serializer); <crate::api::peer::events::rtc_track_event::RtcTrackEvent>::sse_encode(field0, serializer);
 }
 _ => { unimplemented!(""); }}
    }
}

impl SseEncode
    for crate::api::peer::events::peer_connection_state::PeerConnectionState
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(match self {crate::api::peer::events::peer_connection_state::PeerConnectionState::New => { 0 }
crate::api::peer::events::peer_connection_state::PeerConnectionState::Connecting => { 1 }
crate::api::peer::events::peer_connection_state::PeerConnectionState::Connected => { 2 }
crate::api::peer::events::peer_connection_state::PeerConnectionState::Disconnected => { 3 }
crate::api::peer::events::peer_connection_state::PeerConnectionState::Failed => { 4 }
crate::api::peer::events::peer_connection_state::PeerConnectionState::Closed => { 5 }
 _ => { unimplemented!(""); }}, serializer);
    }
}

impl SseEncode for crate::api::stats::rtc_ice_candidate_stats::Protocol {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(
            match self {
                crate::api::stats::rtc_ice_candidate_stats::Protocol::Tcp => 0,
                crate::api::stats::rtc_ice_candidate_stats::Protocol::Udp => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode
    for (
        crate::api::rtc_rtp_encoding_parameters::RtcRtpEncodingParameters,
        RustOpaqueMoi<Arc<RtpEncodingParameters>>,
    )
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <crate::api::rtc_rtp_encoding_parameters::RtcRtpEncodingParameters>::sse_encode(self.0, serializer);
        <RustOpaqueMoi<Arc<RtpEncodingParameters>>>::sse_encode(
            self.1, serializer,
        );
    }
}

impl SseEncode for (String, String) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <String>::sse_encode(self.0, serializer);
        <String>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for crate::api::peer::rtc_configuration::RtcConfiguration {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <crate::api::peer::rtc_configuration::ice_transports_type::IceTransportsType>::sse_encode(self.ice_transport_policy, serializer);
        <crate::api::peer::rtc_configuration::bundle_policy::BundlePolicy>::sse_encode(self.bundle_policy, serializer);
        <Vec<crate::api::peer::rtc_configuration::rtc_ice_server::RtcIceServer>>::sse_encode(self.ice_servers, serializer);
    }
}

impl SseEncode
    for crate::api::stats::rtc_ice_candidate_stats::RtcIceCandidateStats
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        match self {crate::api::stats::rtc_ice_candidate_stats::RtcIceCandidateStats::Local(field0) => { <i32>::sse_encode(0, serializer); <crate::api::stats::rtc_ice_candidate_stats::IceCandidateStats>::sse_encode(field0, serializer);
 }
crate::api::stats::rtc_ice_candidate_stats::RtcIceCandidateStats::Remote(field0) => { <i32>::sse_encode(1, serializer); <crate::api::stats::rtc_ice_candidate_stats::IceCandidateStats>::sse_encode(field0, serializer);
 }
 _ => { unimplemented!(""); }}
    }
}

impl SseEncode
    for crate::api::peer::rtc_configuration::rtc_ice_server::RtcIceServer
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <Vec<String>>::sse_encode(self.urls, serializer);
        <String>::sse_encode(self.username, serializer);
        <String>::sse_encode(self.credential, serializer);
    }
}

impl SseEncode for crate::api::stats::rtc_inbound_rtp_stream_media_type::RtcInboundRtpStreamMediaType {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {match self {crate::api::stats::rtc_inbound_rtp_stream_media_type::RtcInboundRtpStreamMediaType::Audio{voice_activity_flag,total_samples_received,concealed_samples,silent_concealed_samples,audio_level,total_audio_energy,total_samples_duration} => { <i32>::sse_encode(0, serializer); <Option<bool>>::sse_encode(voice_activity_flag, serializer);
<Option<u64>>::sse_encode(total_samples_received, serializer);
<Option<u64>>::sse_encode(concealed_samples, serializer);
<Option<u64>>::sse_encode(silent_concealed_samples, serializer);
<Option<f64>>::sse_encode(audio_level, serializer);
<Option<f64>>::sse_encode(total_audio_energy, serializer);
<Option<f64>>::sse_encode(total_samples_duration, serializer);
 }
crate::api::stats::rtc_inbound_rtp_stream_media_type::RtcInboundRtpStreamMediaType::Video{frames_decoded,key_frames_decoded,frame_width,frame_height,total_inter_frame_delay,frames_per_second,fir_count,pli_count,sli_count,concealment_events,frames_received} => { <i32>::sse_encode(1, serializer); <Option<u32>>::sse_encode(frames_decoded, serializer);
<Option<u32>>::sse_encode(key_frames_decoded, serializer);
<Option<u32>>::sse_encode(frame_width, serializer);
<Option<u32>>::sse_encode(frame_height, serializer);
<Option<f64>>::sse_encode(total_inter_frame_delay, serializer);
<Option<f64>>::sse_encode(frames_per_second, serializer);
<Option<u32>>::sse_encode(fir_count, serializer);
<Option<u32>>::sse_encode(pli_count, serializer);
<Option<u32>>::sse_encode(sli_count, serializer);
<Option<u64>>::sse_encode(concealment_events, serializer);
<Option<i32>>::sse_encode(frames_received, serializer);
 }
 _ => { unimplemented!(""); }}}
                }

impl SseEncode for crate::api::stats::rtc_media_source_stats_media_type::RtcMediaSourceStatsMediaType {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {match self {crate::api::stats::rtc_media_source_stats_media_type::RtcMediaSourceStatsMediaType::RtcVideoSourceStats{width,height,frames,frames_per_second} => { <i32>::sse_encode(0, serializer); <Option<u32>>::sse_encode(width, serializer);
<Option<u32>>::sse_encode(height, serializer);
<Option<u32>>::sse_encode(frames, serializer);
<Option<f64>>::sse_encode(frames_per_second, serializer);
 }
crate::api::stats::rtc_media_source_stats_media_type::RtcMediaSourceStatsMediaType::RtcAudioSourceStats{audio_level,total_audio_energy,total_samples_duration,echo_return_loss,echo_return_loss_enhancement} => { <i32>::sse_encode(1, serializer); <Option<f64>>::sse_encode(audio_level, serializer);
<Option<f64>>::sse_encode(total_audio_energy, serializer);
<Option<f64>>::sse_encode(total_samples_duration, serializer);
<Option<f64>>::sse_encode(echo_return_loss, serializer);
<Option<f64>>::sse_encode(echo_return_loss_enhancement, serializer);
 }
 _ => { unimplemented!(""); }}}
                }

impl SseEncode for crate::api::stats::rtc_outbound_rtp_stream_media_type::RtcOutboundRtpStreamStatsMediaType {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {match self {crate::api::stats::rtc_outbound_rtp_stream_media_type::RtcOutboundRtpStreamStatsMediaType::Audio{total_samples_sent,voice_activity_flag} => { <i32>::sse_encode(0, serializer); <Option<u64>>::sse_encode(total_samples_sent, serializer);
<Option<bool>>::sse_encode(voice_activity_flag, serializer);
 }
crate::api::stats::rtc_outbound_rtp_stream_media_type::RtcOutboundRtpStreamStatsMediaType::Video{frame_width,frame_height,frames_per_second} => { <i32>::sse_encode(1, serializer); <Option<u32>>::sse_encode(frame_width, serializer);
<Option<u32>>::sse_encode(frame_height, serializer);
<Option<f64>>::sse_encode(frames_per_second, serializer);
 }
 _ => { unimplemented!(""); }}}
                }

impl SseEncode
    for crate::api::rtc_rtp_encoding_parameters::RtcRtpEncodingParameters
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <String>::sse_encode(self.rid, serializer);
        <bool>::sse_encode(self.active, serializer);
        <Option<i32>>::sse_encode(self.max_bitrate, serializer);
        <Option<f64>>::sse_encode(self.max_framerate, serializer);
        <Option<f64>>::sse_encode(self.scale_resolution_down_by, serializer);
        <Option<String>>::sse_encode(self.scalability_mode, serializer);
    }
}

impl SseEncode for crate::api::rtc_rtp_send_parameters::RtcRtpSendParameters {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <Vec<(
            crate::api::rtc_rtp_encoding_parameters::RtcRtpEncodingParameters,
            RustOpaqueMoi<Arc<RtpEncodingParameters>>,
        )>>::sse_encode(self.encodings, serializer);
        <RustOpaqueMoi<Arc<RtpParameters>>>::sse_encode(self.inner, serializer);
    }
}

impl SseEncode for crate::api::transceiver::RtcRtpTransceiver {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <RustOpaqueMoi<Arc<PeerConnection>>>::sse_encode(self.peer, serializer);
        <RustOpaqueMoi<Arc<RtpTransceiver>>>::sse_encode(
            self.transceiver,
            serializer,
        );
        <Option<String>>::sse_encode(self.mid, serializer);
        <crate::api::transceiver::direction::RtpTransceiverDirection>::sse_encode(self.direction, serializer);
    }
}

impl SseEncode
    for crate::api::peer::rtc_session_description::RtcSessionDescription
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <String>::sse_encode(self.sdp, serializer);
        <crate::api::peer::rtc_session_description::SdpType>::sse_encode(
            self.kind, serializer,
        );
    }
}

impl SseEncode for crate::api::stats::RtcStats {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <String>::sse_encode(self.id, serializer);
        <i64>::sse_encode(self.timestamp_us, serializer);
        <crate::api::stats::RtcStatsType>::sse_encode(self.kind, serializer);
    }
}

impl SseEncode for crate::api::stats::rtc_stats_ice_candidate_pair_state::RtcStatsIceCandidatePairState {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {<i32>::sse_encode(match self {crate::api::stats::rtc_stats_ice_candidate_pair_state::RtcStatsIceCandidatePairState::Frozen => { 0 }
crate::api::stats::rtc_stats_ice_candidate_pair_state::RtcStatsIceCandidatePairState::Waiting => { 1 }
crate::api::stats::rtc_stats_ice_candidate_pair_state::RtcStatsIceCandidatePairState::InProgress => { 2 }
crate::api::stats::rtc_stats_ice_candidate_pair_state::RtcStatsIceCandidatePairState::Failed => { 3 }
crate::api::stats::rtc_stats_ice_candidate_pair_state::RtcStatsIceCandidatePairState::Succeeded => { 4 }
 _ => { unimplemented!(""); }}, serializer);}
                }

impl SseEncode for crate::api::stats::RtcStatsType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        match self {crate::api::stats::RtcStatsType::RtcMediaSourceStats{track_identifier,kind} => { <i32>::sse_encode(0, serializer); <Option<String>>::sse_encode(track_identifier, serializer);
<crate::api::stats::rtc_media_source_stats_media_type::RtcMediaSourceStatsMediaType>::sse_encode(kind, serializer);
 }
crate::api::stats::RtcStatsType::RtcIceCandidateStats(field0) => { <i32>::sse_encode(1, serializer); <crate::api::stats::rtc_ice_candidate_stats::RtcIceCandidateStats>::sse_encode(field0, serializer);
 }
crate::api::stats::RtcStatsType::RtcOutboundRtpStreamStats{track_id,media_type,bytes_sent,packets_sent,media_source_id} => { <i32>::sse_encode(2, serializer); <Option<String>>::sse_encode(track_id, serializer);
<crate::api::stats::rtc_outbound_rtp_stream_media_type::RtcOutboundRtpStreamStatsMediaType>::sse_encode(media_type, serializer);
<Option<u64>>::sse_encode(bytes_sent, serializer);
<Option<u32>>::sse_encode(packets_sent, serializer);
<Option<String>>::sse_encode(media_source_id, serializer);
 }
crate::api::stats::RtcStatsType::RtcInboundRtpStreamStats{remote_id,bytes_received,packets_received,packets_lost,jitter,total_decode_time,jitter_buffer_emitted_count,media_type} => { <i32>::sse_encode(3, serializer); <Option<String>>::sse_encode(remote_id, serializer);
<Option<u64>>::sse_encode(bytes_received, serializer);
<Option<u32>>::sse_encode(packets_received, serializer);
<Option<u64>>::sse_encode(packets_lost, serializer);
<Option<f64>>::sse_encode(jitter, serializer);
<Option<f64>>::sse_encode(total_decode_time, serializer);
<Option<u64>>::sse_encode(jitter_buffer_emitted_count, serializer);
<Option<crate::api::stats::rtc_inbound_rtp_stream_media_type::RtcInboundRtpStreamMediaType>>::sse_encode(media_type, serializer);
 }
crate::api::stats::RtcStatsType::RtcIceCandidatePairStats{state,nominated,bytes_sent,bytes_received,total_round_trip_time,current_round_trip_time,available_outgoing_bitrate} => { <i32>::sse_encode(4, serializer); <crate::api::stats::rtc_stats_ice_candidate_pair_state::RtcStatsIceCandidatePairState>::sse_encode(state, serializer);
<Option<bool>>::sse_encode(nominated, serializer);
<Option<u64>>::sse_encode(bytes_sent, serializer);
<Option<u64>>::sse_encode(bytes_received, serializer);
<Option<f64>>::sse_encode(total_round_trip_time, serializer);
<Option<f64>>::sse_encode(current_round_trip_time, serializer);
<Option<f64>>::sse_encode(available_outgoing_bitrate, serializer);
 }
crate::api::stats::RtcStatsType::RtcTransportStats{packets_sent,packets_received,bytes_sent,bytes_received,ice_role} => { <i32>::sse_encode(5, serializer); <Option<u64>>::sse_encode(packets_sent, serializer);
<Option<u64>>::sse_encode(packets_received, serializer);
<Option<u64>>::sse_encode(bytes_sent, serializer);
<Option<u64>>::sse_encode(bytes_received, serializer);
<Option<crate::api::stats::ice_role::IceRole>>::sse_encode(ice_role, serializer);
 }
crate::api::stats::RtcStatsType::RtcRemoteInboundRtpStreamStats{local_id,jitter,round_trip_time,fraction_lost,reports_received,round_trip_time_measurements} => { <i32>::sse_encode(6, serializer); <Option<String>>::sse_encode(local_id, serializer);
<Option<f64>>::sse_encode(jitter, serializer);
<Option<f64>>::sse_encode(round_trip_time, serializer);
<Option<f64>>::sse_encode(fraction_lost, serializer);
<Option<u64>>::sse_encode(reports_received, serializer);
<Option<i32>>::sse_encode(round_trip_time_measurements, serializer);
 }
crate::api::stats::RtcStatsType::RtcRemoteOutboundRtpStreamStats{local_id,remote_timestamp,reports_sent} => { <i32>::sse_encode(7, serializer); <Option<String>>::sse_encode(local_id, serializer);
<Option<f64>>::sse_encode(remote_timestamp, serializer);
<Option<u64>>::sse_encode(reports_sent, serializer);
 }
crate::api::stats::RtcStatsType::Unimplemented => { <i32>::sse_encode(8, serializer);  }
 _ => { unimplemented!(""); }}
    }
}

impl SseEncode for crate::api::peer::events::rtc_track_event::RtcTrackEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <crate::api::media_stream_track::MediaStreamTrack>::sse_encode(
            self.track, serializer,
        );
        <crate::api::transceiver::RtcRtpTransceiver>::sse_encode(
            self.transceiver,
            serializer,
        );
    }
}

impl SseEncode
    for crate::api::capability::rtp_codec::rtcp_feedback::RtcpFeedback
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <Option<crate::api::capability::rtp_codec::rtcp_feedback::RtcpFeedbackMessageType>>::sse_encode(self.message_type, serializer);
        <crate::api::capability::rtp_codec::rtcp_feedback::RtcpFeedbackType>::sse_encode(self.kind, serializer);
    }
}

impl SseEncode for crate::api::capability::rtp_codec::rtcp_feedback::RtcpFeedbackMessageType {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {<i32>::sse_encode(match self {crate::api::capability::rtp_codec::rtcp_feedback::RtcpFeedbackMessageType::GenericNACK => { 0 }
crate::api::capability::rtp_codec::rtcp_feedback::RtcpFeedbackMessageType::Pli => { 1 }
crate::api::capability::rtp_codec::rtcp_feedback::RtcpFeedbackMessageType::Fir => { 2 }
 _ => { unimplemented!(""); }}, serializer);}
                }

impl SseEncode
    for crate::api::capability::rtp_codec::rtcp_feedback::RtcpFeedbackType
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(match self {crate::api::capability::rtp_codec::rtcp_feedback::RtcpFeedbackType::Ccm => { 0 }
crate::api::capability::rtp_codec::rtcp_feedback::RtcpFeedbackType::Lntf => { 1 }
crate::api::capability::rtp_codec::rtcp_feedback::RtcpFeedbackType::Nack => { 2 }
crate::api::capability::rtp_codec::rtcp_feedback::RtcpFeedbackType::Remb => { 3 }
crate::api::capability::rtp_codec::rtcp_feedback::RtcpFeedbackType::TransportCC => { 4 }
 _ => { unimplemented!(""); }}, serializer);
    }
}

impl SseEncode for crate::api::capability::RtpCapabilities {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <Vec<crate::api::capability::rtp_codec::RtpCodecCapability>>::sse_encode(self.codecs, serializer);
        <Vec<crate::api::capability::rtp_header_extension_capability::RtpHeaderExtensionCapability>>::sse_encode(self.header_extensions, serializer);
    }
}

impl SseEncode for crate::api::capability::rtp_codec::RtpCodecCapability {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <Option<i32>>::sse_encode(self.preferred_payload_type, serializer);
        <Vec<crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode>>::sse_encode(self.scalability_modes, serializer);
        <String>::sse_encode(self.mime_type, serializer);
        <String>::sse_encode(self.name, serializer);
        <crate::api::media_stream_track::media_type::MediaType>::sse_encode(
            self.kind, serializer,
        );
        <Option<i32>>::sse_encode(self.clock_rate, serializer);
        <Option<i32>>::sse_encode(self.num_channels, serializer);
        <Vec<(String, String)>>::sse_encode(self.parameters, serializer);
        <Vec<crate::api::capability::rtp_codec::rtcp_feedback::RtcpFeedback>>::sse_encode(self.feedback, serializer);
    }
}

impl SseEncode for crate::api::capability::rtp_header_extension_capability::RtpHeaderExtensionCapability {
                    // Codec=Sse (Serialization based), see doc to use other codecs
                    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {<String>::sse_encode(self.uri, serializer);
<Option<i32>>::sse_encode(self.preferred_id, serializer);
<bool>::sse_encode(self.preferred_encrypted, serializer);
<crate::api::transceiver::direction::RtpTransceiverDirection>::sse_encode(self.direction, serializer);}
                }

impl SseEncode for crate::api::transceiver::direction::RtpTransceiverDirection {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(match self {crate::api::transceiver::direction::RtpTransceiverDirection::SendRecv => { 0 }
crate::api::transceiver::direction::RtpTransceiverDirection::SendOnly => { 1 }
crate::api::transceiver::direction::RtpTransceiverDirection::RecvOnly => { 2 }
crate::api::transceiver::direction::RtpTransceiverDirection::Inactive => { 3 }
crate::api::transceiver::direction::RtpTransceiverDirection::Stopped => { 4 }
 _ => { unimplemented!(""); }}, serializer);
    }
}

impl SseEncode for crate::api::transceiver::init::RtpTransceiverInit {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <crate::api::transceiver::direction::RtpTransceiverDirection>::sse_encode(self.direction, serializer);
        <Vec<crate::api::rtc_rtp_encoding_parameters::RtcRtpEncodingParameters>>::sse_encode(self.send_encodings, serializer);
    }
}

impl SseEncode
    for crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(match self {crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::L1T1 => { 0 }
crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::L1T2 => { 1 }
crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::L1T3 => { 2 }
crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::L2T1 => { 3 }
crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::L2T1h => { 4 }
crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::L2t1Key => { 5 }
crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::L2T2 => { 6 }
crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::L2T2h => { 7 }
crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::L2T2Key => { 8 }
crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::L2T2KeyShift => { 9 }
crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::L2T3 => { 10 }
crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::L2T3h => { 11 }
crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::L2T3Key => { 12 }
crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::L3T1 => { 13 }
crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::L3T1h => { 14 }
crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::L3T1Key => { 15 }
crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::L3T2 => { 16 }
crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::L3T2h => { 17 }
crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::L3T2Key => { 18 }
crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::L3T3 => { 19 }
crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::L3T3h => { 20 }
crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::L3T3Key => { 21 }
crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::S2T1 => { 22 }
crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::S2T1h => { 23 }
crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::S2T2 => { 24 }
crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::S2T2h => { 25 }
crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::S2T3 => { 26 }
crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::S2T3h => { 27 }
crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::S3T1 => { 28 }
crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::S3T1h => { 29 }
crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::S3T2 => { 30 }
crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::S3T2h => { 31 }
crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::S3T3 => { 32 }
crate::api::capability::rtp_codec::scalability_mode::ScalabilityMode::S3T3h => { 33 }
 _ => { unimplemented!(""); }}, serializer);
    }
}

impl SseEncode for crate::api::peer::rtc_session_description::SdpType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(match self {crate::api::peer::rtc_session_description::SdpType::Offer => { 0 }
crate::api::peer::rtc_session_description::SdpType::PrAnswer => { 1 }
crate::api::peer::rtc_session_description::SdpType::Answer => { 2 }
crate::api::peer::rtc_session_description::SdpType::Rollback => { 3 }
 _ => { unimplemented!(""); }}, serializer);
    }
}

impl SseEncode for crate::api::peer::events::signaling_state::SignalingState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(match self {crate::api::peer::events::signaling_state::SignalingState::Stable => { 0 }
crate::api::peer::events::signaling_state::SignalingState::HaveLocalOffer => { 1 }
crate::api::peer::events::signaling_state::SignalingState::HaveLocalPrAnswer => { 2 }
crate::api::peer::events::signaling_state::SignalingState::HaveRemoteOffer => { 3 }
crate::api::peer::events::signaling_state::SignalingState::HaveRemotePrAnswer => { 4 }
crate::api::peer::events::signaling_state::SignalingState::Closed => { 5 }
 _ => { unimplemented!(""); }}, serializer);
    }
}

impl SseEncode for crate::renderer::TextureEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        match self {
            crate::renderer::TextureEvent::OnTextureChange {
                texture_id,
                width,
                height,
                rotation,
            } => {
                <i32>::sse_encode(0, serializer);
                <i64>::sse_encode(texture_id, serializer);
                <i32>::sse_encode(width, serializer);
                <i32>::sse_encode(height, serializer);
                <i32>::sse_encode(rotation, serializer);
            }
            crate::renderer::TextureEvent::OnFirstFrameRendered {
                texture_id,
            } => {
                <i32>::sse_encode(1, serializer);
                <i64>::sse_encode(texture_id, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::media_stream_track::track_event::TrackEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        match self {crate::api::media_stream_track::track_event::TrackEvent::Ended => { <i32>::sse_encode(0, serializer);  }
crate::api::media_stream_track::track_event::TrackEvent::AudioLevelUpdated(field0) => { <i32>::sse_encode(1, serializer); <u32>::sse_encode(field0, serializer);
 }
crate::api::media_stream_track::track_event::TrackEvent::TrackCreated => { <i32>::sse_encode(2, serializer);  }
 _ => { unimplemented!(""); }}
    }
}

impl SseEncode for crate::api::media_stream_track::track_state::TrackState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(match self {crate::api::media_stream_track::track_state::TrackState::Live => { 0 }
crate::api::media_stream_track::track_state::TrackState::Ended => { 1 }
 _ => { unimplemented!(""); }}, serializer);
    }
}

impl SseEncode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        serializer.cursor.write_u32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        serializer.cursor.write_u64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        serializer.cursor.write_u8(self).unwrap();
    }
}

impl SseEncode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
    }
}

impl SseEncode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        serializer.cursor.write_u64::<NativeEndian>(self as _).unwrap();
    }
}

impl SseEncode for crate::api::peer::video_codec_info::VideoCodec {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <i32>::sse_encode(
            match self {
                crate::api::peer::video_codec_info::VideoCodec::AV1 => 0,
                crate::api::peer::video_codec_info::VideoCodec::H264 => 1,
                crate::api::peer::video_codec_info::VideoCodec::H265 => 2,
                crate::api::peer::video_codec_info::VideoCodec::VP8 => 3,
                crate::api::peer::video_codec_info::VideoCodec::VP9 => 4,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::peer::video_codec_info::VideoCodecInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <bool>::sse_encode(self.is_hardware_accelerated, serializer);
        <crate::api::peer::video_codec_info::VideoCodec>::sse_encode(
            self.codec, serializer,
        );
    }
}

impl SseEncode for crate::api::media::constraints::video::VideoConstraints {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(
        self,
        serializer: &mut flutter_rust_bridge::for_generated::SseSerializer,
    ) {
        <Option<String>>::sse_encode(self.device_id, serializer);
        <u32>::sse_encode(self.width, serializer);
        <u32>::sse_encode(self.height, serializer);
        <u32>::sse_encode(self.frame_rate, serializer);
        <bool>::sse_encode(self.is_display, serializer);
    }
}

#[cfg(not(target_family = "wasm"))]
mod io {
    // This file is automatically generated, so please do not edit it.
    // @generated by `flutter_rust_bridge`@ 2.11.1.

    // Section: imports

    use super::*;
    use crate::*;
    use flutter_rust_bridge::for_generated::byteorder::{
        NativeEndian, ReadBytesExt, WriteBytesExt,
    };
    use flutter_rust_bridge::for_generated::{
        transform_result_dco, Lifetimeable, Lockable,
    };
    use flutter_rust_bridge::{Handler, IntoIntoDart};

    // Section: boilerplate

    flutter_rust_bridge::frb_generated_boilerplate_io!();

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_medea_flutter_webrtc_rust_arc_increment_strong_count_RustOpaque_ArcPeerConnection(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<Arc<PeerConnection>>::increment_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_medea_flutter_webrtc_rust_arc_decrement_strong_count_RustOpaque_ArcPeerConnection(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<Arc<PeerConnection>>::decrement_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_medea_flutter_webrtc_rust_arc_increment_strong_count_RustOpaque_ArcRtpEncodingParameters(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<Arc<RtpEncodingParameters>>::increment_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_medea_flutter_webrtc_rust_arc_decrement_strong_count_RustOpaque_ArcRtpEncodingParameters(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<Arc<RtpEncodingParameters>>::decrement_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_medea_flutter_webrtc_rust_arc_increment_strong_count_RustOpaque_ArcRtpParameters(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<Arc<RtpParameters>>::increment_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_medea_flutter_webrtc_rust_arc_decrement_strong_count_RustOpaque_ArcRtpParameters(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<Arc<RtpParameters>>::decrement_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_medea_flutter_webrtc_rust_arc_increment_strong_count_RustOpaque_ArcRtpTransceiver(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<Arc<RtpTransceiver>>::increment_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_medea_flutter_webrtc_rust_arc_decrement_strong_count_RustOpaque_ArcRtpTransceiver(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<Arc<RtpTransceiver>>::decrement_strong_count(ptr as _);
    }
}
#[cfg(not(target_family = "wasm"))]
pub use io::*;
