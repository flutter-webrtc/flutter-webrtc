// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.7.0.

#![allow(
    non_camel_case_types,
    unused,
    non_snake_case,
    clippy::needless_return,
    clippy::redundant_closure_call,
    clippy::redundant_closure,
    clippy::useless_conversion,
    clippy::unit_arg,
    clippy::unused_unit,
    clippy::double_parens,
    clippy::let_and_return,
    clippy::too_many_arguments,
    clippy::match_single_binding,
    clippy::clone_on_copy,
    clippy::let_unit_value,
    clippy::deref_addrof,
    clippy::explicit_auto_deref,
    clippy::borrow_deref_ref,
    clippy::needless_borrow
)]

// Section: imports

use crate::*;
use flutter_rust_bridge::for_generated::byteorder::{NativeEndian, ReadBytesExt, WriteBytesExt};
use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
use flutter_rust_bridge::{Handler, IntoIntoDart};

// Section: boilerplate

flutter_rust_bridge::frb_generated_boilerplate!(
    default_stream_sink_codec = SseCodec,
    default_rust_opaque = RustOpaqueMoi,
    default_rust_auto_opaque = RustAutoOpaqueMoi,
);
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_VERSION: &str = "2.7.0";
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_CONTENT_HASH: i32 = -1353945569;

// Section: executor

flutter_rust_bridge::frb_generated_default_handler!();

// Section: wire_funcs

fn wire__crate__api__add_ice_candidate_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "add_ice_candidate",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_peer = <RustOpaqueMoi<Arc<PeerConnection>>>::sse_decode(&mut deserializer);
            let api_candidate = <String>::sse_decode(&mut deserializer);
            let api_sdp_mid = <String>::sse_decode(&mut deserializer);
            let api_sdp_mline_index = <i32>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::add_ice_candidate(
                            api_peer,
                            api_candidate,
                            api_sdp_mid,
                            api_sdp_mline_index,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__add_transceiver_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "add_transceiver",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_peer = <RustOpaqueMoi<Arc<PeerConnection>>>::sse_decode(&mut deserializer);
            let api_media_type = <crate::api::MediaType>::sse_decode(&mut deserializer);
            let api_init = <crate::api::RtpTransceiverInit>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok =
                            crate::api::add_transceiver(api_peer, api_media_type, api_init)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__clone_track_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "clone_track",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_track_id = <String>::sse_decode(&mut deserializer);
            let api_peer_id = <Option<u32>>::sse_decode(&mut deserializer);
            let api_kind = <crate::api::MediaType>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok =
                            crate::api::clone_track(api_track_id, api_peer_id, api_kind)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__create_answer_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "create_answer",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_peer = <RustOpaqueMoi<Arc<PeerConnection>>>::sse_decode(&mut deserializer);
            let api_voice_activity_detection = <bool>::sse_decode(&mut deserializer);
            let api_ice_restart = <bool>::sse_decode(&mut deserializer);
            let api_use_rtp_mux = <bool>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::create_answer(
                            api_peer,
                            api_voice_activity_detection,
                            api_ice_restart,
                            api_use_rtp_mux,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__create_offer_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "create_offer",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_peer = <RustOpaqueMoi<Arc<PeerConnection>>>::sse_decode(&mut deserializer);
            let api_voice_activity_detection = <bool>::sse_decode(&mut deserializer);
            let api_ice_restart = <bool>::sse_decode(&mut deserializer);
            let api_use_rtp_mux = <bool>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::create_offer(
                            api_peer,
                            api_voice_activity_detection,
                            api_ice_restart,
                            api_use_rtp_mux,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__create_peer_connection_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "create_peer_connection",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_cb = <StreamSink<
                crate::api::PeerConnectionEvent,
                flutter_rust_bridge::for_generated::SseCodec,
            >>::sse_decode(&mut deserializer);
            let api_configuration = <crate::api::RtcConfiguration>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok =
                            crate::api::create_peer_connection(api_cb, api_configuration)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__create_video_sink_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "create_video_sink",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_cb = <StreamSink<
                crate::renderer::TextureEvent,
                flutter_rust_bridge::for_generated::SseCodec,
            >>::sse_decode(&mut deserializer);
            let api_sink_id = <i64>::sse_decode(&mut deserializer);
            let api_peer_id = <Option<u32>>::sse_decode(&mut deserializer);
            let api_track_id = <String>::sse_decode(&mut deserializer);
            let api_callback_ptr = <i64>::sse_decode(&mut deserializer);
            let api_texture_id = <i64>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::create_video_sink(
                            api_cb,
                            api_sink_id,
                            api_peer_id,
                            api_track_id,
                            api_callback_ptr,
                            api_texture_id,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__dispose_peer_connection_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "dispose_peer_connection",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_peer = <RustOpaqueMoi<Arc<PeerConnection>>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok({
                        crate::api::dispose_peer_connection(api_peer);
                    })?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__dispose_track_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "dispose_track",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_track_id = <String>::sse_decode(&mut deserializer);
            let api_peer_id = <Option<u32>>::sse_decode(&mut deserializer);
            let api_kind = <crate::api::MediaType>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok({
                        crate::api::dispose_track(api_track_id, api_peer_id, api_kind);
                    })?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__dispose_video_sink_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "dispose_video_sink",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_sink_id = <i64>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok({
                        crate::api::dispose_video_sink(api_sink_id);
                    })?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__enable_fake_media_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "enable_fake_media",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok({
                        crate::api::enable_fake_media();
                    })?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__enumerate_devices_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "enumerate_devices",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::enumerate_devices()?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__enumerate_displays_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "enumerate_displays",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::enumerate_displays())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__get_media_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_media",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_constraints =
                <crate::api::MediaStreamConstraints>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::get_media(api_constraints))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__get_peer_stats_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_peer_stats",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_peer = <RustOpaqueMoi<Arc<PeerConnection>>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::get_peer_stats(api_peer)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__get_rtp_receiver_capabilities_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_rtp_receiver_capabilities",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_kind = <crate::api::MediaType>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::get_rtp_receiver_capabilities(api_kind))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__get_rtp_sender_capabilities_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_rtp_sender_capabilities",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_kind = <crate::api::MediaType>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::get_rtp_sender_capabilities(api_kind))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__get_transceiver_direction_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_transceiver_direction",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_transceiver =
                <RustOpaqueMoi<Arc<RtpTransceiver>>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::get_transceiver_direction(
                        api_transceiver,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__get_transceiver_mid_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_transceiver_mid",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_transceiver =
                <RustOpaqueMoi<Arc<RtpTransceiver>>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::get_transceiver_mid(api_transceiver))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__get_transceivers_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_transceivers",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_peer = <RustOpaqueMoi<Arc<PeerConnection>>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::get_transceivers(api_peer))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__is_fake_media_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "is_fake_media",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::is_fake_media())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__microphone_volume_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "microphone_volume",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::microphone_volume()?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__microphone_volume_is_available_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "microphone_volume_is_available",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::microphone_volume_is_available()?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__register_track_observer_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "register_track_observer",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_cb = <StreamSink<
                crate::api::TrackEvent,
                flutter_rust_bridge::for_generated::SseCodec,
            >>::sse_decode(&mut deserializer);
            let api_peer_id = <Option<u32>>::sse_decode(&mut deserializer);
            let api_track_id = <String>::sse_decode(&mut deserializer);
            let api_kind = <crate::api::MediaType>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::register_track_observer(
                            api_cb,
                            api_peer_id,
                            api_track_id,
                            api_kind,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__restart_ice_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "restart_ice",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_peer = <RustOpaqueMoi<Arc<PeerConnection>>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok({
                        crate::api::restart_ice(api_peer);
                    })?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__sender_get_parameters_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "sender_get_parameters",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_transceiver =
                <RustOpaqueMoi<Arc<RtpTransceiver>>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::sender_get_parameters(api_transceiver))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__sender_replace_track_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "sender_replace_track",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_peer = <RustOpaqueMoi<Arc<PeerConnection>>>::sse_decode(&mut deserializer);
            let api_transceiver =
                <RustOpaqueMoi<Arc<RtpTransceiver>>>::sse_decode(&mut deserializer);
            let api_track_id = <Option<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::sender_replace_track(
                            api_peer,
                            api_transceiver,
                            api_track_id,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__sender_set_parameters_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "sender_set_parameters",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_transceiver =
                <RustOpaqueMoi<Arc<RtpTransceiver>>>::sse_decode(&mut deserializer);
            let api_params = <crate::api::RtcRtpSendParameters>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok =
                            crate::api::sender_set_parameters(api_transceiver, api_params)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__set_audio_level_observer_enabled_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_audio_level_observer_enabled",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_track_id = <String>::sse_decode(&mut deserializer);
            let api_peer_id = <Option<u32>>::sse_decode(&mut deserializer);
            let api_enabled = <bool>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::set_audio_level_observer_enabled(
                            api_track_id,
                            api_peer_id,
                            api_enabled,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__set_audio_playout_device_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_audio_playout_device",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_device_id = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::set_audio_playout_device(api_device_id)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__set_codec_preferences_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_codec_preferences",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_transceiver =
                <RustOpaqueMoi<Arc<RtpTransceiver>>>::sse_decode(&mut deserializer);
            let api_codecs = <Vec<crate::api::RtpCodecCapability>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok({
                        crate::api::set_codec_preferences(api_transceiver, api_codecs);
                    })?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__set_local_description_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_local_description",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_peer = <RustOpaqueMoi<Arc<PeerConnection>>>::sse_decode(&mut deserializer);
            let api_kind = <crate::api::SdpType>::sse_decode(&mut deserializer);
            let api_sdp = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok =
                            crate::api::set_local_description(api_peer, api_kind, api_sdp)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__set_microphone_volume_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_microphone_volume",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_level = <u8>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::set_microphone_volume(api_level)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__set_on_device_changed_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_on_device_changed",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_cb = <StreamSink<(), flutter_rust_bridge::for_generated::SseCodec>>::sse_decode(
                &mut deserializer,
            );
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::set_on_device_changed(api_cb)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__set_remote_description_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_remote_description",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_peer = <RustOpaqueMoi<Arc<PeerConnection>>>::sse_decode(&mut deserializer);
            let api_kind = <crate::api::SdpType>::sse_decode(&mut deserializer);
            let api_sdp = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok =
                            crate::api::set_remote_description(api_peer, api_kind, api_sdp)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__set_track_enabled_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_track_enabled",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_track_id = <String>::sse_decode(&mut deserializer);
            let api_peer_id = <Option<u32>>::sse_decode(&mut deserializer);
            let api_kind = <crate::api::MediaType>::sse_decode(&mut deserializer);
            let api_enabled = <bool>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::set_track_enabled(
                            api_track_id,
                            api_peer_id,
                            api_kind,
                            api_enabled,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__set_transceiver_direction_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_transceiver_direction",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_transceiver =
                <RustOpaqueMoi<Arc<RtpTransceiver>>>::sse_decode(&mut deserializer);
            let api_direction =
                <crate::api::RtpTransceiverDirection>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok =
                            crate::api::set_transceiver_direction(api_transceiver, api_direction)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__set_transceiver_recv_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_transceiver_recv",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_transceiver =
                <RustOpaqueMoi<Arc<RtpTransceiver>>>::sse_decode(&mut deserializer);
            let api_recv = <bool>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok =
                            crate::api::set_transceiver_recv(api_transceiver, api_recv)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__set_transceiver_send_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_transceiver_send",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_transceiver =
                <RustOpaqueMoi<Arc<RtpTransceiver>>>::sse_decode(&mut deserializer);
            let api_send = <bool>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok =
                            crate::api::set_transceiver_send(api_transceiver, api_send)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__stop_transceiver_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "stop_transceiver",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_transceiver =
                <RustOpaqueMoi<Arc<RtpTransceiver>>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::stop_transceiver(api_transceiver)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__track_height_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "track_height",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_track_id = <String>::sse_decode(&mut deserializer);
            let api_peer_id = <Option<u32>>::sse_decode(&mut deserializer);
            let api_kind = <crate::api::MediaType>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok =
                            crate::api::track_height(api_track_id, api_peer_id, api_kind)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__track_state_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "track_state",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_track_id = <String>::sse_decode(&mut deserializer);
            let api_peer_id = <Option<u32>>::sse_decode(&mut deserializer);
            let api_kind = <crate::api::MediaType>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok =
                            crate::api::track_state(api_track_id, api_peer_id, api_kind)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__track_width_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "track_width",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_track_id = <String>::sse_decode(&mut deserializer);
            let api_peer_id = <Option<u32>>::sse_decode(&mut deserializer);
            let api_kind = <crate::api::MediaType>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok =
                            crate::api::track_width(api_track_id, api_peer_id, api_kind)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__video_decoders_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "video_decoders",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::video_decoders())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__video_encoders_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "video_encoders",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::video_encoders())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}

// Section: related_funcs

flutter_rust_bridge::frb_generated_moi_arc_impl_value!(Arc<PeerConnection>);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(Arc<RtpEncodingParameters>);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(Arc<RtpParameters>);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(Arc<RtpTransceiver>);

// Section: dart2rust

impl SseDecode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::anyhow::anyhow!("{}", inner);
    }
}

impl SseDecode for RustOpaqueMoi<Arc<PeerConnection>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode for RustOpaqueMoi<Arc<RtpEncodingParameters>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode for RustOpaqueMoi<Arc<RtpParameters>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode for RustOpaqueMoi<Arc<RtpTransceiver>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for StreamSink<crate::api::PeerConnectionEvent, flutter_rust_bridge::for_generated::SseCodec>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return StreamSink::deserialize(inner);
    }
}

impl SseDecode
    for StreamSink<crate::renderer::TextureEvent, flutter_rust_bridge::for_generated::SseCodec>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return StreamSink::deserialize(inner);
    }
}

impl SseDecode
    for StreamSink<crate::api::TrackEvent, flutter_rust_bridge::for_generated::SseCodec>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return StreamSink::deserialize(inner);
    }
}

impl SseDecode for StreamSink<(), flutter_rust_bridge::for_generated::SseCodec> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return StreamSink::deserialize(inner);
    }
}

impl SseDecode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return String::from_utf8(inner).unwrap();
    }
}

impl SseDecode for crate::api::AudioConstraints {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_deviceId = <Option<String>>::sse_decode(deserializer);
        let mut var_autoGainControl = <Option<bool>>::sse_decode(deserializer);
        return crate::api::AudioConstraints {
            device_id: var_deviceId,
            auto_gain_control: var_autoGainControl,
        };
    }
}

impl SseDecode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap() != 0
    }
}

impl SseDecode for crate::api::BundlePolicy {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::BundlePolicy::Balanced,
            1 => crate::api::BundlePolicy::MaxBundle,
            2 => crate::api::BundlePolicy::MaxCompat,
            _ => unreachable!("Invalid variant for BundlePolicy: {}", inner),
        };
    }
}

impl SseDecode for crate::api::CandidateType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::CandidateType::Host,
            1 => crate::api::CandidateType::Srflx,
            2 => crate::api::CandidateType::Prflx,
            3 => crate::api::CandidateType::Relay,
            _ => unreachable!("Invalid variant for CandidateType: {}", inner),
        };
    }
}

impl SseDecode for f64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_f64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for crate::api::GetMediaError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::GetMediaError::Audio(var_field0);
            }
            1 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::GetMediaError::Video(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::GetMediaResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 = <Vec<crate::api::MediaStreamTrack>>::sse_decode(deserializer);
                return crate::api::GetMediaResult::Ok(var_field0);
            }
            1 => {
                let mut var_field0 = <crate::api::GetMediaError>::sse_decode(deserializer);
                return crate::api::GetMediaResult::Err(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for i64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for crate::api::IceCandidateStats {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_transportId = <Option<String>>::sse_decode(deserializer);
        let mut var_address = <Option<String>>::sse_decode(deserializer);
        let mut var_port = <Option<i32>>::sse_decode(deserializer);
        let mut var_protocol = <crate::api::Protocol>::sse_decode(deserializer);
        let mut var_candidateType = <crate::api::CandidateType>::sse_decode(deserializer);
        let mut var_priority = <Option<i32>>::sse_decode(deserializer);
        let mut var_url = <Option<String>>::sse_decode(deserializer);
        let mut var_relayProtocol = <Option<crate::api::Protocol>>::sse_decode(deserializer);
        return crate::api::IceCandidateStats {
            transport_id: var_transportId,
            address: var_address,
            port: var_port,
            protocol: var_protocol,
            candidate_type: var_candidateType,
            priority: var_priority,
            url: var_url,
            relay_protocol: var_relayProtocol,
        };
    }
}

impl SseDecode for crate::api::IceConnectionState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::IceConnectionState::New,
            1 => crate::api::IceConnectionState::Checking,
            2 => crate::api::IceConnectionState::Connected,
            3 => crate::api::IceConnectionState::Completed,
            4 => crate::api::IceConnectionState::Failed,
            5 => crate::api::IceConnectionState::Disconnected,
            6 => crate::api::IceConnectionState::Closed,
            _ => unreachable!("Invalid variant for IceConnectionState: {}", inner),
        };
    }
}

impl SseDecode for crate::api::IceGatheringState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::IceGatheringState::New,
            1 => crate::api::IceGatheringState::Gathering,
            2 => crate::api::IceGatheringState::Complete,
            _ => unreachable!("Invalid variant for IceGatheringState: {}", inner),
        };
    }
}

impl SseDecode for crate::api::IceRole {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::IceRole::Unknown,
            1 => crate::api::IceRole::Controlling,
            2 => crate::api::IceRole::Controlled,
            _ => unreachable!("Invalid variant for IceRole: {}", inner),
        };
    }
}

impl SseDecode for crate::api::IceTransportsType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::IceTransportsType::All,
            1 => crate::api::IceTransportsType::Relay,
            2 => crate::api::IceTransportsType::NoHost,
            3 => crate::api::IceTransportsType::None,
            _ => unreachable!("Invalid variant for IceTransportsType: {}", inner),
        };
    }
}

impl SseDecode for Vec<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<String>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::MediaDeviceInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::MediaDeviceInfo>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::MediaDisplayInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::MediaDisplayInfo>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::MediaStreamTrack> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::MediaStreamTrack>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u8>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode
    for Vec<(
        crate::api::RtcRtpEncodingParameters,
        RustOpaqueMoi<Arc<RtpEncodingParameters>>,
    )>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(
                crate::api::RtcRtpEncodingParameters,
                RustOpaqueMoi<Arc<RtpEncodingParameters>>,
            )>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<(String, String)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(String, String)>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::RtcIceServer> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::RtcIceServer>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::RtcRtpEncodingParameters> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::RtcRtpEncodingParameters>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::RtcRtpTransceiver> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::RtcRtpTransceiver>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::RtcStats> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::RtcStats>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::RtcpFeedback> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::RtcpFeedback>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::RtpCodecCapability> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::RtpCodecCapability>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::RtpHeaderExtensionCapability> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::RtpHeaderExtensionCapability>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::ScalabilityMode> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::ScalabilityMode>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::VideoCodecInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::VideoCodecInfo>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for crate::api::MediaDeviceInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_deviceId = <String>::sse_decode(deserializer);
        let mut var_kind = <crate::api::MediaDeviceKind>::sse_decode(deserializer);
        let mut var_label = <String>::sse_decode(deserializer);
        return crate::api::MediaDeviceInfo {
            device_id: var_deviceId,
            kind: var_kind,
            label: var_label,
        };
    }
}

impl SseDecode for crate::api::MediaDeviceKind {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::MediaDeviceKind::AudioInput,
            1 => crate::api::MediaDeviceKind::AudioOutput,
            2 => crate::api::MediaDeviceKind::VideoInput,
            _ => unreachable!("Invalid variant for MediaDeviceKind: {}", inner),
        };
    }
}

impl SseDecode for crate::api::MediaDisplayInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_deviceId = <String>::sse_decode(deserializer);
        let mut var_title = <Option<String>>::sse_decode(deserializer);
        return crate::api::MediaDisplayInfo {
            device_id: var_deviceId,
            title: var_title,
        };
    }
}

impl SseDecode for crate::api::MediaStreamConstraints {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_audio = <Option<crate::api::AudioConstraints>>::sse_decode(deserializer);
        let mut var_video = <Option<crate::api::VideoConstraints>>::sse_decode(deserializer);
        return crate::api::MediaStreamConstraints {
            audio: var_audio,
            video: var_video,
        };
    }
}

impl SseDecode for crate::api::MediaStreamTrack {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_peerId = <Option<u32>>::sse_decode(deserializer);
        let mut var_deviceId = <String>::sse_decode(deserializer);
        let mut var_kind = <crate::api::MediaType>::sse_decode(deserializer);
        let mut var_enabled = <bool>::sse_decode(deserializer);
        return crate::api::MediaStreamTrack {
            id: var_id,
            peer_id: var_peerId,
            device_id: var_deviceId,
            kind: var_kind,
            enabled: var_enabled,
        };
    }
}

impl SseDecode for crate::api::MediaType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::MediaType::Audio,
            1 => crate::api::MediaType::Video,
            _ => unreachable!("Invalid variant for MediaType: {}", inner),
        };
    }
}

impl SseDecode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<String>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::AudioConstraints> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::AudioConstraints>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<bool> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<bool>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<f64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<f64>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<i32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<i32>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::IceRole> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::IceRole>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::Protocol> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::Protocol>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::RtcInboundRtpStreamMediaType> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::RtcInboundRtpStreamMediaType>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::RtcpFeedbackMessageType> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::RtcpFeedbackMessageType>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u32>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u64>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::VideoConstraints> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::VideoConstraints>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for crate::api::PeerConnectionEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_peer = <RustOpaqueMoi<Arc<PeerConnection>>>::sse_decode(deserializer);
                return crate::api::PeerConnectionEvent::PeerCreated { peer: var_peer };
            }
            1 => {
                let mut var_sdpMid = <String>::sse_decode(deserializer);
                let mut var_sdpMlineIndex = <i32>::sse_decode(deserializer);
                let mut var_candidate = <String>::sse_decode(deserializer);
                return crate::api::PeerConnectionEvent::IceCandidate {
                    sdp_mid: var_sdpMid,
                    sdp_mline_index: var_sdpMlineIndex,
                    candidate: var_candidate,
                };
            }
            2 => {
                let mut var_field0 = <crate::api::IceGatheringState>::sse_decode(deserializer);
                return crate::api::PeerConnectionEvent::IceGatheringStateChange(var_field0);
            }
            3 => {
                let mut var_address = <String>::sse_decode(deserializer);
                let mut var_port = <i32>::sse_decode(deserializer);
                let mut var_url = <String>::sse_decode(deserializer);
                let mut var_errorCode = <i32>::sse_decode(deserializer);
                let mut var_errorText = <String>::sse_decode(deserializer);
                return crate::api::PeerConnectionEvent::IceCandidateError {
                    address: var_address,
                    port: var_port,
                    url: var_url,
                    error_code: var_errorCode,
                    error_text: var_errorText,
                };
            }
            4 => {
                return crate::api::PeerConnectionEvent::NegotiationNeeded;
            }
            5 => {
                let mut var_field0 = <crate::api::SignalingState>::sse_decode(deserializer);
                return crate::api::PeerConnectionEvent::SignallingChange(var_field0);
            }
            6 => {
                let mut var_field0 = <crate::api::IceConnectionState>::sse_decode(deserializer);
                return crate::api::PeerConnectionEvent::IceConnectionStateChange(var_field0);
            }
            7 => {
                let mut var_field0 = <crate::api::PeerConnectionState>::sse_decode(deserializer);
                return crate::api::PeerConnectionEvent::ConnectionStateChange(var_field0);
            }
            8 => {
                let mut var_field0 = <crate::api::RtcTrackEvent>::sse_decode(deserializer);
                return crate::api::PeerConnectionEvent::Track(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::PeerConnectionState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::PeerConnectionState::New,
            1 => crate::api::PeerConnectionState::Connecting,
            2 => crate::api::PeerConnectionState::Connected,
            3 => crate::api::PeerConnectionState::Disconnected,
            4 => crate::api::PeerConnectionState::Failed,
            5 => crate::api::PeerConnectionState::Closed,
            _ => unreachable!("Invalid variant for PeerConnectionState: {}", inner),
        };
    }
}

impl SseDecode for crate::api::Protocol {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::Protocol::Tcp,
            1 => crate::api::Protocol::Udp,
            _ => unreachable!("Invalid variant for Protocol: {}", inner),
        };
    }
}

impl SseDecode
    for (
        crate::api::RtcRtpEncodingParameters,
        RustOpaqueMoi<Arc<RtpEncodingParameters>>,
    )
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <crate::api::RtcRtpEncodingParameters>::sse_decode(deserializer);
        let mut var_field1 = <RustOpaqueMoi<Arc<RtpEncodingParameters>>>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for (String, String) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <String>::sse_decode(deserializer);
        let mut var_field1 = <String>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for crate::api::RtcConfiguration {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_iceTransportPolicy = <crate::api::IceTransportsType>::sse_decode(deserializer);
        let mut var_bundlePolicy = <crate::api::BundlePolicy>::sse_decode(deserializer);
        let mut var_iceServers = <Vec<crate::api::RtcIceServer>>::sse_decode(deserializer);
        return crate::api::RtcConfiguration {
            ice_transport_policy: var_iceTransportPolicy,
            bundle_policy: var_bundlePolicy,
            ice_servers: var_iceServers,
        };
    }
}

impl SseDecode for crate::api::RtcIceCandidateStats {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 = <crate::api::IceCandidateStats>::sse_decode(deserializer);
                return crate::api::RtcIceCandidateStats::Local(var_field0);
            }
            1 => {
                let mut var_field0 = <crate::api::IceCandidateStats>::sse_decode(deserializer);
                return crate::api::RtcIceCandidateStats::Remote(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::RtcIceServer {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_urls = <Vec<String>>::sse_decode(deserializer);
        let mut var_username = <String>::sse_decode(deserializer);
        let mut var_credential = <String>::sse_decode(deserializer);
        return crate::api::RtcIceServer {
            urls: var_urls,
            username: var_username,
            credential: var_credential,
        };
    }
}

impl SseDecode for crate::api::RtcInboundRtpStreamMediaType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_voiceActivityFlag = <Option<bool>>::sse_decode(deserializer);
                let mut var_totalSamplesReceived = <Option<u64>>::sse_decode(deserializer);
                let mut var_concealedSamples = <Option<u64>>::sse_decode(deserializer);
                let mut var_silentConcealedSamples = <Option<u64>>::sse_decode(deserializer);
                let mut var_audioLevel = <Option<f64>>::sse_decode(deserializer);
                let mut var_totalAudioEnergy = <Option<f64>>::sse_decode(deserializer);
                let mut var_totalSamplesDuration = <Option<f64>>::sse_decode(deserializer);
                return crate::api::RtcInboundRtpStreamMediaType::Audio {
                    voice_activity_flag: var_voiceActivityFlag,
                    total_samples_received: var_totalSamplesReceived,
                    concealed_samples: var_concealedSamples,
                    silent_concealed_samples: var_silentConcealedSamples,
                    audio_level: var_audioLevel,
                    total_audio_energy: var_totalAudioEnergy,
                    total_samples_duration: var_totalSamplesDuration,
                };
            }
            1 => {
                let mut var_framesDecoded = <Option<u32>>::sse_decode(deserializer);
                let mut var_keyFramesDecoded = <Option<u32>>::sse_decode(deserializer);
                let mut var_frameWidth = <Option<u32>>::sse_decode(deserializer);
                let mut var_frameHeight = <Option<u32>>::sse_decode(deserializer);
                let mut var_totalInterFrameDelay = <Option<f64>>::sse_decode(deserializer);
                let mut var_framesPerSecond = <Option<f64>>::sse_decode(deserializer);
                let mut var_firCount = <Option<u32>>::sse_decode(deserializer);
                let mut var_pliCount = <Option<u32>>::sse_decode(deserializer);
                let mut var_sliCount = <Option<u32>>::sse_decode(deserializer);
                let mut var_concealmentEvents = <Option<u64>>::sse_decode(deserializer);
                let mut var_framesReceived = <Option<i32>>::sse_decode(deserializer);
                return crate::api::RtcInboundRtpStreamMediaType::Video {
                    frames_decoded: var_framesDecoded,
                    key_frames_decoded: var_keyFramesDecoded,
                    frame_width: var_frameWidth,
                    frame_height: var_frameHeight,
                    total_inter_frame_delay: var_totalInterFrameDelay,
                    frames_per_second: var_framesPerSecond,
                    fir_count: var_firCount,
                    pli_count: var_pliCount,
                    sli_count: var_sliCount,
                    concealment_events: var_concealmentEvents,
                    frames_received: var_framesReceived,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::RtcMediaSourceStatsMediaType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_width = <Option<u32>>::sse_decode(deserializer);
                let mut var_height = <Option<u32>>::sse_decode(deserializer);
                let mut var_frames = <Option<u32>>::sse_decode(deserializer);
                let mut var_framesPerSecond = <Option<f64>>::sse_decode(deserializer);
                return crate::api::RtcMediaSourceStatsMediaType::RtcVideoSourceStats {
                    width: var_width,
                    height: var_height,
                    frames: var_frames,
                    frames_per_second: var_framesPerSecond,
                };
            }
            1 => {
                let mut var_audioLevel = <Option<f64>>::sse_decode(deserializer);
                let mut var_totalAudioEnergy = <Option<f64>>::sse_decode(deserializer);
                let mut var_totalSamplesDuration = <Option<f64>>::sse_decode(deserializer);
                let mut var_echoReturnLoss = <Option<f64>>::sse_decode(deserializer);
                let mut var_echoReturnLossEnhancement = <Option<f64>>::sse_decode(deserializer);
                return crate::api::RtcMediaSourceStatsMediaType::RtcAudioSourceStats {
                    audio_level: var_audioLevel,
                    total_audio_energy: var_totalAudioEnergy,
                    total_samples_duration: var_totalSamplesDuration,
                    echo_return_loss: var_echoReturnLoss,
                    echo_return_loss_enhancement: var_echoReturnLossEnhancement,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::RtcOutboundRtpStreamStatsMediaType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_totalSamplesSent = <Option<u64>>::sse_decode(deserializer);
                let mut var_voiceActivityFlag = <Option<bool>>::sse_decode(deserializer);
                return crate::api::RtcOutboundRtpStreamStatsMediaType::Audio {
                    total_samples_sent: var_totalSamplesSent,
                    voice_activity_flag: var_voiceActivityFlag,
                };
            }
            1 => {
                let mut var_frameWidth = <Option<u32>>::sse_decode(deserializer);
                let mut var_frameHeight = <Option<u32>>::sse_decode(deserializer);
                let mut var_framesPerSecond = <Option<f64>>::sse_decode(deserializer);
                return crate::api::RtcOutboundRtpStreamStatsMediaType::Video {
                    frame_width: var_frameWidth,
                    frame_height: var_frameHeight,
                    frames_per_second: var_framesPerSecond,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::RtcRtpEncodingParameters {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_rid = <String>::sse_decode(deserializer);
        let mut var_active = <bool>::sse_decode(deserializer);
        let mut var_maxBitrate = <Option<i32>>::sse_decode(deserializer);
        let mut var_maxFramerate = <Option<f64>>::sse_decode(deserializer);
        let mut var_scaleResolutionDownBy = <Option<f64>>::sse_decode(deserializer);
        let mut var_scalabilityMode = <Option<String>>::sse_decode(deserializer);
        return crate::api::RtcRtpEncodingParameters {
            rid: var_rid,
            active: var_active,
            max_bitrate: var_maxBitrate,
            max_framerate: var_maxFramerate,
            scale_resolution_down_by: var_scaleResolutionDownBy,
            scalability_mode: var_scalabilityMode,
        };
    }
}

impl SseDecode for crate::api::RtcRtpSendParameters {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_encodings = <Vec<(
            crate::api::RtcRtpEncodingParameters,
            RustOpaqueMoi<Arc<RtpEncodingParameters>>,
        )>>::sse_decode(deserializer);
        let mut var_inner = <RustOpaqueMoi<Arc<RtpParameters>>>::sse_decode(deserializer);
        return crate::api::RtcRtpSendParameters {
            encodings: var_encodings,
            inner: var_inner,
        };
    }
}

impl SseDecode for crate::api::RtcRtpTransceiver {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_peer = <RustOpaqueMoi<Arc<PeerConnection>>>::sse_decode(deserializer);
        let mut var_transceiver = <RustOpaqueMoi<Arc<RtpTransceiver>>>::sse_decode(deserializer);
        let mut var_mid = <Option<String>>::sse_decode(deserializer);
        let mut var_direction = <crate::api::RtpTransceiverDirection>::sse_decode(deserializer);
        return crate::api::RtcRtpTransceiver {
            peer: var_peer,
            transceiver: var_transceiver,
            mid: var_mid,
            direction: var_direction,
        };
    }
}

impl SseDecode for crate::api::RtcSessionDescription {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_sdp = <String>::sse_decode(deserializer);
        let mut var_kind = <crate::api::SdpType>::sse_decode(deserializer);
        return crate::api::RtcSessionDescription {
            sdp: var_sdp,
            kind: var_kind,
        };
    }
}

impl SseDecode for crate::api::RtcStats {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_timestampUs = <i64>::sse_decode(deserializer);
        let mut var_kind = <crate::api::RtcStatsType>::sse_decode(deserializer);
        return crate::api::RtcStats {
            id: var_id,
            timestamp_us: var_timestampUs,
            kind: var_kind,
        };
    }
}

impl SseDecode for crate::api::RtcStatsIceCandidatePairState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::RtcStatsIceCandidatePairState::Frozen,
            1 => crate::api::RtcStatsIceCandidatePairState::Waiting,
            2 => crate::api::RtcStatsIceCandidatePairState::InProgress,
            3 => crate::api::RtcStatsIceCandidatePairState::Failed,
            4 => crate::api::RtcStatsIceCandidatePairState::Succeeded,
            _ => unreachable!(
                "Invalid variant for RtcStatsIceCandidatePairState: {}",
                inner
            ),
        };
    }
}

impl SseDecode for crate::api::RtcStatsType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_trackIdentifier = <Option<String>>::sse_decode(deserializer);
                let mut var_kind =
                    <crate::api::RtcMediaSourceStatsMediaType>::sse_decode(deserializer);
                return crate::api::RtcStatsType::RtcMediaSourceStats {
                    track_identifier: var_trackIdentifier,
                    kind: var_kind,
                };
            }
            1 => {
                let mut var_field0 = <crate::api::RtcIceCandidateStats>::sse_decode(deserializer);
                return crate::api::RtcStatsType::RtcIceCandidateStats(var_field0);
            }
            2 => {
                let mut var_trackId = <Option<String>>::sse_decode(deserializer);
                let mut var_mediaType =
                    <crate::api::RtcOutboundRtpStreamStatsMediaType>::sse_decode(deserializer);
                let mut var_bytesSent = <Option<u64>>::sse_decode(deserializer);
                let mut var_packetsSent = <Option<u32>>::sse_decode(deserializer);
                let mut var_mediaSourceId = <Option<String>>::sse_decode(deserializer);
                return crate::api::RtcStatsType::RtcOutboundRtpStreamStats {
                    track_id: var_trackId,
                    media_type: var_mediaType,
                    bytes_sent: var_bytesSent,
                    packets_sent: var_packetsSent,
                    media_source_id: var_mediaSourceId,
                };
            }
            3 => {
                let mut var_remoteId = <Option<String>>::sse_decode(deserializer);
                let mut var_bytesReceived = <Option<u64>>::sse_decode(deserializer);
                let mut var_packetsReceived = <Option<u32>>::sse_decode(deserializer);
                let mut var_packetsLost = <Option<u64>>::sse_decode(deserializer);
                let mut var_jitter = <Option<f64>>::sse_decode(deserializer);
                let mut var_totalDecodeTime = <Option<f64>>::sse_decode(deserializer);
                let mut var_jitterBufferEmittedCount = <Option<u64>>::sse_decode(deserializer);
                let mut var_mediaType =
                    <Option<crate::api::RtcInboundRtpStreamMediaType>>::sse_decode(deserializer);
                return crate::api::RtcStatsType::RtcInboundRtpStreamStats {
                    remote_id: var_remoteId,
                    bytes_received: var_bytesReceived,
                    packets_received: var_packetsReceived,
                    packets_lost: var_packetsLost,
                    jitter: var_jitter,
                    total_decode_time: var_totalDecodeTime,
                    jitter_buffer_emitted_count: var_jitterBufferEmittedCount,
                    media_type: var_mediaType,
                };
            }
            4 => {
                let mut var_state =
                    <crate::api::RtcStatsIceCandidatePairState>::sse_decode(deserializer);
                let mut var_nominated = <Option<bool>>::sse_decode(deserializer);
                let mut var_bytesSent = <Option<u64>>::sse_decode(deserializer);
                let mut var_bytesReceived = <Option<u64>>::sse_decode(deserializer);
                let mut var_totalRoundTripTime = <Option<f64>>::sse_decode(deserializer);
                let mut var_currentRoundTripTime = <Option<f64>>::sse_decode(deserializer);
                let mut var_availableOutgoingBitrate = <Option<f64>>::sse_decode(deserializer);
                return crate::api::RtcStatsType::RtcIceCandidatePairStats {
                    state: var_state,
                    nominated: var_nominated,
                    bytes_sent: var_bytesSent,
                    bytes_received: var_bytesReceived,
                    total_round_trip_time: var_totalRoundTripTime,
                    current_round_trip_time: var_currentRoundTripTime,
                    available_outgoing_bitrate: var_availableOutgoingBitrate,
                };
            }
            5 => {
                let mut var_packetsSent = <Option<u64>>::sse_decode(deserializer);
                let mut var_packetsReceived = <Option<u64>>::sse_decode(deserializer);
                let mut var_bytesSent = <Option<u64>>::sse_decode(deserializer);
                let mut var_bytesReceived = <Option<u64>>::sse_decode(deserializer);
                let mut var_iceRole = <Option<crate::api::IceRole>>::sse_decode(deserializer);
                return crate::api::RtcStatsType::RtcTransportStats {
                    packets_sent: var_packetsSent,
                    packets_received: var_packetsReceived,
                    bytes_sent: var_bytesSent,
                    bytes_received: var_bytesReceived,
                    ice_role: var_iceRole,
                };
            }
            6 => {
                let mut var_localId = <Option<String>>::sse_decode(deserializer);
                let mut var_jitter = <Option<f64>>::sse_decode(deserializer);
                let mut var_roundTripTime = <Option<f64>>::sse_decode(deserializer);
                let mut var_fractionLost = <Option<f64>>::sse_decode(deserializer);
                let mut var_reportsReceived = <Option<u64>>::sse_decode(deserializer);
                let mut var_roundTripTimeMeasurements = <Option<i32>>::sse_decode(deserializer);
                return crate::api::RtcStatsType::RtcRemoteInboundRtpStreamStats {
                    local_id: var_localId,
                    jitter: var_jitter,
                    round_trip_time: var_roundTripTime,
                    fraction_lost: var_fractionLost,
                    reports_received: var_reportsReceived,
                    round_trip_time_measurements: var_roundTripTimeMeasurements,
                };
            }
            7 => {
                let mut var_localId = <Option<String>>::sse_decode(deserializer);
                let mut var_remoteTimestamp = <Option<f64>>::sse_decode(deserializer);
                let mut var_reportsSent = <Option<u64>>::sse_decode(deserializer);
                return crate::api::RtcStatsType::RtcRemoteOutboundRtpStreamStats {
                    local_id: var_localId,
                    remote_timestamp: var_remoteTimestamp,
                    reports_sent: var_reportsSent,
                };
            }
            8 => {
                return crate::api::RtcStatsType::Unimplemented;
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::RtcTrackEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_track = <crate::api::MediaStreamTrack>::sse_decode(deserializer);
        let mut var_transceiver = <crate::api::RtcRtpTransceiver>::sse_decode(deserializer);
        return crate::api::RtcTrackEvent {
            track: var_track,
            transceiver: var_transceiver,
        };
    }
}

impl SseDecode for crate::api::RtcpFeedback {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_messageType =
            <Option<crate::api::RtcpFeedbackMessageType>>::sse_decode(deserializer);
        let mut var_kind = <crate::api::RtcpFeedbackType>::sse_decode(deserializer);
        return crate::api::RtcpFeedback {
            message_type: var_messageType,
            kind: var_kind,
        };
    }
}

impl SseDecode for crate::api::RtcpFeedbackMessageType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::RtcpFeedbackMessageType::GenericNACK,
            1 => crate::api::RtcpFeedbackMessageType::Pli,
            2 => crate::api::RtcpFeedbackMessageType::Fir,
            _ => unreachable!("Invalid variant for RtcpFeedbackMessageType: {}", inner),
        };
    }
}

impl SseDecode for crate::api::RtcpFeedbackType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::RtcpFeedbackType::Ccm,
            1 => crate::api::RtcpFeedbackType::Lntf,
            2 => crate::api::RtcpFeedbackType::Nack,
            3 => crate::api::RtcpFeedbackType::Remb,
            4 => crate::api::RtcpFeedbackType::TransportCC,
            _ => unreachable!("Invalid variant for RtcpFeedbackType: {}", inner),
        };
    }
}

impl SseDecode for crate::api::RtpCapabilities {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_codecs = <Vec<crate::api::RtpCodecCapability>>::sse_decode(deserializer);
        let mut var_headerExtensions =
            <Vec<crate::api::RtpHeaderExtensionCapability>>::sse_decode(deserializer);
        return crate::api::RtpCapabilities {
            codecs: var_codecs,
            header_extensions: var_headerExtensions,
        };
    }
}

impl SseDecode for crate::api::RtpCodecCapability {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_preferredPayloadType = <Option<i32>>::sse_decode(deserializer);
        let mut var_scalabilityModes = <Vec<crate::api::ScalabilityMode>>::sse_decode(deserializer);
        let mut var_mimeType = <String>::sse_decode(deserializer);
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_kind = <crate::api::MediaType>::sse_decode(deserializer);
        let mut var_clockRate = <Option<i32>>::sse_decode(deserializer);
        let mut var_numChannels = <Option<i32>>::sse_decode(deserializer);
        let mut var_parameters = <Vec<(String, String)>>::sse_decode(deserializer);
        let mut var_feedback = <Vec<crate::api::RtcpFeedback>>::sse_decode(deserializer);
        return crate::api::RtpCodecCapability {
            preferred_payload_type: var_preferredPayloadType,
            scalability_modes: var_scalabilityModes,
            mime_type: var_mimeType,
            name: var_name,
            kind: var_kind,
            clock_rate: var_clockRate,
            num_channels: var_numChannels,
            parameters: var_parameters,
            feedback: var_feedback,
        };
    }
}

impl SseDecode for crate::api::RtpHeaderExtensionCapability {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_uri = <String>::sse_decode(deserializer);
        let mut var_preferredId = <Option<i32>>::sse_decode(deserializer);
        let mut var_preferredEncrypted = <bool>::sse_decode(deserializer);
        let mut var_direction = <crate::api::RtpTransceiverDirection>::sse_decode(deserializer);
        return crate::api::RtpHeaderExtensionCapability {
            uri: var_uri,
            preferred_id: var_preferredId,
            preferred_encrypted: var_preferredEncrypted,
            direction: var_direction,
        };
    }
}

impl SseDecode for crate::api::RtpTransceiverDirection {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::RtpTransceiverDirection::SendRecv,
            1 => crate::api::RtpTransceiverDirection::SendOnly,
            2 => crate::api::RtpTransceiverDirection::RecvOnly,
            3 => crate::api::RtpTransceiverDirection::Inactive,
            4 => crate::api::RtpTransceiverDirection::Stopped,
            _ => unreachable!("Invalid variant for RtpTransceiverDirection: {}", inner),
        };
    }
}

impl SseDecode for crate::api::RtpTransceiverInit {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_direction = <crate::api::RtpTransceiverDirection>::sse_decode(deserializer);
        let mut var_sendEncodings =
            <Vec<crate::api::RtcRtpEncodingParameters>>::sse_decode(deserializer);
        return crate::api::RtpTransceiverInit {
            direction: var_direction,
            send_encodings: var_sendEncodings,
        };
    }
}

impl SseDecode for crate::api::ScalabilityMode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::ScalabilityMode::L1T1,
            1 => crate::api::ScalabilityMode::L1T2,
            2 => crate::api::ScalabilityMode::L1T3,
            3 => crate::api::ScalabilityMode::L2T1,
            4 => crate::api::ScalabilityMode::L2T1h,
            5 => crate::api::ScalabilityMode::L2t1Key,
            6 => crate::api::ScalabilityMode::L2T2,
            7 => crate::api::ScalabilityMode::L2T2h,
            8 => crate::api::ScalabilityMode::L2T2Key,
            9 => crate::api::ScalabilityMode::L2T2KeyShift,
            10 => crate::api::ScalabilityMode::L2T3,
            11 => crate::api::ScalabilityMode::L2T3h,
            12 => crate::api::ScalabilityMode::L2T3Key,
            13 => crate::api::ScalabilityMode::L3T1,
            14 => crate::api::ScalabilityMode::L3T1h,
            15 => crate::api::ScalabilityMode::L3T1Key,
            16 => crate::api::ScalabilityMode::L3T2,
            17 => crate::api::ScalabilityMode::L3T2h,
            18 => crate::api::ScalabilityMode::L3T2Key,
            19 => crate::api::ScalabilityMode::L3T3,
            20 => crate::api::ScalabilityMode::L3T3h,
            21 => crate::api::ScalabilityMode::L3T3Key,
            22 => crate::api::ScalabilityMode::S2T1,
            23 => crate::api::ScalabilityMode::S2T1h,
            24 => crate::api::ScalabilityMode::S2T2,
            25 => crate::api::ScalabilityMode::S2T2h,
            26 => crate::api::ScalabilityMode::S2T3,
            27 => crate::api::ScalabilityMode::S2T3h,
            28 => crate::api::ScalabilityMode::S3T1,
            29 => crate::api::ScalabilityMode::S3T1h,
            30 => crate::api::ScalabilityMode::S3T2,
            31 => crate::api::ScalabilityMode::S3T2h,
            32 => crate::api::ScalabilityMode::S3T3,
            33 => crate::api::ScalabilityMode::S3T3h,
            _ => unreachable!("Invalid variant for ScalabilityMode: {}", inner),
        };
    }
}

impl SseDecode for crate::api::SdpType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::SdpType::Offer,
            1 => crate::api::SdpType::PrAnswer,
            2 => crate::api::SdpType::Answer,
            3 => crate::api::SdpType::Rollback,
            _ => unreachable!("Invalid variant for SdpType: {}", inner),
        };
    }
}

impl SseDecode for crate::api::SignalingState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::SignalingState::Stable,
            1 => crate::api::SignalingState::HaveLocalOffer,
            2 => crate::api::SignalingState::HaveLocalPrAnswer,
            3 => crate::api::SignalingState::HaveRemoteOffer,
            4 => crate::api::SignalingState::HaveRemotePrAnswer,
            5 => crate::api::SignalingState::Closed,
            _ => unreachable!("Invalid variant for SignalingState: {}", inner),
        };
    }
}

impl SseDecode for crate::renderer::TextureEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_textureId = <i64>::sse_decode(deserializer);
                let mut var_width = <i32>::sse_decode(deserializer);
                let mut var_height = <i32>::sse_decode(deserializer);
                let mut var_rotation = <i32>::sse_decode(deserializer);
                return crate::renderer::TextureEvent::OnTextureChange {
                    texture_id: var_textureId,
                    width: var_width,
                    height: var_height,
                    rotation: var_rotation,
                };
            }
            1 => {
                let mut var_textureId = <i64>::sse_decode(deserializer);
                return crate::renderer::TextureEvent::OnFirstFrameRendered {
                    texture_id: var_textureId,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::TrackEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::api::TrackEvent::Ended;
            }
            1 => {
                let mut var_field0 = <u32>::sse_decode(deserializer);
                return crate::api::TrackEvent::AudioLevelUpdated(var_field0);
            }
            2 => {
                return crate::api::TrackEvent::TrackCreated;
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::TrackState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::TrackState::Live,
            1 => crate::api::TrackState::Ended,
            _ => unreachable!("Invalid variant for TrackState: {}", inner),
        };
    }
}

impl SseDecode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap()
    }
}

impl SseDecode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {}
}

impl SseDecode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap() as _
    }
}

impl SseDecode for crate::api::VideoCodec {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::VideoCodec::AV1,
            1 => crate::api::VideoCodec::H264,
            2 => crate::api::VideoCodec::H265,
            3 => crate::api::VideoCodec::VP8,
            4 => crate::api::VideoCodec::VP9,
            _ => unreachable!("Invalid variant for VideoCodec: {}", inner),
        };
    }
}

impl SseDecode for crate::api::VideoCodecInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_isHardwareAccelerated = <bool>::sse_decode(deserializer);
        let mut var_codec = <crate::api::VideoCodec>::sse_decode(deserializer);
        return crate::api::VideoCodecInfo {
            is_hardware_accelerated: var_isHardwareAccelerated,
            codec: var_codec,
        };
    }
}

impl SseDecode for crate::api::VideoConstraints {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_deviceId = <Option<String>>::sse_decode(deserializer);
        let mut var_width = <u32>::sse_decode(deserializer);
        let mut var_height = <u32>::sse_decode(deserializer);
        let mut var_frameRate = <u32>::sse_decode(deserializer);
        let mut var_isDisplay = <bool>::sse_decode(deserializer);
        return crate::api::VideoConstraints {
            device_id: var_deviceId,
            width: var_width,
            height: var_height,
            frame_rate: var_frameRate,
            is_display: var_isDisplay,
        };
    }
}

fn pde_ffi_dispatcher_primary_impl(
    func_id: i32,
    port: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        1 => wire__crate__api__add_ice_candidate_impl(port, ptr, rust_vec_len, data_len),
        2 => wire__crate__api__add_transceiver_impl(port, ptr, rust_vec_len, data_len),
        3 => wire__crate__api__clone_track_impl(port, ptr, rust_vec_len, data_len),
        4 => wire__crate__api__create_answer_impl(port, ptr, rust_vec_len, data_len),
        5 => wire__crate__api__create_offer_impl(port, ptr, rust_vec_len, data_len),
        6 => wire__crate__api__create_peer_connection_impl(port, ptr, rust_vec_len, data_len),
        7 => wire__crate__api__create_video_sink_impl(port, ptr, rust_vec_len, data_len),
        8 => wire__crate__api__dispose_peer_connection_impl(port, ptr, rust_vec_len, data_len),
        9 => wire__crate__api__dispose_track_impl(port, ptr, rust_vec_len, data_len),
        10 => wire__crate__api__dispose_video_sink_impl(port, ptr, rust_vec_len, data_len),
        11 => wire__crate__api__enable_fake_media_impl(port, ptr, rust_vec_len, data_len),
        12 => wire__crate__api__enumerate_devices_impl(port, ptr, rust_vec_len, data_len),
        13 => wire__crate__api__enumerate_displays_impl(port, ptr, rust_vec_len, data_len),
        14 => wire__crate__api__get_media_impl(port, ptr, rust_vec_len, data_len),
        15 => wire__crate__api__get_peer_stats_impl(port, ptr, rust_vec_len, data_len),
        16 => {
            wire__crate__api__get_rtp_receiver_capabilities_impl(port, ptr, rust_vec_len, data_len)
        }
        17 => wire__crate__api__get_rtp_sender_capabilities_impl(port, ptr, rust_vec_len, data_len),
        18 => wire__crate__api__get_transceiver_direction_impl(port, ptr, rust_vec_len, data_len),
        19 => wire__crate__api__get_transceiver_mid_impl(port, ptr, rust_vec_len, data_len),
        20 => wire__crate__api__get_transceivers_impl(port, ptr, rust_vec_len, data_len),
        21 => wire__crate__api__is_fake_media_impl(port, ptr, rust_vec_len, data_len),
        22 => wire__crate__api__microphone_volume_impl(port, ptr, rust_vec_len, data_len),
        23 => {
            wire__crate__api__microphone_volume_is_available_impl(port, ptr, rust_vec_len, data_len)
        }
        24 => wire__crate__api__register_track_observer_impl(port, ptr, rust_vec_len, data_len),
        25 => wire__crate__api__restart_ice_impl(port, ptr, rust_vec_len, data_len),
        26 => wire__crate__api__sender_get_parameters_impl(port, ptr, rust_vec_len, data_len),
        27 => wire__crate__api__sender_replace_track_impl(port, ptr, rust_vec_len, data_len),
        28 => wire__crate__api__sender_set_parameters_impl(port, ptr, rust_vec_len, data_len),
        29 => wire__crate__api__set_audio_level_observer_enabled_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        30 => wire__crate__api__set_audio_playout_device_impl(port, ptr, rust_vec_len, data_len),
        31 => wire__crate__api__set_codec_preferences_impl(port, ptr, rust_vec_len, data_len),
        32 => wire__crate__api__set_local_description_impl(port, ptr, rust_vec_len, data_len),
        33 => wire__crate__api__set_microphone_volume_impl(port, ptr, rust_vec_len, data_len),
        34 => wire__crate__api__set_on_device_changed_impl(port, ptr, rust_vec_len, data_len),
        35 => wire__crate__api__set_remote_description_impl(port, ptr, rust_vec_len, data_len),
        36 => wire__crate__api__set_track_enabled_impl(port, ptr, rust_vec_len, data_len),
        37 => wire__crate__api__set_transceiver_direction_impl(port, ptr, rust_vec_len, data_len),
        38 => wire__crate__api__set_transceiver_recv_impl(port, ptr, rust_vec_len, data_len),
        39 => wire__crate__api__set_transceiver_send_impl(port, ptr, rust_vec_len, data_len),
        40 => wire__crate__api__stop_transceiver_impl(port, ptr, rust_vec_len, data_len),
        41 => wire__crate__api__track_height_impl(port, ptr, rust_vec_len, data_len),
        42 => wire__crate__api__track_state_impl(port, ptr, rust_vec_len, data_len),
        43 => wire__crate__api__track_width_impl(port, ptr, rust_vec_len, data_len),
        44 => wire__crate__api__video_decoders_impl(port, ptr, rust_vec_len, data_len),
        45 => wire__crate__api__video_encoders_impl(port, ptr, rust_vec_len, data_len),
        _ => unreachable!(),
    }
}

fn pde_ffi_dispatcher_sync_impl(
    func_id: i32,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        _ => unreachable!(),
    }
}

// Section: rust2dart

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::AudioConstraints {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.device_id.into_into_dart().into_dart(),
            self.auto_gain_control.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::AudioConstraints {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::AudioConstraints>
    for crate::api::AudioConstraints
{
    fn into_into_dart(self) -> crate::api::AudioConstraints {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::BundlePolicy {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Balanced => 0.into_dart(),
            Self::MaxBundle => 1.into_dart(),
            Self::MaxCompat => 2.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::BundlePolicy {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::BundlePolicy> for crate::api::BundlePolicy {
    fn into_into_dart(self) -> crate::api::BundlePolicy {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::CandidateType {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Host => 0.into_dart(),
            Self::Srflx => 1.into_dart(),
            Self::Prflx => 2.into_dart(),
            Self::Relay => 3.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::CandidateType {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::CandidateType> for crate::api::CandidateType {
    fn into_into_dart(self) -> crate::api::CandidateType {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::GetMediaError {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::GetMediaError::Audio(field0) => {
                [0.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::GetMediaError::Video(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::GetMediaError {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::GetMediaError> for crate::api::GetMediaError {
    fn into_into_dart(self) -> crate::api::GetMediaError {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::GetMediaResult {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::GetMediaResult::Ok(field0) => {
                [0.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::GetMediaResult::Err(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::GetMediaResult {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::GetMediaResult> for crate::api::GetMediaResult {
    fn into_into_dart(self) -> crate::api::GetMediaResult {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::IceCandidateStats {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.transport_id.into_into_dart().into_dart(),
            self.address.into_into_dart().into_dart(),
            self.port.into_into_dart().into_dart(),
            self.protocol.into_into_dart().into_dart(),
            self.candidate_type.into_into_dart().into_dart(),
            self.priority.into_into_dart().into_dart(),
            self.url.into_into_dart().into_dart(),
            self.relay_protocol.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::IceCandidateStats {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::IceCandidateStats>
    for crate::api::IceCandidateStats
{
    fn into_into_dart(self) -> crate::api::IceCandidateStats {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::IceConnectionState {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::New => 0.into_dart(),
            Self::Checking => 1.into_dart(),
            Self::Connected => 2.into_dart(),
            Self::Completed => 3.into_dart(),
            Self::Failed => 4.into_dart(),
            Self::Disconnected => 5.into_dart(),
            Self::Closed => 6.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::IceConnectionState
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::IceConnectionState>
    for crate::api::IceConnectionState
{
    fn into_into_dart(self) -> crate::api::IceConnectionState {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::IceGatheringState {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::New => 0.into_dart(),
            Self::Gathering => 1.into_dart(),
            Self::Complete => 2.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::IceGatheringState {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::IceGatheringState>
    for crate::api::IceGatheringState
{
    fn into_into_dart(self) -> crate::api::IceGatheringState {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::IceRole {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Unknown => 0.into_dart(),
            Self::Controlling => 1.into_dart(),
            Self::Controlled => 2.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::IceRole {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::IceRole> for crate::api::IceRole {
    fn into_into_dart(self) -> crate::api::IceRole {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::IceTransportsType {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::All => 0.into_dart(),
            Self::Relay => 1.into_dart(),
            Self::NoHost => 2.into_dart(),
            Self::None => 3.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::IceTransportsType {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::IceTransportsType>
    for crate::api::IceTransportsType
{
    fn into_into_dart(self) -> crate::api::IceTransportsType {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::MediaDeviceInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.device_id.into_into_dart().into_dart(),
            self.kind.into_into_dart().into_dart(),
            self.label.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::MediaDeviceInfo {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::MediaDeviceInfo>
    for crate::api::MediaDeviceInfo
{
    fn into_into_dart(self) -> crate::api::MediaDeviceInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::MediaDeviceKind {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::AudioInput => 0.into_dart(),
            Self::AudioOutput => 1.into_dart(),
            Self::VideoInput => 2.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::MediaDeviceKind {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::MediaDeviceKind>
    for crate::api::MediaDeviceKind
{
    fn into_into_dart(self) -> crate::api::MediaDeviceKind {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::MediaDisplayInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.device_id.into_into_dart().into_dart(),
            self.title.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::MediaDisplayInfo {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::MediaDisplayInfo>
    for crate::api::MediaDisplayInfo
{
    fn into_into_dart(self) -> crate::api::MediaDisplayInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::MediaStreamConstraints {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.audio.into_into_dart().into_dart(),
            self.video.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::MediaStreamConstraints
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::MediaStreamConstraints>
    for crate::api::MediaStreamConstraints
{
    fn into_into_dart(self) -> crate::api::MediaStreamConstraints {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::MediaStreamTrack {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.peer_id.into_into_dart().into_dart(),
            self.device_id.into_into_dart().into_dart(),
            self.kind.into_into_dart().into_dart(),
            self.enabled.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::MediaStreamTrack {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::MediaStreamTrack>
    for crate::api::MediaStreamTrack
{
    fn into_into_dart(self) -> crate::api::MediaStreamTrack {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::MediaType {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Audio => 0.into_dart(),
            Self::Video => 1.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::MediaType {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::MediaType> for crate::api::MediaType {
    fn into_into_dart(self) -> crate::api::MediaType {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::PeerConnectionEvent {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::PeerConnectionEvent::PeerCreated { peer } => {
                [0.into_dart(), peer.into_into_dart().into_dart()].into_dart()
            }
            crate::api::PeerConnectionEvent::IceCandidate {
                sdp_mid,
                sdp_mline_index,
                candidate,
            } => [
                1.into_dart(),
                sdp_mid.into_into_dart().into_dart(),
                sdp_mline_index.into_into_dart().into_dart(),
                candidate.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::PeerConnectionEvent::IceGatheringStateChange(field0) => {
                [2.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::PeerConnectionEvent::IceCandidateError {
                address,
                port,
                url,
                error_code,
                error_text,
            } => [
                3.into_dart(),
                address.into_into_dart().into_dart(),
                port.into_into_dart().into_dart(),
                url.into_into_dart().into_dart(),
                error_code.into_into_dart().into_dart(),
                error_text.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::PeerConnectionEvent::NegotiationNeeded => [4.into_dart()].into_dart(),
            crate::api::PeerConnectionEvent::SignallingChange(field0) => {
                [5.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::PeerConnectionEvent::IceConnectionStateChange(field0) => {
                [6.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::PeerConnectionEvent::ConnectionStateChange(field0) => {
                [7.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::PeerConnectionEvent::Track(field0) => {
                [8.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::PeerConnectionEvent
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::PeerConnectionEvent>
    for crate::api::PeerConnectionEvent
{
    fn into_into_dart(self) -> crate::api::PeerConnectionEvent {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::PeerConnectionState {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::New => 0.into_dart(),
            Self::Connecting => 1.into_dart(),
            Self::Connected => 2.into_dart(),
            Self::Disconnected => 3.into_dart(),
            Self::Failed => 4.into_dart(),
            Self::Closed => 5.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::PeerConnectionState
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::PeerConnectionState>
    for crate::api::PeerConnectionState
{
    fn into_into_dart(self) -> crate::api::PeerConnectionState {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::Protocol {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Tcp => 0.into_dart(),
            Self::Udp => 1.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::Protocol {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::Protocol> for crate::api::Protocol {
    fn into_into_dart(self) -> crate::api::Protocol {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::RtcConfiguration {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.ice_transport_policy.into_into_dart().into_dart(),
            self.bundle_policy.into_into_dart().into_dart(),
            self.ice_servers.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::RtcConfiguration {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::RtcConfiguration>
    for crate::api::RtcConfiguration
{
    fn into_into_dart(self) -> crate::api::RtcConfiguration {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::RtcIceCandidateStats {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::RtcIceCandidateStats::Local(field0) => {
                [0.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::RtcIceCandidateStats::Remote(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::RtcIceCandidateStats
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::RtcIceCandidateStats>
    for crate::api::RtcIceCandidateStats
{
    fn into_into_dart(self) -> crate::api::RtcIceCandidateStats {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::RtcIceServer {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.urls.into_into_dart().into_dart(),
            self.username.into_into_dart().into_dart(),
            self.credential.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::RtcIceServer {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::RtcIceServer> for crate::api::RtcIceServer {
    fn into_into_dart(self) -> crate::api::RtcIceServer {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::RtcInboundRtpStreamMediaType {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::RtcInboundRtpStreamMediaType::Audio {
                voice_activity_flag,
                total_samples_received,
                concealed_samples,
                silent_concealed_samples,
                audio_level,
                total_audio_energy,
                total_samples_duration,
            } => [
                0.into_dart(),
                voice_activity_flag.into_into_dart().into_dart(),
                total_samples_received.into_into_dart().into_dart(),
                concealed_samples.into_into_dart().into_dart(),
                silent_concealed_samples.into_into_dart().into_dart(),
                audio_level.into_into_dart().into_dart(),
                total_audio_energy.into_into_dart().into_dart(),
                total_samples_duration.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::RtcInboundRtpStreamMediaType::Video {
                frames_decoded,
                key_frames_decoded,
                frame_width,
                frame_height,
                total_inter_frame_delay,
                frames_per_second,
                fir_count,
                pli_count,
                sli_count,
                concealment_events,
                frames_received,
            } => [
                1.into_dart(),
                frames_decoded.into_into_dart().into_dart(),
                key_frames_decoded.into_into_dart().into_dart(),
                frame_width.into_into_dart().into_dart(),
                frame_height.into_into_dart().into_dart(),
                total_inter_frame_delay.into_into_dart().into_dart(),
                frames_per_second.into_into_dart().into_dart(),
                fir_count.into_into_dart().into_dart(),
                pli_count.into_into_dart().into_dart(),
                sli_count.into_into_dart().into_dart(),
                concealment_events.into_into_dart().into_dart(),
                frames_received.into_into_dart().into_dart(),
            ]
            .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::RtcInboundRtpStreamMediaType
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::RtcInboundRtpStreamMediaType>
    for crate::api::RtcInboundRtpStreamMediaType
{
    fn into_into_dart(self) -> crate::api::RtcInboundRtpStreamMediaType {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::RtcMediaSourceStatsMediaType {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::RtcMediaSourceStatsMediaType::RtcVideoSourceStats {
                width,
                height,
                frames,
                frames_per_second,
            } => [
                0.into_dart(),
                width.into_into_dart().into_dart(),
                height.into_into_dart().into_dart(),
                frames.into_into_dart().into_dart(),
                frames_per_second.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::RtcMediaSourceStatsMediaType::RtcAudioSourceStats {
                audio_level,
                total_audio_energy,
                total_samples_duration,
                echo_return_loss,
                echo_return_loss_enhancement,
            } => [
                1.into_dart(),
                audio_level.into_into_dart().into_dart(),
                total_audio_energy.into_into_dart().into_dart(),
                total_samples_duration.into_into_dart().into_dart(),
                echo_return_loss.into_into_dart().into_dart(),
                echo_return_loss_enhancement.into_into_dart().into_dart(),
            ]
            .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::RtcMediaSourceStatsMediaType
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::RtcMediaSourceStatsMediaType>
    for crate::api::RtcMediaSourceStatsMediaType
{
    fn into_into_dart(self) -> crate::api::RtcMediaSourceStatsMediaType {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::RtcOutboundRtpStreamStatsMediaType {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::RtcOutboundRtpStreamStatsMediaType::Audio {
                total_samples_sent,
                voice_activity_flag,
            } => [
                0.into_dart(),
                total_samples_sent.into_into_dart().into_dart(),
                voice_activity_flag.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::RtcOutboundRtpStreamStatsMediaType::Video {
                frame_width,
                frame_height,
                frames_per_second,
            } => [
                1.into_dart(),
                frame_width.into_into_dart().into_dart(),
                frame_height.into_into_dart().into_dart(),
                frames_per_second.into_into_dart().into_dart(),
            ]
            .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::RtcOutboundRtpStreamStatsMediaType
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::RtcOutboundRtpStreamStatsMediaType>
    for crate::api::RtcOutboundRtpStreamStatsMediaType
{
    fn into_into_dart(self) -> crate::api::RtcOutboundRtpStreamStatsMediaType {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::RtcRtpEncodingParameters {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.rid.into_into_dart().into_dart(),
            self.active.into_into_dart().into_dart(),
            self.max_bitrate.into_into_dart().into_dart(),
            self.max_framerate.into_into_dart().into_dart(),
            self.scale_resolution_down_by.into_into_dart().into_dart(),
            self.scalability_mode.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::RtcRtpEncodingParameters
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::RtcRtpEncodingParameters>
    for crate::api::RtcRtpEncodingParameters
{
    fn into_into_dart(self) -> crate::api::RtcRtpEncodingParameters {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::RtcRtpSendParameters {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.encodings.into_into_dart().into_dart(),
            self.inner.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::RtcRtpSendParameters
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::RtcRtpSendParameters>
    for crate::api::RtcRtpSendParameters
{
    fn into_into_dart(self) -> crate::api::RtcRtpSendParameters {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::RtcRtpTransceiver {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.peer.into_into_dart().into_dart(),
            self.transceiver.into_into_dart().into_dart(),
            self.mid.into_into_dart().into_dart(),
            self.direction.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::RtcRtpTransceiver {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::RtcRtpTransceiver>
    for crate::api::RtcRtpTransceiver
{
    fn into_into_dart(self) -> crate::api::RtcRtpTransceiver {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::RtcSessionDescription {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.sdp.into_into_dart().into_dart(),
            self.kind.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::RtcSessionDescription
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::RtcSessionDescription>
    for crate::api::RtcSessionDescription
{
    fn into_into_dart(self) -> crate::api::RtcSessionDescription {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::RtcStats {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.timestamp_us.into_into_dart().into_dart(),
            self.kind.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::RtcStats {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::RtcStats> for crate::api::RtcStats {
    fn into_into_dart(self) -> crate::api::RtcStats {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::RtcStatsIceCandidatePairState {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Frozen => 0.into_dart(),
            Self::Waiting => 1.into_dart(),
            Self::InProgress => 2.into_dart(),
            Self::Failed => 3.into_dart(),
            Self::Succeeded => 4.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::RtcStatsIceCandidatePairState
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::RtcStatsIceCandidatePairState>
    for crate::api::RtcStatsIceCandidatePairState
{
    fn into_into_dart(self) -> crate::api::RtcStatsIceCandidatePairState {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::RtcStatsType {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::RtcStatsType::RtcMediaSourceStats {
                track_identifier,
                kind,
            } => [
                0.into_dart(),
                track_identifier.into_into_dart().into_dart(),
                kind.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::RtcStatsType::RtcIceCandidateStats(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::RtcStatsType::RtcOutboundRtpStreamStats {
                track_id,
                media_type,
                bytes_sent,
                packets_sent,
                media_source_id,
            } => [
                2.into_dart(),
                track_id.into_into_dart().into_dart(),
                media_type.into_into_dart().into_dart(),
                bytes_sent.into_into_dart().into_dart(),
                packets_sent.into_into_dart().into_dart(),
                media_source_id.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::RtcStatsType::RtcInboundRtpStreamStats {
                remote_id,
                bytes_received,
                packets_received,
                packets_lost,
                jitter,
                total_decode_time,
                jitter_buffer_emitted_count,
                media_type,
            } => [
                3.into_dart(),
                remote_id.into_into_dart().into_dart(),
                bytes_received.into_into_dart().into_dart(),
                packets_received.into_into_dart().into_dart(),
                packets_lost.into_into_dart().into_dart(),
                jitter.into_into_dart().into_dart(),
                total_decode_time.into_into_dart().into_dart(),
                jitter_buffer_emitted_count.into_into_dart().into_dart(),
                media_type.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::RtcStatsType::RtcIceCandidatePairStats {
                state,
                nominated,
                bytes_sent,
                bytes_received,
                total_round_trip_time,
                current_round_trip_time,
                available_outgoing_bitrate,
            } => [
                4.into_dart(),
                state.into_into_dart().into_dart(),
                nominated.into_into_dart().into_dart(),
                bytes_sent.into_into_dart().into_dart(),
                bytes_received.into_into_dart().into_dart(),
                total_round_trip_time.into_into_dart().into_dart(),
                current_round_trip_time.into_into_dart().into_dart(),
                available_outgoing_bitrate.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::RtcStatsType::RtcTransportStats {
                packets_sent,
                packets_received,
                bytes_sent,
                bytes_received,
                ice_role,
            } => [
                5.into_dart(),
                packets_sent.into_into_dart().into_dart(),
                packets_received.into_into_dart().into_dart(),
                bytes_sent.into_into_dart().into_dart(),
                bytes_received.into_into_dart().into_dart(),
                ice_role.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::RtcStatsType::RtcRemoteInboundRtpStreamStats {
                local_id,
                jitter,
                round_trip_time,
                fraction_lost,
                reports_received,
                round_trip_time_measurements,
            } => [
                6.into_dart(),
                local_id.into_into_dart().into_dart(),
                jitter.into_into_dart().into_dart(),
                round_trip_time.into_into_dart().into_dart(),
                fraction_lost.into_into_dart().into_dart(),
                reports_received.into_into_dart().into_dart(),
                round_trip_time_measurements.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::RtcStatsType::RtcRemoteOutboundRtpStreamStats {
                local_id,
                remote_timestamp,
                reports_sent,
            } => [
                7.into_dart(),
                local_id.into_into_dart().into_dart(),
                remote_timestamp.into_into_dart().into_dart(),
                reports_sent.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::RtcStatsType::Unimplemented => [8.into_dart()].into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::RtcStatsType {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::RtcStatsType> for crate::api::RtcStatsType {
    fn into_into_dart(self) -> crate::api::RtcStatsType {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::RtcTrackEvent {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.track.into_into_dart().into_dart(),
            self.transceiver.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::RtcTrackEvent {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::RtcTrackEvent> for crate::api::RtcTrackEvent {
    fn into_into_dart(self) -> crate::api::RtcTrackEvent {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::RtcpFeedback {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.message_type.into_into_dart().into_dart(),
            self.kind.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::RtcpFeedback {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::RtcpFeedback> for crate::api::RtcpFeedback {
    fn into_into_dart(self) -> crate::api::RtcpFeedback {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::RtcpFeedbackMessageType {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::GenericNACK => 0.into_dart(),
            Self::Pli => 1.into_dart(),
            Self::Fir => 2.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::RtcpFeedbackMessageType
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::RtcpFeedbackMessageType>
    for crate::api::RtcpFeedbackMessageType
{
    fn into_into_dart(self) -> crate::api::RtcpFeedbackMessageType {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::RtcpFeedbackType {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Ccm => 0.into_dart(),
            Self::Lntf => 1.into_dart(),
            Self::Nack => 2.into_dart(),
            Self::Remb => 3.into_dart(),
            Self::TransportCC => 4.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::RtcpFeedbackType {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::RtcpFeedbackType>
    for crate::api::RtcpFeedbackType
{
    fn into_into_dart(self) -> crate::api::RtcpFeedbackType {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::RtpCapabilities {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.codecs.into_into_dart().into_dart(),
            self.header_extensions.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::RtpCapabilities {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::RtpCapabilities>
    for crate::api::RtpCapabilities
{
    fn into_into_dart(self) -> crate::api::RtpCapabilities {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::RtpCodecCapability {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.preferred_payload_type.into_into_dart().into_dart(),
            self.scalability_modes.into_into_dart().into_dart(),
            self.mime_type.into_into_dart().into_dart(),
            self.name.into_into_dart().into_dart(),
            self.kind.into_into_dart().into_dart(),
            self.clock_rate.into_into_dart().into_dart(),
            self.num_channels.into_into_dart().into_dart(),
            self.parameters.into_into_dart().into_dart(),
            self.feedback.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::RtpCodecCapability
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::RtpCodecCapability>
    for crate::api::RtpCodecCapability
{
    fn into_into_dart(self) -> crate::api::RtpCodecCapability {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::RtpHeaderExtensionCapability {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.uri.into_into_dart().into_dart(),
            self.preferred_id.into_into_dart().into_dart(),
            self.preferred_encrypted.into_into_dart().into_dart(),
            self.direction.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::RtpHeaderExtensionCapability
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::RtpHeaderExtensionCapability>
    for crate::api::RtpHeaderExtensionCapability
{
    fn into_into_dart(self) -> crate::api::RtpHeaderExtensionCapability {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::RtpTransceiverDirection {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::SendRecv => 0.into_dart(),
            Self::SendOnly => 1.into_dart(),
            Self::RecvOnly => 2.into_dart(),
            Self::Inactive => 3.into_dart(),
            Self::Stopped => 4.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::RtpTransceiverDirection
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::RtpTransceiverDirection>
    for crate::api::RtpTransceiverDirection
{
    fn into_into_dart(self) -> crate::api::RtpTransceiverDirection {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::RtpTransceiverInit {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.direction.into_into_dart().into_dart(),
            self.send_encodings.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::RtpTransceiverInit
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::RtpTransceiverInit>
    for crate::api::RtpTransceiverInit
{
    fn into_into_dart(self) -> crate::api::RtpTransceiverInit {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::ScalabilityMode {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::L1T1 => 0.into_dart(),
            Self::L1T2 => 1.into_dart(),
            Self::L1T3 => 2.into_dart(),
            Self::L2T1 => 3.into_dart(),
            Self::L2T1h => 4.into_dart(),
            Self::L2t1Key => 5.into_dart(),
            Self::L2T2 => 6.into_dart(),
            Self::L2T2h => 7.into_dart(),
            Self::L2T2Key => 8.into_dart(),
            Self::L2T2KeyShift => 9.into_dart(),
            Self::L2T3 => 10.into_dart(),
            Self::L2T3h => 11.into_dart(),
            Self::L2T3Key => 12.into_dart(),
            Self::L3T1 => 13.into_dart(),
            Self::L3T1h => 14.into_dart(),
            Self::L3T1Key => 15.into_dart(),
            Self::L3T2 => 16.into_dart(),
            Self::L3T2h => 17.into_dart(),
            Self::L3T2Key => 18.into_dart(),
            Self::L3T3 => 19.into_dart(),
            Self::L3T3h => 20.into_dart(),
            Self::L3T3Key => 21.into_dart(),
            Self::S2T1 => 22.into_dart(),
            Self::S2T1h => 23.into_dart(),
            Self::S2T2 => 24.into_dart(),
            Self::S2T2h => 25.into_dart(),
            Self::S2T3 => 26.into_dart(),
            Self::S2T3h => 27.into_dart(),
            Self::S3T1 => 28.into_dart(),
            Self::S3T1h => 29.into_dart(),
            Self::S3T2 => 30.into_dart(),
            Self::S3T2h => 31.into_dart(),
            Self::S3T3 => 32.into_dart(),
            Self::S3T3h => 33.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::ScalabilityMode {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::ScalabilityMode>
    for crate::api::ScalabilityMode
{
    fn into_into_dart(self) -> crate::api::ScalabilityMode {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::SdpType {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Offer => 0.into_dart(),
            Self::PrAnswer => 1.into_dart(),
            Self::Answer => 2.into_dart(),
            Self::Rollback => 3.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::SdpType {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::SdpType> for crate::api::SdpType {
    fn into_into_dart(self) -> crate::api::SdpType {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::SignalingState {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Stable => 0.into_dart(),
            Self::HaveLocalOffer => 1.into_dart(),
            Self::HaveLocalPrAnswer => 2.into_dart(),
            Self::HaveRemoteOffer => 3.into_dart(),
            Self::HaveRemotePrAnswer => 4.into_dart(),
            Self::Closed => 5.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::SignalingState {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::SignalingState> for crate::api::SignalingState {
    fn into_into_dart(self) -> crate::api::SignalingState {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::renderer::TextureEvent {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::renderer::TextureEvent::OnTextureChange {
                texture_id,
                width,
                height,
                rotation,
            } => [
                0.into_dart(),
                texture_id.into_into_dart().into_dart(),
                width.into_into_dart().into_dart(),
                height.into_into_dart().into_dart(),
                rotation.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::renderer::TextureEvent::OnFirstFrameRendered { texture_id } => {
                [1.into_dart(), texture_id.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::renderer::TextureEvent {}
impl flutter_rust_bridge::IntoIntoDart<crate::renderer::TextureEvent>
    for crate::renderer::TextureEvent
{
    fn into_into_dart(self) -> crate::renderer::TextureEvent {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::TrackEvent {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::TrackEvent::Ended => [0.into_dart()].into_dart(),
            crate::api::TrackEvent::AudioLevelUpdated(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::TrackEvent::TrackCreated => [2.into_dart()].into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::TrackEvent {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::TrackEvent> for crate::api::TrackEvent {
    fn into_into_dart(self) -> crate::api::TrackEvent {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::TrackState {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Live => 0.into_dart(),
            Self::Ended => 1.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::TrackState {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::TrackState> for crate::api::TrackState {
    fn into_into_dart(self) -> crate::api::TrackState {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::VideoCodec {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::AV1 => 0.into_dart(),
            Self::H264 => 1.into_dart(),
            Self::H265 => 2.into_dart(),
            Self::VP8 => 3.into_dart(),
            Self::VP9 => 4.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::VideoCodec {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::VideoCodec> for crate::api::VideoCodec {
    fn into_into_dart(self) -> crate::api::VideoCodec {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::VideoCodecInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.is_hardware_accelerated.into_into_dart().into_dart(),
            self.codec.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::VideoCodecInfo {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::VideoCodecInfo> for crate::api::VideoCodecInfo {
    fn into_into_dart(self) -> crate::api::VideoCodecInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::VideoConstraints {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.device_id.into_into_dart().into_dart(),
            self.width.into_into_dart().into_dart(),
            self.height.into_into_dart().into_dart(),
            self.frame_rate.into_into_dart().into_dart(),
            self.is_display.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::VideoConstraints {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::VideoConstraints>
    for crate::api::VideoConstraints
{
    fn into_into_dart(self) -> crate::api::VideoConstraints {
        self
    }
}

impl SseEncode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(format!("{:?}", self), serializer);
    }
}

impl SseEncode for RustOpaqueMoi<Arc<PeerConnection>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueMoi<Arc<RtpEncodingParameters>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueMoi<Arc<RtpParameters>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueMoi<Arc<RtpTransceiver>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for StreamSink<crate::api::PeerConnectionEvent, flutter_rust_bridge::for_generated::SseCodec>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        unimplemented!("")
    }
}

impl SseEncode
    for StreamSink<crate::renderer::TextureEvent, flutter_rust_bridge::for_generated::SseCodec>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        unimplemented!("")
    }
}

impl SseEncode
    for StreamSink<crate::api::TrackEvent, flutter_rust_bridge::for_generated::SseCodec>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        unimplemented!("")
    }
}

impl SseEncode for StreamSink<(), flutter_rust_bridge::for_generated::SseCodec> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        unimplemented!("")
    }
}

impl SseEncode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.into_bytes(), serializer);
    }
}

impl SseEncode for crate::api::AudioConstraints {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<String>>::sse_encode(self.device_id, serializer);
        <Option<bool>>::sse_encode(self.auto_gain_control, serializer);
    }
}

impl SseEncode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self as _).unwrap();
    }
}

impl SseEncode for crate::api::BundlePolicy {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::BundlePolicy::Balanced => 0,
                crate::api::BundlePolicy::MaxBundle => 1,
                crate::api::BundlePolicy::MaxCompat => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::CandidateType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::CandidateType::Host => 0,
                crate::api::CandidateType::Srflx => 1,
                crate::api::CandidateType::Prflx => 2,
                crate::api::CandidateType::Relay => 3,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for f64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_f64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for crate::api::GetMediaError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::GetMediaError::Audio(field0) => {
                <i32>::sse_encode(0, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::api::GetMediaError::Video(field0) => {
                <i32>::sse_encode(1, serializer);
                <String>::sse_encode(field0, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::GetMediaResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::GetMediaResult::Ok(field0) => {
                <i32>::sse_encode(0, serializer);
                <Vec<crate::api::MediaStreamTrack>>::sse_encode(field0, serializer);
            }
            crate::api::GetMediaResult::Err(field0) => {
                <i32>::sse_encode(1, serializer);
                <crate::api::GetMediaError>::sse_encode(field0, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for i64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for crate::api::IceCandidateStats {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<String>>::sse_encode(self.transport_id, serializer);
        <Option<String>>::sse_encode(self.address, serializer);
        <Option<i32>>::sse_encode(self.port, serializer);
        <crate::api::Protocol>::sse_encode(self.protocol, serializer);
        <crate::api::CandidateType>::sse_encode(self.candidate_type, serializer);
        <Option<i32>>::sse_encode(self.priority, serializer);
        <Option<String>>::sse_encode(self.url, serializer);
        <Option<crate::api::Protocol>>::sse_encode(self.relay_protocol, serializer);
    }
}

impl SseEncode for crate::api::IceConnectionState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::IceConnectionState::New => 0,
                crate::api::IceConnectionState::Checking => 1,
                crate::api::IceConnectionState::Connected => 2,
                crate::api::IceConnectionState::Completed => 3,
                crate::api::IceConnectionState::Failed => 4,
                crate::api::IceConnectionState::Disconnected => 5,
                crate::api::IceConnectionState::Closed => 6,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::IceGatheringState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::IceGatheringState::New => 0,
                crate::api::IceGatheringState::Gathering => 1,
                crate::api::IceGatheringState::Complete => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::IceRole {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::IceRole::Unknown => 0,
                crate::api::IceRole::Controlling => 1,
                crate::api::IceRole::Controlled => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::IceTransportsType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::IceTransportsType::All => 0,
                crate::api::IceTransportsType::Relay => 1,
                crate::api::IceTransportsType::NoHost => 2,
                crate::api::IceTransportsType::None => 3,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for Vec<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <String>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::MediaDeviceInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::MediaDeviceInfo>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::MediaDisplayInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::MediaDisplayInfo>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::MediaStreamTrack> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::MediaStreamTrack>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u8>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode
    for Vec<(
        crate::api::RtcRtpEncodingParameters,
        RustOpaqueMoi<Arc<RtpEncodingParameters>>,
    )>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(
                crate::api::RtcRtpEncodingParameters,
                RustOpaqueMoi<Arc<RtpEncodingParameters>>,
            )>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<(String, String)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(String, String)>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::RtcIceServer> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::RtcIceServer>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::RtcRtpEncodingParameters> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::RtcRtpEncodingParameters>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::RtcRtpTransceiver> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::RtcRtpTransceiver>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::RtcStats> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::RtcStats>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::RtcpFeedback> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::RtcpFeedback>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::RtpCodecCapability> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::RtpCodecCapability>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::RtpHeaderExtensionCapability> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::RtpHeaderExtensionCapability>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::ScalabilityMode> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::ScalabilityMode>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::VideoCodecInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::VideoCodecInfo>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for crate::api::MediaDeviceInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.device_id, serializer);
        <crate::api::MediaDeviceKind>::sse_encode(self.kind, serializer);
        <String>::sse_encode(self.label, serializer);
    }
}

impl SseEncode for crate::api::MediaDeviceKind {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::MediaDeviceKind::AudioInput => 0,
                crate::api::MediaDeviceKind::AudioOutput => 1,
                crate::api::MediaDeviceKind::VideoInput => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::MediaDisplayInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.device_id, serializer);
        <Option<String>>::sse_encode(self.title, serializer);
    }
}

impl SseEncode for crate::api::MediaStreamConstraints {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<crate::api::AudioConstraints>>::sse_encode(self.audio, serializer);
        <Option<crate::api::VideoConstraints>>::sse_encode(self.video, serializer);
    }
}

impl SseEncode for crate::api::MediaStreamTrack {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.id, serializer);
        <Option<u32>>::sse_encode(self.peer_id, serializer);
        <String>::sse_encode(self.device_id, serializer);
        <crate::api::MediaType>::sse_encode(self.kind, serializer);
        <bool>::sse_encode(self.enabled, serializer);
    }
}

impl SseEncode for crate::api::MediaType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::MediaType::Audio => 0,
                crate::api::MediaType::Video => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <String>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::AudioConstraints> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::AudioConstraints>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<bool> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <bool>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<f64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <f64>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<i32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <i32>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::IceRole> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::IceRole>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::Protocol> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::Protocol>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::RtcInboundRtpStreamMediaType> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::RtcInboundRtpStreamMediaType>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::RtcpFeedbackMessageType> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::RtcpFeedbackMessageType>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u32>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u64>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::VideoConstraints> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::VideoConstraints>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for crate::api::PeerConnectionEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::PeerConnectionEvent::PeerCreated { peer } => {
                <i32>::sse_encode(0, serializer);
                <RustOpaqueMoi<Arc<PeerConnection>>>::sse_encode(peer, serializer);
            }
            crate::api::PeerConnectionEvent::IceCandidate {
                sdp_mid,
                sdp_mline_index,
                candidate,
            } => {
                <i32>::sse_encode(1, serializer);
                <String>::sse_encode(sdp_mid, serializer);
                <i32>::sse_encode(sdp_mline_index, serializer);
                <String>::sse_encode(candidate, serializer);
            }
            crate::api::PeerConnectionEvent::IceGatheringStateChange(field0) => {
                <i32>::sse_encode(2, serializer);
                <crate::api::IceGatheringState>::sse_encode(field0, serializer);
            }
            crate::api::PeerConnectionEvent::IceCandidateError {
                address,
                port,
                url,
                error_code,
                error_text,
            } => {
                <i32>::sse_encode(3, serializer);
                <String>::sse_encode(address, serializer);
                <i32>::sse_encode(port, serializer);
                <String>::sse_encode(url, serializer);
                <i32>::sse_encode(error_code, serializer);
                <String>::sse_encode(error_text, serializer);
            }
            crate::api::PeerConnectionEvent::NegotiationNeeded => {
                <i32>::sse_encode(4, serializer);
            }
            crate::api::PeerConnectionEvent::SignallingChange(field0) => {
                <i32>::sse_encode(5, serializer);
                <crate::api::SignalingState>::sse_encode(field0, serializer);
            }
            crate::api::PeerConnectionEvent::IceConnectionStateChange(field0) => {
                <i32>::sse_encode(6, serializer);
                <crate::api::IceConnectionState>::sse_encode(field0, serializer);
            }
            crate::api::PeerConnectionEvent::ConnectionStateChange(field0) => {
                <i32>::sse_encode(7, serializer);
                <crate::api::PeerConnectionState>::sse_encode(field0, serializer);
            }
            crate::api::PeerConnectionEvent::Track(field0) => {
                <i32>::sse_encode(8, serializer);
                <crate::api::RtcTrackEvent>::sse_encode(field0, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::PeerConnectionState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::PeerConnectionState::New => 0,
                crate::api::PeerConnectionState::Connecting => 1,
                crate::api::PeerConnectionState::Connected => 2,
                crate::api::PeerConnectionState::Disconnected => 3,
                crate::api::PeerConnectionState::Failed => 4,
                crate::api::PeerConnectionState::Closed => 5,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::Protocol {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::Protocol::Tcp => 0,
                crate::api::Protocol::Udp => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode
    for (
        crate::api::RtcRtpEncodingParameters,
        RustOpaqueMoi<Arc<RtpEncodingParameters>>,
    )
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::RtcRtpEncodingParameters>::sse_encode(self.0, serializer);
        <RustOpaqueMoi<Arc<RtpEncodingParameters>>>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for (String, String) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.0, serializer);
        <String>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for crate::api::RtcConfiguration {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::IceTransportsType>::sse_encode(self.ice_transport_policy, serializer);
        <crate::api::BundlePolicy>::sse_encode(self.bundle_policy, serializer);
        <Vec<crate::api::RtcIceServer>>::sse_encode(self.ice_servers, serializer);
    }
}

impl SseEncode for crate::api::RtcIceCandidateStats {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::RtcIceCandidateStats::Local(field0) => {
                <i32>::sse_encode(0, serializer);
                <crate::api::IceCandidateStats>::sse_encode(field0, serializer);
            }
            crate::api::RtcIceCandidateStats::Remote(field0) => {
                <i32>::sse_encode(1, serializer);
                <crate::api::IceCandidateStats>::sse_encode(field0, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::RtcIceServer {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<String>>::sse_encode(self.urls, serializer);
        <String>::sse_encode(self.username, serializer);
        <String>::sse_encode(self.credential, serializer);
    }
}

impl SseEncode for crate::api::RtcInboundRtpStreamMediaType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::RtcInboundRtpStreamMediaType::Audio {
                voice_activity_flag,
                total_samples_received,
                concealed_samples,
                silent_concealed_samples,
                audio_level,
                total_audio_energy,
                total_samples_duration,
            } => {
                <i32>::sse_encode(0, serializer);
                <Option<bool>>::sse_encode(voice_activity_flag, serializer);
                <Option<u64>>::sse_encode(total_samples_received, serializer);
                <Option<u64>>::sse_encode(concealed_samples, serializer);
                <Option<u64>>::sse_encode(silent_concealed_samples, serializer);
                <Option<f64>>::sse_encode(audio_level, serializer);
                <Option<f64>>::sse_encode(total_audio_energy, serializer);
                <Option<f64>>::sse_encode(total_samples_duration, serializer);
            }
            crate::api::RtcInboundRtpStreamMediaType::Video {
                frames_decoded,
                key_frames_decoded,
                frame_width,
                frame_height,
                total_inter_frame_delay,
                frames_per_second,
                fir_count,
                pli_count,
                sli_count,
                concealment_events,
                frames_received,
            } => {
                <i32>::sse_encode(1, serializer);
                <Option<u32>>::sse_encode(frames_decoded, serializer);
                <Option<u32>>::sse_encode(key_frames_decoded, serializer);
                <Option<u32>>::sse_encode(frame_width, serializer);
                <Option<u32>>::sse_encode(frame_height, serializer);
                <Option<f64>>::sse_encode(total_inter_frame_delay, serializer);
                <Option<f64>>::sse_encode(frames_per_second, serializer);
                <Option<u32>>::sse_encode(fir_count, serializer);
                <Option<u32>>::sse_encode(pli_count, serializer);
                <Option<u32>>::sse_encode(sli_count, serializer);
                <Option<u64>>::sse_encode(concealment_events, serializer);
                <Option<i32>>::sse_encode(frames_received, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::RtcMediaSourceStatsMediaType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::RtcMediaSourceStatsMediaType::RtcVideoSourceStats {
                width,
                height,
                frames,
                frames_per_second,
            } => {
                <i32>::sse_encode(0, serializer);
                <Option<u32>>::sse_encode(width, serializer);
                <Option<u32>>::sse_encode(height, serializer);
                <Option<u32>>::sse_encode(frames, serializer);
                <Option<f64>>::sse_encode(frames_per_second, serializer);
            }
            crate::api::RtcMediaSourceStatsMediaType::RtcAudioSourceStats {
                audio_level,
                total_audio_energy,
                total_samples_duration,
                echo_return_loss,
                echo_return_loss_enhancement,
            } => {
                <i32>::sse_encode(1, serializer);
                <Option<f64>>::sse_encode(audio_level, serializer);
                <Option<f64>>::sse_encode(total_audio_energy, serializer);
                <Option<f64>>::sse_encode(total_samples_duration, serializer);
                <Option<f64>>::sse_encode(echo_return_loss, serializer);
                <Option<f64>>::sse_encode(echo_return_loss_enhancement, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::RtcOutboundRtpStreamStatsMediaType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::RtcOutboundRtpStreamStatsMediaType::Audio {
                total_samples_sent,
                voice_activity_flag,
            } => {
                <i32>::sse_encode(0, serializer);
                <Option<u64>>::sse_encode(total_samples_sent, serializer);
                <Option<bool>>::sse_encode(voice_activity_flag, serializer);
            }
            crate::api::RtcOutboundRtpStreamStatsMediaType::Video {
                frame_width,
                frame_height,
                frames_per_second,
            } => {
                <i32>::sse_encode(1, serializer);
                <Option<u32>>::sse_encode(frame_width, serializer);
                <Option<u32>>::sse_encode(frame_height, serializer);
                <Option<f64>>::sse_encode(frames_per_second, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::RtcRtpEncodingParameters {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.rid, serializer);
        <bool>::sse_encode(self.active, serializer);
        <Option<i32>>::sse_encode(self.max_bitrate, serializer);
        <Option<f64>>::sse_encode(self.max_framerate, serializer);
        <Option<f64>>::sse_encode(self.scale_resolution_down_by, serializer);
        <Option<String>>::sse_encode(self.scalability_mode, serializer);
    }
}

impl SseEncode for crate::api::RtcRtpSendParameters {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<(
            crate::api::RtcRtpEncodingParameters,
            RustOpaqueMoi<Arc<RtpEncodingParameters>>,
        )>>::sse_encode(self.encodings, serializer);
        <RustOpaqueMoi<Arc<RtpParameters>>>::sse_encode(self.inner, serializer);
    }
}

impl SseEncode for crate::api::RtcRtpTransceiver {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<Arc<PeerConnection>>>::sse_encode(self.peer, serializer);
        <RustOpaqueMoi<Arc<RtpTransceiver>>>::sse_encode(self.transceiver, serializer);
        <Option<String>>::sse_encode(self.mid, serializer);
        <crate::api::RtpTransceiverDirection>::sse_encode(self.direction, serializer);
    }
}

impl SseEncode for crate::api::RtcSessionDescription {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.sdp, serializer);
        <crate::api::SdpType>::sse_encode(self.kind, serializer);
    }
}

impl SseEncode for crate::api::RtcStats {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.id, serializer);
        <i64>::sse_encode(self.timestamp_us, serializer);
        <crate::api::RtcStatsType>::sse_encode(self.kind, serializer);
    }
}

impl SseEncode for crate::api::RtcStatsIceCandidatePairState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::RtcStatsIceCandidatePairState::Frozen => 0,
                crate::api::RtcStatsIceCandidatePairState::Waiting => 1,
                crate::api::RtcStatsIceCandidatePairState::InProgress => 2,
                crate::api::RtcStatsIceCandidatePairState::Failed => 3,
                crate::api::RtcStatsIceCandidatePairState::Succeeded => 4,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::RtcStatsType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::RtcStatsType::RtcMediaSourceStats {
                track_identifier,
                kind,
            } => {
                <i32>::sse_encode(0, serializer);
                <Option<String>>::sse_encode(track_identifier, serializer);
                <crate::api::RtcMediaSourceStatsMediaType>::sse_encode(kind, serializer);
            }
            crate::api::RtcStatsType::RtcIceCandidateStats(field0) => {
                <i32>::sse_encode(1, serializer);
                <crate::api::RtcIceCandidateStats>::sse_encode(field0, serializer);
            }
            crate::api::RtcStatsType::RtcOutboundRtpStreamStats {
                track_id,
                media_type,
                bytes_sent,
                packets_sent,
                media_source_id,
            } => {
                <i32>::sse_encode(2, serializer);
                <Option<String>>::sse_encode(track_id, serializer);
                <crate::api::RtcOutboundRtpStreamStatsMediaType>::sse_encode(
                    media_type, serializer,
                );
                <Option<u64>>::sse_encode(bytes_sent, serializer);
                <Option<u32>>::sse_encode(packets_sent, serializer);
                <Option<String>>::sse_encode(media_source_id, serializer);
            }
            crate::api::RtcStatsType::RtcInboundRtpStreamStats {
                remote_id,
                bytes_received,
                packets_received,
                packets_lost,
                jitter,
                total_decode_time,
                jitter_buffer_emitted_count,
                media_type,
            } => {
                <i32>::sse_encode(3, serializer);
                <Option<String>>::sse_encode(remote_id, serializer);
                <Option<u64>>::sse_encode(bytes_received, serializer);
                <Option<u32>>::sse_encode(packets_received, serializer);
                <Option<u64>>::sse_encode(packets_lost, serializer);
                <Option<f64>>::sse_encode(jitter, serializer);
                <Option<f64>>::sse_encode(total_decode_time, serializer);
                <Option<u64>>::sse_encode(jitter_buffer_emitted_count, serializer);
                <Option<crate::api::RtcInboundRtpStreamMediaType>>::sse_encode(
                    media_type, serializer,
                );
            }
            crate::api::RtcStatsType::RtcIceCandidatePairStats {
                state,
                nominated,
                bytes_sent,
                bytes_received,
                total_round_trip_time,
                current_round_trip_time,
                available_outgoing_bitrate,
            } => {
                <i32>::sse_encode(4, serializer);
                <crate::api::RtcStatsIceCandidatePairState>::sse_encode(state, serializer);
                <Option<bool>>::sse_encode(nominated, serializer);
                <Option<u64>>::sse_encode(bytes_sent, serializer);
                <Option<u64>>::sse_encode(bytes_received, serializer);
                <Option<f64>>::sse_encode(total_round_trip_time, serializer);
                <Option<f64>>::sse_encode(current_round_trip_time, serializer);
                <Option<f64>>::sse_encode(available_outgoing_bitrate, serializer);
            }
            crate::api::RtcStatsType::RtcTransportStats {
                packets_sent,
                packets_received,
                bytes_sent,
                bytes_received,
                ice_role,
            } => {
                <i32>::sse_encode(5, serializer);
                <Option<u64>>::sse_encode(packets_sent, serializer);
                <Option<u64>>::sse_encode(packets_received, serializer);
                <Option<u64>>::sse_encode(bytes_sent, serializer);
                <Option<u64>>::sse_encode(bytes_received, serializer);
                <Option<crate::api::IceRole>>::sse_encode(ice_role, serializer);
            }
            crate::api::RtcStatsType::RtcRemoteInboundRtpStreamStats {
                local_id,
                jitter,
                round_trip_time,
                fraction_lost,
                reports_received,
                round_trip_time_measurements,
            } => {
                <i32>::sse_encode(6, serializer);
                <Option<String>>::sse_encode(local_id, serializer);
                <Option<f64>>::sse_encode(jitter, serializer);
                <Option<f64>>::sse_encode(round_trip_time, serializer);
                <Option<f64>>::sse_encode(fraction_lost, serializer);
                <Option<u64>>::sse_encode(reports_received, serializer);
                <Option<i32>>::sse_encode(round_trip_time_measurements, serializer);
            }
            crate::api::RtcStatsType::RtcRemoteOutboundRtpStreamStats {
                local_id,
                remote_timestamp,
                reports_sent,
            } => {
                <i32>::sse_encode(7, serializer);
                <Option<String>>::sse_encode(local_id, serializer);
                <Option<f64>>::sse_encode(remote_timestamp, serializer);
                <Option<u64>>::sse_encode(reports_sent, serializer);
            }
            crate::api::RtcStatsType::Unimplemented => {
                <i32>::sse_encode(8, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::RtcTrackEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::MediaStreamTrack>::sse_encode(self.track, serializer);
        <crate::api::RtcRtpTransceiver>::sse_encode(self.transceiver, serializer);
    }
}

impl SseEncode for crate::api::RtcpFeedback {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<crate::api::RtcpFeedbackMessageType>>::sse_encode(self.message_type, serializer);
        <crate::api::RtcpFeedbackType>::sse_encode(self.kind, serializer);
    }
}

impl SseEncode for crate::api::RtcpFeedbackMessageType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::RtcpFeedbackMessageType::GenericNACK => 0,
                crate::api::RtcpFeedbackMessageType::Pli => 1,
                crate::api::RtcpFeedbackMessageType::Fir => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::RtcpFeedbackType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::RtcpFeedbackType::Ccm => 0,
                crate::api::RtcpFeedbackType::Lntf => 1,
                crate::api::RtcpFeedbackType::Nack => 2,
                crate::api::RtcpFeedbackType::Remb => 3,
                crate::api::RtcpFeedbackType::TransportCC => 4,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::RtpCapabilities {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<crate::api::RtpCodecCapability>>::sse_encode(self.codecs, serializer);
        <Vec<crate::api::RtpHeaderExtensionCapability>>::sse_encode(
            self.header_extensions,
            serializer,
        );
    }
}

impl SseEncode for crate::api::RtpCodecCapability {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<i32>>::sse_encode(self.preferred_payload_type, serializer);
        <Vec<crate::api::ScalabilityMode>>::sse_encode(self.scalability_modes, serializer);
        <String>::sse_encode(self.mime_type, serializer);
        <String>::sse_encode(self.name, serializer);
        <crate::api::MediaType>::sse_encode(self.kind, serializer);
        <Option<i32>>::sse_encode(self.clock_rate, serializer);
        <Option<i32>>::sse_encode(self.num_channels, serializer);
        <Vec<(String, String)>>::sse_encode(self.parameters, serializer);
        <Vec<crate::api::RtcpFeedback>>::sse_encode(self.feedback, serializer);
    }
}

impl SseEncode for crate::api::RtpHeaderExtensionCapability {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.uri, serializer);
        <Option<i32>>::sse_encode(self.preferred_id, serializer);
        <bool>::sse_encode(self.preferred_encrypted, serializer);
        <crate::api::RtpTransceiverDirection>::sse_encode(self.direction, serializer);
    }
}

impl SseEncode for crate::api::RtpTransceiverDirection {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::RtpTransceiverDirection::SendRecv => 0,
                crate::api::RtpTransceiverDirection::SendOnly => 1,
                crate::api::RtpTransceiverDirection::RecvOnly => 2,
                crate::api::RtpTransceiverDirection::Inactive => 3,
                crate::api::RtpTransceiverDirection::Stopped => 4,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::RtpTransceiverInit {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::RtpTransceiverDirection>::sse_encode(self.direction, serializer);
        <Vec<crate::api::RtcRtpEncodingParameters>>::sse_encode(self.send_encodings, serializer);
    }
}

impl SseEncode for crate::api::ScalabilityMode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::ScalabilityMode::L1T1 => 0,
                crate::api::ScalabilityMode::L1T2 => 1,
                crate::api::ScalabilityMode::L1T3 => 2,
                crate::api::ScalabilityMode::L2T1 => 3,
                crate::api::ScalabilityMode::L2T1h => 4,
                crate::api::ScalabilityMode::L2t1Key => 5,
                crate::api::ScalabilityMode::L2T2 => 6,
                crate::api::ScalabilityMode::L2T2h => 7,
                crate::api::ScalabilityMode::L2T2Key => 8,
                crate::api::ScalabilityMode::L2T2KeyShift => 9,
                crate::api::ScalabilityMode::L2T3 => 10,
                crate::api::ScalabilityMode::L2T3h => 11,
                crate::api::ScalabilityMode::L2T3Key => 12,
                crate::api::ScalabilityMode::L3T1 => 13,
                crate::api::ScalabilityMode::L3T1h => 14,
                crate::api::ScalabilityMode::L3T1Key => 15,
                crate::api::ScalabilityMode::L3T2 => 16,
                crate::api::ScalabilityMode::L3T2h => 17,
                crate::api::ScalabilityMode::L3T2Key => 18,
                crate::api::ScalabilityMode::L3T3 => 19,
                crate::api::ScalabilityMode::L3T3h => 20,
                crate::api::ScalabilityMode::L3T3Key => 21,
                crate::api::ScalabilityMode::S2T1 => 22,
                crate::api::ScalabilityMode::S2T1h => 23,
                crate::api::ScalabilityMode::S2T2 => 24,
                crate::api::ScalabilityMode::S2T2h => 25,
                crate::api::ScalabilityMode::S2T3 => 26,
                crate::api::ScalabilityMode::S2T3h => 27,
                crate::api::ScalabilityMode::S3T1 => 28,
                crate::api::ScalabilityMode::S3T1h => 29,
                crate::api::ScalabilityMode::S3T2 => 30,
                crate::api::ScalabilityMode::S3T2h => 31,
                crate::api::ScalabilityMode::S3T3 => 32,
                crate::api::ScalabilityMode::S3T3h => 33,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::SdpType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::SdpType::Offer => 0,
                crate::api::SdpType::PrAnswer => 1,
                crate::api::SdpType::Answer => 2,
                crate::api::SdpType::Rollback => 3,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::SignalingState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::SignalingState::Stable => 0,
                crate::api::SignalingState::HaveLocalOffer => 1,
                crate::api::SignalingState::HaveLocalPrAnswer => 2,
                crate::api::SignalingState::HaveRemoteOffer => 3,
                crate::api::SignalingState::HaveRemotePrAnswer => 4,
                crate::api::SignalingState::Closed => 5,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::renderer::TextureEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::renderer::TextureEvent::OnTextureChange {
                texture_id,
                width,
                height,
                rotation,
            } => {
                <i32>::sse_encode(0, serializer);
                <i64>::sse_encode(texture_id, serializer);
                <i32>::sse_encode(width, serializer);
                <i32>::sse_encode(height, serializer);
                <i32>::sse_encode(rotation, serializer);
            }
            crate::renderer::TextureEvent::OnFirstFrameRendered { texture_id } => {
                <i32>::sse_encode(1, serializer);
                <i64>::sse_encode(texture_id, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::TrackEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::TrackEvent::Ended => {
                <i32>::sse_encode(0, serializer);
            }
            crate::api::TrackEvent::AudioLevelUpdated(field0) => {
                <i32>::sse_encode(1, serializer);
                <u32>::sse_encode(field0, serializer);
            }
            crate::api::TrackEvent::TrackCreated => {
                <i32>::sse_encode(2, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::TrackState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::TrackState::Live => 0,
                crate::api::TrackState::Ended => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self).unwrap();
    }
}

impl SseEncode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer
            .cursor
            .write_u64::<NativeEndian>(self as _)
            .unwrap();
    }
}

impl SseEncode for crate::api::VideoCodec {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::VideoCodec::AV1 => 0,
                crate::api::VideoCodec::H264 => 1,
                crate::api::VideoCodec::H265 => 2,
                crate::api::VideoCodec::VP8 => 3,
                crate::api::VideoCodec::VP9 => 4,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::VideoCodecInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_hardware_accelerated, serializer);
        <crate::api::VideoCodec>::sse_encode(self.codec, serializer);
    }
}

impl SseEncode for crate::api::VideoConstraints {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<String>>::sse_encode(self.device_id, serializer);
        <u32>::sse_encode(self.width, serializer);
        <u32>::sse_encode(self.height, serializer);
        <u32>::sse_encode(self.frame_rate, serializer);
        <bool>::sse_encode(self.is_display, serializer);
    }
}

#[cfg(not(target_family = "wasm"))]
mod io {
    // This file is automatically generated, so please do not edit it.
    // @generated by `flutter_rust_bridge`@ 2.7.0.

    // Section: imports

    use super::*;
    use crate::*;
    use flutter_rust_bridge::for_generated::byteorder::{
        NativeEndian, ReadBytesExt, WriteBytesExt,
    };
    use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
    use flutter_rust_bridge::{Handler, IntoIntoDart};

    // Section: boilerplate

    flutter_rust_bridge::frb_generated_boilerplate_io!();

    #[no_mangle]
    pub extern "C" fn frbgen_medea_flutter_webrtc_rust_arc_increment_strong_count_RustOpaque_ArcPeerConnection(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<Arc<PeerConnection>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_medea_flutter_webrtc_rust_arc_decrement_strong_count_RustOpaque_ArcPeerConnection(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<Arc<PeerConnection>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_medea_flutter_webrtc_rust_arc_increment_strong_count_RustOpaque_ArcRtpEncodingParameters(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<Arc<RtpEncodingParameters>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_medea_flutter_webrtc_rust_arc_decrement_strong_count_RustOpaque_ArcRtpEncodingParameters(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<Arc<RtpEncodingParameters>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_medea_flutter_webrtc_rust_arc_increment_strong_count_RustOpaque_ArcRtpParameters(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<Arc<RtpParameters>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_medea_flutter_webrtc_rust_arc_decrement_strong_count_RustOpaque_ArcRtpParameters(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<Arc<RtpParameters>>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_medea_flutter_webrtc_rust_arc_increment_strong_count_RustOpaque_ArcRtpTransceiver(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<Arc<RtpTransceiver>>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_medea_flutter_webrtc_rust_arc_decrement_strong_count_RustOpaque_ArcRtpTransceiver(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<Arc<RtpTransceiver>>::decrement_strong_count(ptr as _);
    }
}
#[cfg(not(target_family = "wasm"))]
pub use io::*;
