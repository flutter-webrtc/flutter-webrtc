// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.10.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;

import '../api.dart';
import '../frb_generated.dart';
import '../renderer.dart';
import 'media_stream_track/audio_processing_config.dart';
import 'media_stream_track/media_type.dart';
import 'media_stream_track/track_event.dart';
import 'media_stream_track/track_state.dart';

part 'media_stream_track.freezed.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `fmt`

/// Creates a [MediaStream] with tracks according to provided
/// [`MediaStreamConstraints`].
///
/// [MediaStream]: https://w3.org/TR/mediacapture-streams#dom-mediastream
Future<GetMediaResult> getMedia({
  required MediaStreamConstraints constraints,
}) => RustLib.instance.api.crateApiMediaStreamTrackGetMedia(
  constraints: constraints,
);

/// Disposes the specified [`MediaStreamTrack`].
Future<void> disposeTrack({
  required String trackId,
  int? peerId,
  required MediaType kind,
}) => RustLib.instance.api.crateApiMediaStreamTrackDisposeTrack(
  trackId: trackId,
  peerId: peerId,
  kind: kind,
);

/// Returns the [readyState][0] property of the [`MediaStreamTrack`] by its ID
/// and [`MediaType`].
///
/// [0]: https://w3.org/TR/mediacapture-streams#dfn-readystate
Future<TrackState> trackState({
  required String trackId,
  int? peerId,
  required MediaType kind,
}) => RustLib.instance.api.crateApiMediaStreamTrackTrackState(
  trackId: trackId,
  peerId: peerId,
  kind: kind,
);

/// Returns the [height] property of the media track by its ID and
/// [`MediaType`].
///
/// Blocks until the [height] is initialized.
///
/// [height]: https://w3.org/TR/mediacapture-streams#dfn-height
Future<int?> trackHeight({
  required String trackId,
  int? peerId,
  required MediaType kind,
}) => RustLib.instance.api.crateApiMediaStreamTrackTrackHeight(
  trackId: trackId,
  peerId: peerId,
  kind: kind,
);

/// Returns the [width] property of the media track by its ID and [`MediaType`].
///
/// Blocks until the [width] is initialized.
///
/// [width]: https://w3.org/TR/mediacapture-streams#dfn-height
Future<int?> trackWidth({
  required String trackId,
  int? peerId,
  required MediaType kind,
}) => RustLib.instance.api.crateApiMediaStreamTrackTrackWidth(
  trackId: trackId,
  peerId: peerId,
  kind: kind,
);

/// Changes the [enabled][1] property of the [`MediaStreamTrack`] by its ID and
/// [`MediaType`].
///
/// [1]: https://w3.org/TR/mediacapture-streams#track-enabled
Future<void> setTrackEnabled({
  required String trackId,
  int? peerId,
  required MediaType kind,
  required bool enabled,
}) => RustLib.instance.api.crateApiMediaStreamTrackSetTrackEnabled(
  trackId: trackId,
  peerId: peerId,
  kind: kind,
  enabled: enabled,
);

/// Clones the specified [`MediaStreamTrack`].
Future<MediaStreamTrack?> cloneTrack({
  required String trackId,
  int? peerId,
  required MediaType kind,
}) => RustLib.instance.api.crateApiMediaStreamTrackCloneTrack(
  trackId: trackId,
  peerId: peerId,
  kind: kind,
);

/// Registers an observer to the [`MediaStreamTrack`] events.
Stream<TrackEvent> registerTrackObserver({
  int? peerId,
  required String trackId,
  required MediaType kind,
}) => RustLib.instance.api.crateApiMediaStreamTrackRegisterTrackObserver(
  peerId: peerId,
  trackId: trackId,
  kind: kind,
);

/// Enables or disables audio level observing of the audio [`MediaStreamTrack`]
/// with the provided `track_id`.
Future<void> setAudioLevelObserverEnabled({
  required String trackId,
  int? peerId,
  required bool enabled,
}) => RustLib.instance.api.crateApiMediaStreamTrackSetAudioLevelObserverEnabled(
  trackId: trackId,
  peerId: peerId,
  enabled: enabled,
);

/// Applies the provided [`AudioProcessingConstraints`] to specified local audio
/// track.
Future<void> updateAudioProcessing({
  required String trackId,
  required AudioProcessingConstraints conf,
}) => RustLib.instance.api.crateApiMediaStreamTrackUpdateAudioProcessing(
  trackId: trackId,
  conf: conf,
);

/// Creates a new [`VideoSink`] attached to the specified video track.
///
/// `callback_ptr` argument should be a pointer to an [`UniquePtr`] pointing to
/// an [`sys::OnFrameCallback`].
///
/// [`UniquePtr`]: cxx::UniquePtr
/// [`VideoSink`]: crate::VideoSink
Stream<TextureEvent> createVideoSink({
  required PlatformInt64 sinkId,
  int? peerId,
  required String trackId,
  required PlatformInt64 callbackPtr,
  required PlatformInt64 textureId,
}) => RustLib.instance.api.crateApiMediaStreamTrackCreateVideoSink(
  sinkId: sinkId,
  peerId: peerId,
  trackId: trackId,
  callbackPtr: callbackPtr,
  textureId: textureId,
);

/// Destroys a [`VideoSink`] by the provided ID.
///
/// [`VideoSink`]: crate::VideoSink
Future<void> disposeVideoSink({required PlatformInt64 sinkId}) => RustLib
    .instance
    .api
    .crateApiMediaStreamTrackDisposeVideoSink(sinkId: sinkId);

@freezed
sealed class GetMediaError with _$GetMediaError {
  const GetMediaError._();

  /// Could not acquire audio track.
  const factory GetMediaError.audio(String field0) = GetMediaError_Audio;

  /// Could not acquire video track.
  const factory GetMediaError.video(String field0) = GetMediaError_Video;
}

@freezed
sealed class GetMediaResult with _$GetMediaResult {
  const GetMediaResult._();

  /// Requested media tracks.
  const factory GetMediaResult.ok(List<MediaStreamTrack> field0) =
      GetMediaResult_Ok;

  /// Failed to get requested media.
  const factory GetMediaResult.err(GetMediaError field0) = GetMediaResult_Err;
}

/// Representation of a single media track within a [MediaStream].
///
/// Typically, these are audio or video tracks, but other track types may exist
/// as well.
///
/// [MediaStream]: https://w3.org/TR/mediacapture-streams#dom-mediastream
class MediaStreamTrack {
  /// Unique identifier (GUID) of this [`MediaStreamTrack`].
  final String id;

  /// Unique identifier of the [`PeerConnection`] from which this
  /// [`MediaStreamTrack`] was received.
  ///
  /// Always [`None`] for local [`MediaStreamTrack`]s.
  final int? peerId;

  /// Label identifying the track source, as in "internal microphone".
  final String deviceId;

  /// [`MediaType`] of this [`MediaStreamTrack`].
  final MediaType kind;

  /// Indicator whether this [`MediaStreamTrack`] is allowed to render the
  /// source stream.
  ///
  /// This can be used to intentionally mute a track.
  final bool enabled;

  const MediaStreamTrack({
    required this.id,
    this.peerId,
    required this.deviceId,
    required this.kind,
    required this.enabled,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      peerId.hashCode ^
      deviceId.hashCode ^
      kind.hashCode ^
      enabled.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MediaStreamTrack &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          peerId == other.peerId &&
          deviceId == other.deviceId &&
          kind == other.kind &&
          enabled == other.enabled;
}
