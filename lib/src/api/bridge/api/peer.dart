// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.10.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

import '../frb_generated.dart';
import '../lib.dart';
import 'media_stream_track.dart';
import 'media_stream_track/media_type.dart';
import 'peer/events.dart';
import 'peer/events/ice_connection_state.dart';
import 'peer/events/ice_gathering_state.dart';
import 'peer/events/peer_connection_state.dart';
import 'peer/events/rtc_track_event.dart';
import 'peer/events/signaling_state.dart';
import 'peer/rtc_configuration.dart';
import 'peer/rtc_configuration/bundle_policy.dart';
import 'peer/rtc_configuration/ice_transports_type.dart';
import 'peer/rtc_configuration/rtc_ice_server.dart';
import 'peer/rtc_session_description.dart';
import 'transceiver.dart';
import 'transceiver/direction.dart';

/// Creates a new [`PeerConnection`] and returns its ID.
Stream<PeerConnectionEvent> createPeerConnection({
  required RtcConfiguration configuration,
}) => RustLib.instance.api.crateApiPeerCreatePeerConnection(
  configuration: configuration,
);

/// Initiates the creation of an SDP offer for the purpose of starting a new
/// WebRTC connection to a remote peer.
Future<RtcSessionDescription> createOffer({
  required ArcPeerConnection peer,
  required bool voiceActivityDetection,
  required bool iceRestart,
  required bool useRtpMux,
}) => RustLib.instance.api.crateApiPeerCreateOffer(
  peer: peer,
  voiceActivityDetection: voiceActivityDetection,
  iceRestart: iceRestart,
  useRtpMux: useRtpMux,
);

/// Creates an SDP answer to an offer received from a remote peer during an
/// offer/answer negotiation of a WebRTC connection.
Future<RtcSessionDescription> createAnswer({
  required ArcPeerConnection peer,
  required bool voiceActivityDetection,
  required bool iceRestart,
  required bool useRtpMux,
}) => RustLib.instance.api.crateApiPeerCreateAnswer(
  peer: peer,
  voiceActivityDetection: voiceActivityDetection,
  iceRestart: iceRestart,
  useRtpMux: useRtpMux,
);

/// Adds the new ICE `candidate` to the given [`PeerConnection`].
Future<void> addIceCandidate({
  required ArcPeerConnection peer,
  required String candidate,
  required String sdpMid,
  required int sdpMlineIndex,
}) => RustLib.instance.api.crateApiPeerAddIceCandidate(
  peer: peer,
  candidate: candidate,
  sdpMid: sdpMid,
  sdpMlineIndex: sdpMlineIndex,
);

/// Closes the [`PeerConnection`].
Future<void> disposePeerConnection({required ArcPeerConnection peer}) =>
    RustLib.instance.api.crateApiPeerDisposePeerConnection(peer: peer);

/// Tells the [`PeerConnection`] that ICE should be restarted.
Future<void> restartIce({required ArcPeerConnection peer}) =>
    RustLib.instance.api.crateApiPeerRestartIce(peer: peer);
