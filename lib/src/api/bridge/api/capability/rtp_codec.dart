// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

import '../../frb_generated.dart';
import '../../lib.dart';
import '../media_stream_track/media_type.dart';
import 'rtp_codec/rtcp_feedback.dart';
import 'rtp_codec/scalability_mode.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `fmt`, `from`

/// Changes the preferred [`RtpTransceiver`] codecs to the provided
/// [`Vec`]`<`[`RtpCodecCapability`]`>`.
Future<void> setCodecPreferences({
  required ArcRtpTransceiver transceiver,
  required List<RtpCodecCapability> codecs,
}) => RustLib.instance.api.crateApiCapabilityRtpCodecSetCodecPreferences(
  transceiver: transceiver,
  codecs: codecs,
);

/// Representation of static capabilities of an endpoint's implementation of a
/// codec.
class RtpCodecCapability {
  /// Default payload type for the codec.
  ///
  /// Mainly needed for codecs that have statically assigned payload types.
  final int? preferredPayloadType;

  /// List of [`ScalabilityMode`]s supported by the video codec.
  final List<ScalabilityMode> scalabilityModes;

  /// Built [MIME "type/subtype"][0] string from `name` and `kind`.
  ///
  /// [0]: https://en.wikipedia.org/wiki/Media_type
  final String mimeType;

  /// Used to identify the codec. Equivalent to [MIME subtype][0].
  ///
  /// [0]: https://en.wikipedia.org/wiki/Media_type#Subtypes
  final String name;

  /// [`MediaType`] of this codec. Equivalent to [MIME] top-level type.
  ///
  /// [MIME]: https://en.wikipedia.org/wiki/Media_type
  final MediaType kind;

  /// If [`None`], the implementation default is used.
  final int? clockRate;

  /// Number of audio channels used.
  ///
  /// [`None`] for video codecs.
  ///
  /// If [`None`] for audio, the implementation default is used.
  final int? numChannels;

  /// Codec-specific parameters that must be signaled to the remote party.
  ///
  /// Corresponds to `a=fmtp` parameters in [SDP].
  ///
  /// Contrary to ORTC, these parameters are named using all lowercase
  /// strings. This helps make the mapping to [SDP] simpler, if an application
  /// is using [SDP]. Boolean values are represented by the string "1".
  ///
  /// [SDP]: https://en.wikipedia.org/wiki/Session_Description_Protocol
  final List<(String, String)> parameters;

  /// Feedback mechanisms to be used for this codec.
  final List<RtcpFeedback> feedback;

  const RtpCodecCapability({
    this.preferredPayloadType,
    required this.scalabilityModes,
    required this.mimeType,
    required this.name,
    required this.kind,
    this.clockRate,
    this.numChannels,
    required this.parameters,
    required this.feedback,
  });

  @override
  int get hashCode =>
      preferredPayloadType.hashCode ^
      scalabilityModes.hashCode ^
      mimeType.hashCode ^
      name.hashCode ^
      kind.hashCode ^
      clockRate.hashCode ^
      numChannels.hashCode ^
      parameters.hashCode ^
      feedback.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RtpCodecCapability &&
          runtimeType == other.runtimeType &&
          preferredPayloadType == other.preferredPayloadType &&
          scalabilityModes == other.scalabilityModes &&
          mimeType == other.mimeType &&
          name == other.name &&
          kind == other.kind &&
          clockRate == other.clockRate &&
          numChannels == other.numChannels &&
          parameters == other.parameters &&
          feedback == other.feedback;
}
