// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.10.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

import 'api/media_info.dart';
import 'api/media_stream_track/audio_processing_config.dart';
import 'api/rtc_rtp_encoding_parameters.dart';
import 'api/rtc_rtp_send_parameters.dart';
import 'frb_generated.dart';
import 'lib.dart';

// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `TrackKind`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `clone`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `from`

/// Configures media acquisition to use fake devices instead of actual camera
/// and microphone.
Future<void> enableFakeMedia() =>
    RustLib.instance.api.crateApiEnableFakeMedia();

/// Indicates whether application is configured to use fake media devices.
Future<bool> isFakeMedia() => RustLib.instance.api.crateApiIsFakeMedia();

/// Returns a list of all available media input and output devices, such as
/// microphones, cameras, headsets, and so forth.
Future<List<MediaDeviceInfo>> enumerateDevices() =>
    RustLib.instance.api.crateApiEnumerateDevices();

/// Returns a list of all available displays that can be used for screen
/// capturing.
Future<List<MediaDisplayInfo>> enumerateDisplays() =>
    RustLib.instance.api.crateApiEnumerateDisplays();

/// Replaces the specified [`AudioTrack`] (or [`VideoTrack`]) on the
/// [`sys::RtpTransceiverInterface`]'s `sender`.
///
/// [`AudioTrack`]: crate::AudioTrack
/// [`VideoTrack`]: crate::VideoTrack
Future<void> senderReplaceTrack({
  required ArcPeerConnection peer,
  required ArcRtpTransceiver transceiver,
  String? trackId,
}) => RustLib.instance.api.crateApiSenderReplaceTrack(
  peer: peer,
  transceiver: transceiver,
  trackId: trackId,
);

/// Returns [`RtpParameters`] from the provided [`RtpTransceiver`]'s `sender`.
Future<RtcRtpSendParameters> senderGetParameters({
  required ArcRtpTransceiver transceiver,
}) =>
    RustLib.instance.api.crateApiSenderGetParameters(transceiver: transceiver);

/// Sets [`RtpParameters`] into the provided [`RtpTransceiver`]'s `sender`.
Future<void> senderSetParameters({
  required ArcRtpTransceiver transceiver,
  required RtcRtpSendParameters params,
}) => RustLib.instance.api.crateApiSenderSetParameters(
  transceiver: transceiver,
  params: params,
);

/// Sets the specified `audio playout` device.
Future<void> setAudioPlayoutDevice({required String deviceId}) =>
    RustLib.instance.api.crateApiSetAudioPlayoutDevice(deviceId: deviceId);

/// Indicates whether the microphone is available to set volume.
Future<bool> microphoneVolumeIsAvailable() =>
    RustLib.instance.api.crateApiMicrophoneVolumeIsAvailable();

/// Sets the microphone system volume according to the specified `level` in
/// percents.
///
/// Valid values range is `[0; 100]`.
Future<void> setMicrophoneVolume({required int level}) =>
    RustLib.instance.api.crateApiSetMicrophoneVolume(level: level);

/// Returns the current level of the microphone volume in `[0; 100]` range.
Future<int> microphoneVolume() =>
    RustLib.instance.api.crateApiMicrophoneVolume();

/// Sets the provided `OnDeviceChangeCallback` as the callback to be called
/// whenever a set of available media devices changes.
///
/// Only one callback can be set at a time, so the previous one will be dropped,
/// if any.
Stream<void> setOnDeviceChanged() =>
    RustLib.instance.api.crateApiSetOnDeviceChanged();

/// Nature and settings of the audio [`MediaStreamTrack`] returned by
/// [`Webrtc::get_media()`].
class AudioConstraints {
  /// Identifier of the device generating the content of the
  /// [`MediaStreamTrack`].
  ///
  /// First device will be chosen if an empty [`String`] is provided.
  final String? deviceId;

  /// Audio processing configuration constraints of the [`MediaStreamTrack`].
  final AudioProcessingConstraints processing;

  const AudioConstraints({this.deviceId, required this.processing});

  @override
  int get hashCode => deviceId.hashCode ^ processing.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AudioConstraints &&
          runtimeType == other.runtimeType &&
          deviceId == other.deviceId &&
          processing == other.processing;
}

/// Constraints of an [`AudioProcessingConfig`].
class AudioProcessingConstraints {
  /// Indicator whether the audio volume level should be automatically tuned
  /// to maintain a steady overall volume level.
  final bool? autoGainControl;

  /// Indicator whether a high-pass filter should be enabled to eliminate
  /// low-frequency noise.
  final bool? highPassFilter;

  /// Indicator whether noise suppression should be enabled to reduce
  /// background sounds.
  final bool? noiseSuppression;

  /// Level of aggressiveness for noise suppression.
  final NoiseSuppressionLevel? noiseSuppressionLevel;

  /// Indicator whether echo cancellation should be enabled to prevent
  /// feedback.
  final bool? echoCancellation;

  const AudioProcessingConstraints({
    this.autoGainControl,
    this.highPassFilter,
    this.noiseSuppression,
    this.noiseSuppressionLevel,
    this.echoCancellation,
  });

  static Future<AudioProcessingConstraints> default_() =>
      RustLib.instance.api.crateApiAudioProcessingConstraintsDefault();

  @override
  int get hashCode =>
      autoGainControl.hashCode ^
      highPassFilter.hashCode ^
      noiseSuppression.hashCode ^
      noiseSuppressionLevel.hashCode ^
      echoCancellation.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AudioProcessingConstraints &&
          runtimeType == other.runtimeType &&
          autoGainControl == other.autoGainControl &&
          highPassFilter == other.highPassFilter &&
          noiseSuppression == other.noiseSuppression &&
          noiseSuppressionLevel == other.noiseSuppressionLevel &&
          echoCancellation == other.echoCancellation;
}

/// [MediaStreamConstraints], used to instruct what sort of
/// [`MediaStreamTrack`]s to return by the [`Webrtc::get_media()`].
///
/// [1]: https://w3.org/TR/mediacapture-streams#dom-mediastreamconstraints
class MediaStreamConstraints {
  /// Specifies the nature and settings of the audio [`MediaStreamTrack`].
  final AudioConstraints? audio;

  /// Specifies the nature and settings of the video [`MediaStreamTrack`].
  final VideoConstraints? video;

  const MediaStreamConstraints({this.audio, this.video});

  @override
  int get hashCode => audio.hashCode ^ video.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MediaStreamConstraints &&
          runtimeType == other.runtimeType &&
          audio == other.audio &&
          video == other.video;
}

/// Nature and settings of the video [`MediaStreamTrack`] returned by
/// [`Webrtc::get_media()`].
class VideoConstraints {
  /// Identifier of the device generating the content of the
  /// [`MediaStreamTrack`].
  ///
  /// The first device will be chosen if an empty [`String`] is provided.
  final String? deviceId;

  /// Width in pixels.
  final int width;

  /// Height in pixels.
  final int height;

  /// Exact frame rate (frames per second).
  final int frameRate;

  /// Indicator whether the request video track should be acquired via screen
  /// capturing.
  final bool isDisplay;

  const VideoConstraints({
    this.deviceId,
    required this.width,
    required this.height,
    required this.frameRate,
    required this.isDisplay,
  });

  @override
  int get hashCode =>
      deviceId.hashCode ^
      width.hashCode ^
      height.hashCode ^
      frameRate.hashCode ^
      isDisplay.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is VideoConstraints &&
          runtimeType == other.runtimeType &&
          deviceId == other.deviceId &&
          width == other.width &&
          height == other.height &&
          frameRate == other.frameRate &&
          isDisplay == other.isDisplay;
}
