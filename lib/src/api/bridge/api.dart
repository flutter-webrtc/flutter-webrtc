// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.10.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;

import 'api/media_info.dart';
import 'api/media_stream_track.dart';
import 'api/media_stream_track/audio_processing_config.dart';
import 'api/media_stream_track/media_type.dart';
import 'api/rtc_rtp_encoding_parameters.dart';
import 'frb_generated.dart';
import 'lib.dart';

part 'api.freezed.dart';

// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `TrackKind`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`

/// Returns all [`VideoCodecInfo`]s of the supported video encoders.
Future<List<VideoCodecInfo>> videoEncoders() =>
    RustLib.instance.api.crateApiVideoEncoders();

/// Returns all [`VideoCodecInfo`]s of the supported video decoders.
Future<List<VideoCodecInfo>> videoDecoders() =>
    RustLib.instance.api.crateApiVideoDecoders();

/// Configures media acquisition to use fake devices instead of actual camera
/// and microphone.
Future<void> enableFakeMedia() =>
    RustLib.instance.api.crateApiEnableFakeMedia();

/// Indicates whether application is configured to use fake media devices.
Future<bool> isFakeMedia() => RustLib.instance.api.crateApiIsFakeMedia();

/// Returns a list of all available media input and output devices, such as
/// microphones, cameras, headsets, and so forth.
Future<List<MediaDeviceInfo>> enumerateDevices() =>
    RustLib.instance.api.crateApiEnumerateDevices();

/// Returns a list of all available displays that can be used for screen
/// capturing.
Future<List<MediaDisplayInfo>> enumerateDisplays() =>
    RustLib.instance.api.crateApiEnumerateDisplays();

/// Creates a new [`PeerConnection`] and returns its ID.
Stream<PeerConnectionEvent> createPeerConnection({
  required RtcConfiguration configuration,
}) => RustLib.instance.api.crateApiCreatePeerConnection(
  configuration: configuration,
);

/// Initiates the creation of an SDP offer for the purpose of starting a new
/// WebRTC connection to a remote peer.
Future<RtcSessionDescription> createOffer({
  required ArcPeerConnection peer,
  required bool voiceActivityDetection,
  required bool iceRestart,
  required bool useRtpMux,
}) => RustLib.instance.api.crateApiCreateOffer(
  peer: peer,
  voiceActivityDetection: voiceActivityDetection,
  iceRestart: iceRestart,
  useRtpMux: useRtpMux,
);

/// Creates an SDP answer to an offer received from a remote peer during an
/// offer/answer negotiation of a WebRTC connection.
Future<RtcSessionDescription> createAnswer({
  required ArcPeerConnection peer,
  required bool voiceActivityDetection,
  required bool iceRestart,
  required bool useRtpMux,
}) => RustLib.instance.api.crateApiCreateAnswer(
  peer: peer,
  voiceActivityDetection: voiceActivityDetection,
  iceRestart: iceRestart,
  useRtpMux: useRtpMux,
);

/// Changes the local description associated with the connection.
Future<void> setLocalDescription({
  required ArcPeerConnection peer,
  required SdpType kind,
  required String sdp,
}) => RustLib.instance.api.crateApiSetLocalDescription(
  peer: peer,
  kind: kind,
  sdp: sdp,
);

/// Sets the specified session description as the remote peer's current offer or
/// answer.
Future<void> setRemoteDescription({
  required ArcPeerConnection peer,
  required SdpType kind,
  required String sdp,
}) => RustLib.instance.api.crateApiSetRemoteDescription(
  peer: peer,
  kind: kind,
  sdp: sdp,
);

/// Creates a new [`RtcRtpTransceiver`] and adds it to the set of transceivers
/// of the specified [`PeerConnection`].
Future<RtcRtpTransceiver> addTransceiver({
  required ArcPeerConnection peer,
  required MediaType mediaType,
  required RtpTransceiverInit init,
}) => RustLib.instance.api.crateApiAddTransceiver(
  peer: peer,
  mediaType: mediaType,
  init: init,
);

/// Returns a sequence of [`RtcRtpTransceiver`] objects representing the RTP
/// transceivers currently attached to the specified [`PeerConnection`].
Future<List<RtcRtpTransceiver>> getTransceivers({
  required ArcPeerConnection peer,
}) => RustLib.instance.api.crateApiGetTransceivers(peer: peer);

/// Changes the preferred `direction` of the specified [`RtcRtpTransceiver`].
Future<void> setTransceiverDirection({
  required ArcRtpTransceiver transceiver,
  required RtpTransceiverDirection direction,
}) => RustLib.instance.api.crateApiSetTransceiverDirection(
  transceiver: transceiver,
  direction: direction,
);

/// Changes the receive direction of the specified [`RtcRtpTransceiver`].
Future<void> setTransceiverRecv({
  required ArcRtpTransceiver transceiver,
  required bool recv,
}) => RustLib.instance.api.crateApiSetTransceiverRecv(
  transceiver: transceiver,
  recv: recv,
);

/// Changes the send direction of the specified [`RtcRtpTransceiver`].
Future<void> setTransceiverSend({
  required ArcRtpTransceiver transceiver,
  required bool send,
}) => RustLib.instance.api.crateApiSetTransceiverSend(
  transceiver: transceiver,
  send: send,
);

/// Returns the [negotiated media ID (mid)][1] of the specified
/// [`RtcRtpTransceiver`].
///
/// [1]: https://w3.org/TR/webrtc#dfn-media-stream-identification-tag
Future<String?> getTransceiverMid({required ArcRtpTransceiver transceiver}) =>
    RustLib.instance.api.crateApiGetTransceiverMid(transceiver: transceiver);

/// Returns the preferred direction of the specified [`RtcRtpTransceiver`].
Future<RtpTransceiverDirection> getTransceiverDirection({
  required ArcRtpTransceiver transceiver,
}) => RustLib.instance.api.crateApiGetTransceiverDirection(
  transceiver: transceiver,
);

/// Irreversibly marks the specified [`RtcRtpTransceiver`] as stopping, unless
/// it's already stopped.
///
/// This will immediately cause the transceiver's sender to no longer send, and
/// its receiver to no longer receive.
Future<void> stopTransceiver({required ArcRtpTransceiver transceiver}) =>
    RustLib.instance.api.crateApiStopTransceiver(transceiver: transceiver);

/// Replaces the specified [`AudioTrack`] (or [`VideoTrack`]) on the
/// [`sys::RtpTransceiverInterface`]'s `sender`.
///
/// [`AudioTrack`]: crate::AudioTrack
/// [`VideoTrack`]: crate::VideoTrack
Future<void> senderReplaceTrack({
  required ArcPeerConnection peer,
  required ArcRtpTransceiver transceiver,
  String? trackId,
}) => RustLib.instance.api.crateApiSenderReplaceTrack(
  peer: peer,
  transceiver: transceiver,
  trackId: trackId,
);

/// Returns [`RtpParameters`] from the provided [`RtpTransceiver`]'s `sender`.
Future<RtcRtpSendParameters> senderGetParameters({
  required ArcRtpTransceiver transceiver,
}) =>
    RustLib.instance.api.crateApiSenderGetParameters(transceiver: transceiver);

/// Sets [`RtpParameters`] into the provided [`RtpTransceiver`]'s `sender`.
Future<void> senderSetParameters({
  required ArcRtpTransceiver transceiver,
  required RtcRtpSendParameters params,
}) => RustLib.instance.api.crateApiSenderSetParameters(
  transceiver: transceiver,
  params: params,
);

/// Adds the new ICE `candidate` to the given [`PeerConnection`].
Future<void> addIceCandidate({
  required ArcPeerConnection peer,
  required String candidate,
  required String sdpMid,
  required int sdpMlineIndex,
}) => RustLib.instance.api.crateApiAddIceCandidate(
  peer: peer,
  candidate: candidate,
  sdpMid: sdpMid,
  sdpMlineIndex: sdpMlineIndex,
);

/// Tells the [`PeerConnection`] that ICE should be restarted.
Future<void> restartIce({required ArcPeerConnection peer}) =>
    RustLib.instance.api.crateApiRestartIce(peer: peer);

/// Closes the [`PeerConnection`].
Future<void> disposePeerConnection({required ArcPeerConnection peer}) =>
    RustLib.instance.api.crateApiDisposePeerConnection(peer: peer);

/// Sets the specified `audio playout` device.
Future<void> setAudioPlayoutDevice({required String deviceId}) =>
    RustLib.instance.api.crateApiSetAudioPlayoutDevice(deviceId: deviceId);

/// Indicates whether the microphone is available to set volume.
Future<bool> microphoneVolumeIsAvailable() =>
    RustLib.instance.api.crateApiMicrophoneVolumeIsAvailable();

/// Sets the microphone system volume according to the specified `level` in
/// percents.
///
/// Valid values range is `[0; 100]`.
Future<void> setMicrophoneVolume({required int level}) =>
    RustLib.instance.api.crateApiSetMicrophoneVolume(level: level);

/// Returns the current level of the microphone volume in `[0; 100]` range.
Future<int> microphoneVolume() =>
    RustLib.instance.api.crateApiMicrophoneVolume();

/// Sets the provided `OnDeviceChangeCallback` as the callback to be called
/// whenever a set of available media devices changes.
///
/// Only one callback can be set at a time, so the previous one will be dropped,
/// if any.
Stream<void> setOnDeviceChanged() =>
    RustLib.instance.api.crateApiSetOnDeviceChanged();

/// Nature and settings of the audio [`MediaStreamTrack`] returned by
/// [`Webrtc::get_media()`].
class AudioConstraints {
  /// Identifier of the device generating the content of the
  /// [`MediaStreamTrack`].
  ///
  /// First device will be chosen if an empty [`String`] is provided.
  final String? deviceId;

  /// Audio processing configuration constraints of the [`MediaStreamTrack`].
  final AudioProcessingConstraints processing;

  const AudioConstraints({this.deviceId, required this.processing});

  @override
  int get hashCode => deviceId.hashCode ^ processing.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AudioConstraints &&
          runtimeType == other.runtimeType &&
          deviceId == other.deviceId &&
          processing == other.processing;
}

/// Constraints of an [`AudioProcessingConfig`].
class AudioProcessingConstraints {
  /// Indicator whether the audio volume level should be automatically tuned
  /// to maintain a steady overall volume level.
  final bool? autoGainControl;

  /// Indicator whether a high-pass filter should be enabled to eliminate
  /// low-frequency noise.
  final bool? highPassFilter;

  /// Indicator whether noise suppression should be enabled to reduce
  /// background sounds.
  final bool? noiseSuppression;

  /// Level of aggressiveness for noise suppression.
  final NoiseSuppressionLevel? noiseSuppressionLevel;

  /// Indicator whether echo cancellation should be enabled to prevent
  /// feedback.
  final bool? echoCancellation;

  const AudioProcessingConstraints({
    this.autoGainControl,
    this.highPassFilter,
    this.noiseSuppression,
    this.noiseSuppressionLevel,
    this.echoCancellation,
  });

  static Future<AudioProcessingConstraints> default_() =>
      RustLib.instance.api.crateApiAudioProcessingConstraintsDefault();

  @override
  int get hashCode =>
      autoGainControl.hashCode ^
      highPassFilter.hashCode ^
      noiseSuppression.hashCode ^
      noiseSuppressionLevel.hashCode ^
      echoCancellation.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AudioProcessingConstraints &&
          runtimeType == other.runtimeType &&
          autoGainControl == other.autoGainControl &&
          highPassFilter == other.highPassFilter &&
          noiseSuppression == other.noiseSuppression &&
          noiseSuppressionLevel == other.noiseSuppressionLevel &&
          echoCancellation == other.echoCancellation;
}

/// [RTCBundlePolicy][1] representation.
///
/// Affects which media tracks are negotiated if the remote endpoint is not
/// bundle-aware, and what ICE candidates are gathered. If the remote endpoint
/// is bundle-aware, all media tracks and data channels are bundled onto the
/// same transport.
///
/// [1]: https://w3.org/TR/webrtc#dom-rtcbundlepolicy
enum BundlePolicy {
  /// [RTCBundlePolicy.balanced][1] representation.
  ///
  /// [1]: https://w3.org/TR/webrtc#dom-rtcbundlepolicy-balanced
  balanced,

  /// [RTCBundlePolicy.max-bundle][1] representation.
  ///
  /// [1]: https://w3.org/TR/webrtc#dom-rtcbundlepolicy-max-bundle
  maxBundle,

  /// [RTCBundlePolicy.max-compat][1] representation.
  ///
  /// [1]: https://w3.org/TR/webrtc#dom-rtcbundlepolicy-max-compat
  maxCompat,
}

/// [RTCIceConnectionState][1] representation.
///
/// [1]: https://w3.org/TR/webrtc#dom-rtciceconnectionstate
enum IceConnectionState {
  /// [RTCIceConnectionState.new][1] representation.
  ///
  /// [1]: https://w3.org/TR/webrtc#dom-rtciceconnectionstate-new
  new_,

  /// [RTCIceConnectionState.checking][1] representation.
  ///
  /// [1]: https://w3.org/TR/webrtc#dom-rtciceconnectionstate-checking
  checking,

  /// [RTCIceConnectionState.connected][1] representation.
  ///
  /// [1]: https://w3.org/TR/webrtc#dom-rtciceconnectionstate-connected
  connected,

  /// [RTCIceConnectionState.completed][1] representation.
  ///
  /// [1]: https://w3.org/TR/webrtc#dom-rtciceconnectionstate-completed
  completed,

  /// [RTCIceConnectionState.failed][1] representation.
  ///
  /// [1]: https://w3.org/TR/webrtc#dom-rtciceconnectionstate-failed
  failed,

  /// [RTCIceConnectionState.disconnected][1] representation.
  ///
  /// [1]: https://w3.org/TR/webrtc#dom-rtciceconnectionstate-disconnected
  disconnected,

  /// [RTCIceConnectionState.closed][1] representation.
  ///
  /// [1]: https://w3.org/TR/webrtc#dom-rtciceconnectionstate-closed
  closed,
}

/// [RTCIceGatheringState][1] representation.
///
/// [1]: https://w3.org/TR/webrtc#dom-rtcicegatheringstate
enum IceGatheringState {
  /// [RTCIceGatheringState.new][1] representation.
  ///
  /// [1]: https://w3.org/TR/webrtc#dom-rtcicegatheringstate-new
  new_,

  /// [RTCIceGatheringState.gathering][1] representation.
  ///
  /// [1]: https://w3.org/TR/webrtc#dom-rtcicegatheringstate-gathering
  gathering,

  /// [RTCIceGatheringState.complete][1] representation.
  ///
  /// [1]: https://w3.org/TR/webrtc#dom-rtcicegatheringstate-complete
  complete,
}

/// [RTCIceTransportPolicy][1] representation.
///
/// It defines an ICE candidate policy the [ICE Agent][2] uses to surface
/// the permitted candidates to the application. Only these candidates will
/// be used for connectivity checks.
///
/// [1]: https://w3.org/TR/webrtc#dom-rtcicetransportpolicy
/// [2]: https://w3.org/TR/webrtc#dfn-ice-agent
enum IceTransportsType {
  /// [RTCIceTransportPolicy.all][1] representation.
  ///
  /// [1]: https://w3.org/TR/webrtc#dom-rtcicetransportpolicy-all
  all,

  /// [RTCIceTransportPolicy.relay][1] representation.
  ///
  /// [1]: https://w3.org/TR/webrtc#dom-rtcicetransportpolicy-relay
  relay,

  /// ICE Agent can't use `typ host` candidates when this value is specified.
  ///
  /// Non-spec-compliant variant.
  noHost,

  /// No ICE candidate offered.
  none,
}

/// [MediaStreamConstraints], used to instruct what sort of
/// [`MediaStreamTrack`]s to return by the [`Webrtc::get_media()`].
///
/// [1]: https://w3.org/TR/mediacapture-streams#dom-mediastreamconstraints
class MediaStreamConstraints {
  /// Specifies the nature and settings of the audio [`MediaStreamTrack`].
  final AudioConstraints? audio;

  /// Specifies the nature and settings of the video [`MediaStreamTrack`].
  final VideoConstraints? video;

  const MediaStreamConstraints({this.audio, this.video});

  @override
  int get hashCode => audio.hashCode ^ video.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MediaStreamConstraints &&
          runtimeType == other.runtimeType &&
          audio == other.audio &&
          video == other.video;
}

@freezed
sealed class PeerConnectionEvent with _$PeerConnectionEvent {
  const PeerConnectionEvent._();

  /// [`PeerConnection`] has been created.
  const factory PeerConnectionEvent.peerCreated({
    /// Rust side [`PeerConnection`].
    required ArcPeerConnection peer,
  }) = PeerConnectionEvent_PeerCreated;

  /// [RTCIceCandidate][1] has been discovered.
  ///
  /// [1]: https://w3.org/TR/webrtc#dom-rtcicecandidate
  const factory PeerConnectionEvent.iceCandidate({
    /// Media stream "identification-tag" defined in [RFC 5888] for the
    /// media component the discovered [RTCIceCandidate][1] is associated
    /// with.
    ///
    /// [1]: https://w3.org/TR/webrtc#dom-rtcicecandidate
    /// [RFC 5888]: https://tools.ietf.org/html/rfc5888
    required String sdpMid,

    /// Index (starting at zero) of the media description in the SDP this
    /// [RTCIceCandidate][1] is associated with.
    ///
    /// [1]: https://w3.org/TR/webrtc#dom-rtcicecandidate
    required int sdpMlineIndex,

    /// Candidate-attribute as defined in Section 15.1 of [RFC 5245].
    ///
    /// If this [RTCIceCandidate][1] represents an end-of-candidates
    /// indication or a peer reflexive remote candidate, candidate is an
    /// empty string.
    ///
    /// [1]: https://w3.org/TR/webrtc#dom-rtcicecandidate
    /// [RFC 5245]: https://tools.ietf.org/html/rfc5245
    required String candidate,
  }) = PeerConnectionEvent_IceCandidate;

  /// [`PeerConnection`]'s ICE gathering state has changed.
  const factory PeerConnectionEvent.iceGatheringStateChange(
    IceGatheringState field0,
  ) = PeerConnectionEvent_IceGatheringStateChange;

  /// Failure occurred when gathering [RTCIceCandidate][1].
  ///
  /// [1]: https://w3.org/TR/webrtc#dom-rtcicecandidate
  const factory PeerConnectionEvent.iceCandidateError({
    /// Local IP address used to communicate with the STUN or TURN server.
    required String address,

    /// Port used to communicate with the STUN or TURN server.
    required int port,

    /// STUN or TURN URL identifying the STUN or TURN server for which the
    /// failure occurred.
    required String url,

    /// Numeric STUN error code returned by the STUN or TURN server
    /// [`STUN-PARAMETERS`][1].
    ///
    /// If no host candidate can reach the server, it will be set to the
    /// value `701` which is outside the STUN error code range.
    ///
    /// [1]: https://tinyurl.com/stun-parameters-6
    required int errorCode,

    /// STUN reason text returned by the STUN or TURN server
    /// [`STUN-PARAMETERS`][1].
    ///
    /// If the server could not be reached, it will be set to an
    /// implementation-specific value providing details about the error.
    ///
    /// [1]: https://tinyurl.com/stun-parameters-6
    required String errorText,
  }) = PeerConnectionEvent_IceCandidateError;

  /// Negotiation or renegotiation of the [`PeerConnection`] needs to be
  /// performed.
  const factory PeerConnectionEvent.negotiationNeeded() =
      PeerConnectionEvent_NegotiationNeeded;

  /// [`PeerConnection`]'s [`SignalingState`] has been changed.
  const factory PeerConnectionEvent.signallingChange(SignalingState field0) =
      PeerConnectionEvent_SignallingChange;

  /// [`PeerConnection`]'s [`IceConnectionState`] has been changed.
  const factory PeerConnectionEvent.iceConnectionStateChange(
    IceConnectionState field0,
  ) = PeerConnectionEvent_IceConnectionStateChange;

  /// [`PeerConnection`]'s [`PeerConnectionState`] has been changed.
  const factory PeerConnectionEvent.connectionStateChange(
    PeerConnectionState field0,
  ) = PeerConnectionEvent_ConnectionStateChange;

  /// New incoming media has been negotiated.
  const factory PeerConnectionEvent.track(RtcTrackEvent field0) =
      PeerConnectionEvent_Track;
}

/// Indicator of the current state of a [`PeerConnection`].
enum PeerConnectionState {
  /// At least one of the connection's ICE transports is in the new state,
  /// and none of them are in one of the following states: `connecting`,
  /// `checking`, `failed`, `disconnected`, or all of the connection's
  /// transports are in the `closed` state.
  new_,

  /// One or more of the ICE transports are currently in the process of
  /// establishing a connection. That is, their [`IceConnectionState`] is
  /// either [`IceConnectionState::Checking`] or
  /// [`IceConnectionState::Connected`], and no transports are in the
  /// `failed` state.
  connecting,

  /// Every ICE transport used by the connection is either in use (state
  /// `connected` or `completed`) or is closed (state `closed`). In addition,
  /// at least one transport is either `connected` or `completed`.
  connected,

  /// At least one of the ICE transports for the connection is in the
  /// `disconnected` state and none of the other transports are in the state
  /// `failed`, `connecting` or `checking`.
  disconnected,

  /// One or more of the ICE transports on the connection is in the `failed`
  /// state.
  failed,

  /// Peer connection is closed.
  closed,
}

/// [`PeerConnection`]'s configuration.
class RtcConfiguration {
  /// [iceTransportPolicy][1] configuration.
  ///
  /// Indicates which candidates the [ICE Agent][2] is allowed to use.
  ///
  /// [1]: https://tinyurl.com/icetransportpolicy
  /// [2]: https://w3.org/TR/webrtc#dfn-ice-agent
  final IceTransportsType iceTransportPolicy;

  /// [bundlePolicy][1] configuration.
  ///
  /// Indicates which media-bundling policy to use when gathering ICE
  /// candidates.
  ///
  /// [1]: https://w3.org/TR/webrtc#dom-rtcconfiguration-bundlepolicy
  final BundlePolicy bundlePolicy;

  /// [iceServers][1] configuration.
  ///
  /// An array of objects describing servers available to be used by ICE,
  /// such as STUN and TURN servers.
  ///
  /// [1]: https://w3.org/TR/webrtc#dom-rtcconfiguration-iceservers
  final List<RtcIceServer> iceServers;

  const RtcConfiguration({
    required this.iceTransportPolicy,
    required this.bundlePolicy,
    required this.iceServers,
  });

  @override
  int get hashCode =>
      iceTransportPolicy.hashCode ^ bundlePolicy.hashCode ^ iceServers.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RtcConfiguration &&
          runtimeType == other.runtimeType &&
          iceTransportPolicy == other.iceTransportPolicy &&
          bundlePolicy == other.bundlePolicy &&
          iceServers == other.iceServers;
}

/// Description of STUN and TURN servers that can be used by an [ICE Agent][1]
/// to establish a connection with a peer.
///
/// [1]: https://w3.org/TR/webrtc#dfn-ice-agent
class RtcIceServer {
  /// STUN or TURN URI(s).
  final List<String> urls;

  /// If this [`RtcIceServer`] object represents a TURN server, then this
  /// attribute specifies the [username][1] to use with that TURN server.
  ///
  /// [1]: https://w3.org/TR/webrtc#dom-rtciceserver-username
  final String username;

  /// If this [`RtcIceServer`] object represents a TURN server, then this
  /// attribute specifies the [credential][1] to use with that TURN
  /// server.
  ///
  /// [1]: https://w3.org/TR/webrtc#dom-rtciceserver-credential
  final String credential;

  const RtcIceServer({
    required this.urls,
    required this.username,
    required this.credential,
  });

  @override
  int get hashCode => urls.hashCode ^ username.hashCode ^ credential.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RtcIceServer &&
          runtimeType == other.runtimeType &&
          urls == other.urls &&
          username == other.username &&
          credential == other.credential;
}

/// Representation of [RTCRtpSendParameters][0].
///
/// [0]: https://w3.org/TR/webrtc#dom-rtcrtpsendparameters
class RtcRtpSendParameters {
  /// Sequence containing parameters for sending [RTP] encodings of media.
  ///
  /// [RTP]: https://en.wikipedia.org/wiki/Real-time_Transport_Protocol
  final List<(RtcRtpEncodingParameters, ArcRtpEncodingParameters)> encodings;

  /// Reference to the Rust side [`RtpParameters`].
  final ArcRtpParameters inner;

  const RtcRtpSendParameters({required this.encodings, required this.inner});

  @override
  int get hashCode => encodings.hashCode ^ inner.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RtcRtpSendParameters &&
          runtimeType == other.runtimeType &&
          encodings == other.encodings &&
          inner == other.inner;
}

/// Representation of a permanent pair of an [RTCRtpSender] and an
/// [RTCRtpReceiver], along with some shared state.
///
/// [RTCRtpSender]: https://w3.org/TR/webrtc#dom-rtcrtpsender
/// [RTCRtpReceiver]: https://w3.org/TR/webrtc#dom-rtcrtpreceiver
class RtcRtpTransceiver {
  /// [`PeerConnection`] that this [`RtcRtpTransceiver`] belongs to.
  final ArcPeerConnection peer;

  /// Rust side [`RtpTransceiver`].
  final ArcRtpTransceiver transceiver;

  /// [Negotiated media ID (mid)][1] which the local and remote peers have
  /// agreed upon to uniquely identify the [MediaStream]'s pairing of sender
  /// and receiver.
  ///
  /// [MediaStream]: https://w3.org/TR/mediacapture-streams#dom-mediastream
  /// [1]: https://w3.org/TR/webrtc#dfn-media-stream-identification-tag
  final String? mid;

  /// Preferred [`direction`][1] of this [`RtcRtpTransceiver`].
  ///
  /// [1]: https://w3.org/TR/webrtc#dom-rtcrtptransceiver-direction
  final RtpTransceiverDirection direction;

  const RtcRtpTransceiver({
    required this.peer,
    required this.transceiver,
    this.mid,
    required this.direction,
  });

  @override
  int get hashCode =>
      peer.hashCode ^ transceiver.hashCode ^ mid.hashCode ^ direction.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RtcRtpTransceiver &&
          runtimeType == other.runtimeType &&
          peer == other.peer &&
          transceiver == other.transceiver &&
          mid == other.mid &&
          direction == other.direction;
}

/// [RTCSessionDescription] representation.
///
/// [RTCSessionDescription]: https://w3.org/TR/webrtc#dom-rtcsessiondescription
class RtcSessionDescription {
  /// String representation of the SDP.
  final String sdp;

  /// Type of this [`RtcSessionDescription`].
  final SdpType kind;

  const RtcSessionDescription({required this.sdp, required this.kind});

  @override
  int get hashCode => sdp.hashCode ^ kind.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RtcSessionDescription &&
          runtimeType == other.runtimeType &&
          sdp == other.sdp &&
          kind == other.kind;
}

/// Representation of a track event, sent when a new [`MediaStreamTrack`] is
/// added to an [`RtcRtpTransceiver`] as part of a [`PeerConnection`].
class RtcTrackEvent {
  /// [`MediaStreamTrack`] associated with the [RTCRtpReceiver] identified
  /// by the receiver.
  ///
  /// [RTCRtpReceiver]: https://w3.org/TR/webrtc#dom-rtcrtpreceiver
  final MediaStreamTrack track;

  /// [`RtcRtpTransceiver`] object associated with the event.
  final RtcRtpTransceiver transceiver;

  const RtcTrackEvent({required this.track, required this.transceiver});

  @override
  int get hashCode => track.hashCode ^ transceiver.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RtcTrackEvent &&
          runtimeType == other.runtimeType &&
          track == other.track &&
          transceiver == other.transceiver;
}

/// [RTCRtpTransceiverDirection][1] representation.
///
/// [1]: https://w3.org/TR/webrtc#dom-rtcrtptransceiverdirection
enum RtpTransceiverDirection {
  /// The [RTCRtpTransceiver]'s [RTCRtpSender] will offer to send RTP, and
  /// will send RTP if the remote peer accepts. The [RTCRtpTransceiver]'s
  /// [RTCRtpReceiver] will offer to receive RTP, and will receive RTP if the
  /// remote peer accepts.
  ///
  /// [RTCRtpReceiver]: https://w3.org/TR/webrtc#dom-rtcrtpreceiver
  /// [RTCRtpSender]: https://w3.org/TR/webrtc#dom-rtcrtpsender
  /// [RTCRtpTransceiver]: https://w3.org/TR/webrtc#dom-rtcrtptransceiver
  sendRecv,

  /// The [RTCRtpTransceiver]'s [RTCRtpSender] will offer to send RTP, and
  /// will send RTP if the remote peer accepts. The [RTCRtpTransceiver]'s
  /// [RTCRtpReceiver] will not offer to receive RTP, and will not receive
  /// RTP.
  ///
  /// [RTCRtpReceiver]: https://w3.org/TR/webrtc#dom-rtcrtpreceiver
  /// [RTCRtpSender]: https://w3.org/TR/webrtc#dom-rtcrtpsender
  /// [RTCRtpTransceiver]: https://w3.org/TR/webrtc#dom-rtcrtptransceiver
  sendOnly,

  /// The [RTCRtpTransceiver]'s [RTCRtpSender] will not offer to send RTP,
  /// and will not send RTP. The [RTCRtpTransceiver]'s [RTCRtpReceiver] will
  /// offer to receive RTP, and will receive RTP if the remote peer accepts.
  ///
  /// [RTCRtpReceiver]: https://w3.org/TR/webrtc#dom-rtcrtpreceiver
  /// [RTCRtpSender]: https://w3.org/TR/webrtc#dom-rtcrtpsender
  /// [RTCRtpTransceiver]: https://w3.org/TR/webrtc#dom-rtcrtptransceiver
  recvOnly,

  /// The [RTCRtpTransceiver]'s [RTCRtpSender] will not offer to send RTP,
  /// and will not send RTP. The [RTCRtpTransceiver]'s [RTCRtpReceiver] will
  /// not offer to receive RTP, and will not receive RTP.
  ///
  /// [RTCRtpReceiver]: https://w3.org/TR/webrtc#dom-rtcrtpreceiver
  /// [RTCRtpSender]: https://w3.org/TR/webrtc#dom-rtcrtpsender
  /// [RTCRtpTransceiver]: https://w3.org/TR/webrtc#dom-rtcrtptransceiver
  inactive,

  /// The [RTCRtpTransceiver] will neither send nor receive RTP. It will
  /// generate a zero port in the offer. In answers, its [RTCRtpSender] will
  /// not offer to send RTP, and its [RTCRtpReceiver] will not offer to
  /// receive RTP. This is a terminal state.
  ///
  /// [RTCRtpReceiver]: https://w3.org/TR/webrtc#dom-rtcrtpreceiver
  /// [RTCRtpSender]: https://w3.org/TR/webrtc#dom-rtcrtpsender
  /// [RTCRtpTransceiver]: https://w3.org/TR/webrtc#dom-rtcrtptransceiver
  stopped,
}

/// Representation of an [RTCRtpTransceiverInit][0].
///
/// [0]: https://w3.org/TR/webrtc#dom-rtcrtptransceiverinit
class RtpTransceiverInit {
  /// Direction of the [RTCRtpTransceiver].
  ///
  /// [RTCRtpTransceiver]: https://w3.org/TR/webrtc#dom-rtcrtptransceiver
  final RtpTransceiverDirection direction;

  /// Sequence containing parameters for sending [RTP] encodings of media.
  ///
  /// [RTP]: https://en.wikipedia.org/wiki/Real-time_Transport_Protocol
  final List<RtcRtpEncodingParameters> sendEncodings;

  const RtpTransceiverInit({
    required this.direction,
    required this.sendEncodings,
  });

  @override
  int get hashCode => direction.hashCode ^ sendEncodings.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RtpTransceiverInit &&
          runtimeType == other.runtimeType &&
          direction == other.direction &&
          sendEncodings == other.sendEncodings;
}

/// [RTCSdpType] representation.
///
/// [RTCSdpType]: https://w3.org/TR/webrtc#dom-rtcsdptype
enum SdpType {
  /// [RTCSdpType.offer][1] representation.
  ///
  /// [1]: https://w3.org/TR/webrtc#dom-rtcsdptype-offer
  offer,

  /// [RTCSdpType.pranswer][1] representation.
  ///
  /// [1]: https://w3.org/TR/webrtc#dom-rtcsdptype-pranswer
  prAnswer,

  /// [RTCSdpType.answer][1] representation.
  ///
  /// [1]: https://w3.org/TR/webrtc#dom-rtcsdptype-answer
  answer,

  /// [RTCSdpType.rollback][1] representation.
  ///
  /// [1]: https://w3.org/TR/webrtc#dom-rtcsdptype-rollback
  rollback,
}

/// [RTCSignalingState] representation.
///
/// [RTCSignalingState]: https://w3.org/TR/webrtc#state-definitions
enum SignalingState {
  /// [RTCSignalingState.stable][1] representation.
  ///
  /// [1]: https://w3.org/TR/webrtc#dom-rtcsignalingstate-stable
  stable,

  /// [RTCSignalingState.have-local-offer][1] representation.
  ///
  /// [1]: https://w3.org/TR/webrtc#dom-rtcsignalingstate-have-local-offer
  haveLocalOffer,

  /// [RTCSignalingState.have-local-pranswer][1] representation.
  ///
  /// [1]: https://tinyurl.com/have-local-pranswer
  haveLocalPrAnswer,

  /// [RTCSignalingState.have-remote-offer][1] representation.
  ///
  /// [1]: https://tinyurl.com/have-remote-offer
  haveRemoteOffer,

  /// [RTCSignalingState.have-remote-pranswer][1] representation.
  ///
  /// [1]: https://tinyurl.com/have-remote-pranswer
  haveRemotePrAnswer,

  /// [RTCSignalingState.closed][1] representation.
  ///
  /// [1]: https://w3.org/TR/webrtc#dom-rtcsignalingstate-closed
  closed,
}

/// Supported video codecs.
enum VideoCodec {
  /// [AV1] AOMedia Video 1.
  ///
  /// [AV1]: https://en.wikipedia.org/wiki/AV1
  av1,

  /// [H.264] Advanced Video Coding (AVC).
  ///
  /// [H.264]: https://en.wikipedia.org/wiki/Advanced_Video_Coding
  h264,

  /// [H.265] High Efficiency Video Coding (HEVC).
  ///
  /// [H.265]: https://en.wikipedia.org/wiki/High_Efficiency_Video_Coding
  h265,

  /// [VP8] codec.
  ///
  /// [VP8]: https://en.wikipedia.org/wiki/VP8
  vp8,

  /// [VP9] codec.
  ///
  /// [VP9]: https://en.wikipedia.org/wiki/VP9
  vp9,
}

/// [`VideoCodec`] info for encoding/decoding.
class VideoCodecInfo {
  /// Indicator whether hardware acceleration should be used.
  final bool isHardwareAccelerated;

  /// [`VideoCodec`] to be used for encoding/decoding.
  final VideoCodec codec;

  const VideoCodecInfo({
    required this.isHardwareAccelerated,
    required this.codec,
  });

  @override
  int get hashCode => isHardwareAccelerated.hashCode ^ codec.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is VideoCodecInfo &&
          runtimeType == other.runtimeType &&
          isHardwareAccelerated == other.isHardwareAccelerated &&
          codec == other.codec;
}

/// Nature and settings of the video [`MediaStreamTrack`] returned by
/// [`Webrtc::get_media()`].
class VideoConstraints {
  /// Identifier of the device generating the content of the
  /// [`MediaStreamTrack`].
  ///
  /// The first device will be chosen if an empty [`String`] is provided.
  final String? deviceId;

  /// Width in pixels.
  final int width;

  /// Height in pixels.
  final int height;

  /// Exact frame rate (frames per second).
  final int frameRate;

  /// Indicator whether the request video track should be acquired via screen
  /// capturing.
  final bool isDisplay;

  const VideoConstraints({
    this.deviceId,
    required this.width,
    required this.height,
    required this.frameRate,
    required this.isDisplay,
  });

  @override
  int get hashCode =>
      deviceId.hashCode ^
      width.hashCode ^
      height.hashCode ^
      frameRate.hashCode ^
      isDisplay.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is VideoConstraints &&
          runtimeType == other.runtimeType &&
          deviceId == other.deviceId &&
          width == other.width &&
          height == other.height &&
          frameRate == other.frameRate &&
          isDisplay == other.isDisplay;
}
