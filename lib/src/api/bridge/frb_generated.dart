// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'dart:async';
import 'dart:convert';

import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

import 'api.dart';
import 'frb_generated.dart';
import 'lib.dart';
import 'renderer.dart';

import 'frb_generated.io.dart'
    if (dart.library.js_interop) 'frb_generated.web.dart';

/// Main entrypoint of the Rust API
class RustLib extends BaseEntrypoint<RustLibApi, RustLibApiImpl, RustLibWire> {
  @internal
  static final instance = RustLib._();

  RustLib._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    RustLibApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
    );
  }

  /// Initialize flutter_rust_bridge in mock mode.
  /// No libraries for FFI are loaded.
  static void initMock({required RustLibApi api}) {
    instance.initMockImpl(api: api);
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<RustLibApiImpl, RustLibWire> get apiImplConstructor =>
      RustLibApiImpl.new;

  @override
  WireConstructor<RustLibWire> get wireConstructor =>
      RustLibWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {}

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig =>
      kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.9.0';

  @override
  int get rustContentHash => -40294053;

  static const kDefaultExternalLibraryLoaderConfig =
      ExternalLibraryLoaderConfig(
        stem: 'medea_flutter_webrtc_native',
        ioDirectory: 'crates/native/target/release/',
        webPrefix: 'pkg/',
      );
}

abstract class RustLibApi extends BaseApi {
  Future<void> crateApiAddIceCandidate({
    required ArcPeerConnection peer,
    required String candidate,
    required String sdpMid,
    required int sdpMlineIndex,
  });

  Future<RtcRtpTransceiver> crateApiAddTransceiver({
    required ArcPeerConnection peer,
    required MediaType mediaType,
    required RtpTransceiverInit init,
  });

  Future<AudioProcessingConstraints>
  crateApiAudioProcessingConstraintsDefault();

  Future<MediaStreamTrack?> crateApiCloneTrack({
    required String trackId,
    int? peerId,
    required MediaType kind,
  });

  Future<RtcSessionDescription> crateApiCreateAnswer({
    required ArcPeerConnection peer,
    required bool voiceActivityDetection,
    required bool iceRestart,
    required bool useRtpMux,
  });

  Future<RtcSessionDescription> crateApiCreateOffer({
    required ArcPeerConnection peer,
    required bool voiceActivityDetection,
    required bool iceRestart,
    required bool useRtpMux,
  });

  Stream<PeerConnectionEvent> crateApiCreatePeerConnection({
    required RtcConfiguration configuration,
  });

  Stream<TextureEvent> crateApiCreateVideoSink({
    required PlatformInt64 sinkId,
    int? peerId,
    required String trackId,
    required PlatformInt64 callbackPtr,
    required PlatformInt64 textureId,
  });

  Future<void> crateApiDisposePeerConnection({required ArcPeerConnection peer});

  Future<void> crateApiDisposeTrack({
    required String trackId,
    int? peerId,
    required MediaType kind,
  });

  Future<void> crateApiDisposeVideoSink({required PlatformInt64 sinkId});

  Future<void> crateApiEnableFakeMedia();

  Future<List<MediaDeviceInfo>> crateApiEnumerateDevices();

  Future<List<MediaDisplayInfo>> crateApiEnumerateDisplays();

  Future<AudioProcessingConfig> crateApiGetAudioProcessingConfig({
    required String trackId,
  });

  Future<GetMediaResult> crateApiGetMedia({
    required MediaStreamConstraints constraints,
  });

  Future<List<RtcStats>> crateApiGetPeerStats({
    required ArcPeerConnection peer,
  });

  Future<RtpCapabilities> crateApiGetRtpReceiverCapabilities({
    required MediaType kind,
  });

  Future<RtpCapabilities> crateApiGetRtpSenderCapabilities({
    required MediaType kind,
  });

  Future<RtpTransceiverDirection> crateApiGetTransceiverDirection({
    required ArcRtpTransceiver transceiver,
  });

  Future<String?> crateApiGetTransceiverMid({
    required ArcRtpTransceiver transceiver,
  });

  Future<List<RtcRtpTransceiver>> crateApiGetTransceivers({
    required ArcPeerConnection peer,
  });

  Future<bool> crateApiIsFakeMedia();

  Future<int> crateApiMicrophoneVolume();

  Future<bool> crateApiMicrophoneVolumeIsAvailable();

  Stream<TrackEvent> crateApiRegisterTrackObserver({
    int? peerId,
    required String trackId,
    required MediaType kind,
  });

  Future<void> crateApiRestartIce({required ArcPeerConnection peer});

  Future<RtcRtpSendParameters> crateApiSenderGetParameters({
    required ArcRtpTransceiver transceiver,
  });

  Future<void> crateApiSenderReplaceTrack({
    required ArcPeerConnection peer,
    required ArcRtpTransceiver transceiver,
    String? trackId,
  });

  Future<void> crateApiSenderSetParameters({
    required ArcRtpTransceiver transceiver,
    required RtcRtpSendParameters params,
  });

  Future<void> crateApiSetAudioLevelObserverEnabled({
    required String trackId,
    int? peerId,
    required bool enabled,
  });

  Future<void> crateApiSetAudioPlayoutDevice({required String deviceId});

  Future<void> crateApiSetCodecPreferences({
    required ArcRtpTransceiver transceiver,
    required List<RtpCodecCapability> codecs,
  });

  Future<void> crateApiSetLocalDescription({
    required ArcPeerConnection peer,
    required SdpType kind,
    required String sdp,
  });

  Future<void> crateApiSetMicrophoneVolume({required int level});

  Stream<void> crateApiSetOnDeviceChanged();

  Future<void> crateApiSetRemoteDescription({
    required ArcPeerConnection peer,
    required SdpType kind,
    required String sdp,
  });

  Future<void> crateApiSetTrackEnabled({
    required String trackId,
    int? peerId,
    required MediaType kind,
    required bool enabled,
  });

  Future<void> crateApiSetTransceiverDirection({
    required ArcRtpTransceiver transceiver,
    required RtpTransceiverDirection direction,
  });

  Future<void> crateApiSetTransceiverRecv({
    required ArcRtpTransceiver transceiver,
    required bool recv,
  });

  Future<void> crateApiSetTransceiverSend({
    required ArcRtpTransceiver transceiver,
    required bool send,
  });

  Future<void> crateApiStopTransceiver({
    required ArcRtpTransceiver transceiver,
  });

  Future<int?> crateApiTrackHeight({
    required String trackId,
    int? peerId,
    required MediaType kind,
  });

  Future<TrackState> crateApiTrackState({
    required String trackId,
    int? peerId,
    required MediaType kind,
  });

  Future<int?> crateApiTrackWidth({
    required String trackId,
    int? peerId,
    required MediaType kind,
  });

  Future<void> crateApiUpdateAudioProcessing({
    required String trackId,
    required AudioProcessingConstraints conf,
  });

  Future<List<VideoCodecInfo>> crateApiVideoDecoders();

  Future<List<VideoCodecInfo>> crateApiVideoEncoders();

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_ArcPeerConnection;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_ArcPeerConnection;

  CrossPlatformFinalizerArg
  get rust_arc_decrement_strong_count_ArcPeerConnectionPtr;

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_ArcRtpEncodingParameters;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_ArcRtpEncodingParameters;

  CrossPlatformFinalizerArg
  get rust_arc_decrement_strong_count_ArcRtpEncodingParametersPtr;

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_ArcRtpParameters;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_ArcRtpParameters;

  CrossPlatformFinalizerArg
  get rust_arc_decrement_strong_count_ArcRtpParametersPtr;

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_ArcRtpTransceiver;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_ArcRtpTransceiver;

  CrossPlatformFinalizerArg
  get rust_arc_decrement_strong_count_ArcRtpTransceiverPtr;
}

class RustLibApiImpl extends RustLibApiImplPlatform implements RustLibApi {
  RustLibApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  Future<void> crateApiAddIceCandidate({
    required ArcPeerConnection peer,
    required String candidate,
    required String sdpMid,
    required int sdpMlineIndex,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_RustOpaque_ArcPeerConnection(peer, serializer);
          sse_encode_String(candidate, serializer);
          sse_encode_String(sdpMid, serializer);
          sse_encode_i_32(sdpMlineIndex, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 1,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiAddIceCandidateConstMeta,
        argValues: [peer, candidate, sdpMid, sdpMlineIndex],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiAddIceCandidateConstMeta => const TaskConstMeta(
    debugName: "add_ice_candidate",
    argNames: ["peer", "candidate", "sdpMid", "sdpMlineIndex"],
  );

  @override
  Future<RtcRtpTransceiver> crateApiAddTransceiver({
    required ArcPeerConnection peer,
    required MediaType mediaType,
    required RtpTransceiverInit init,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_RustOpaque_ArcPeerConnection(peer, serializer);
          sse_encode_media_type(mediaType, serializer);
          sse_encode_box_autoadd_rtp_transceiver_init(init, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 2,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_rtc_rtp_transceiver,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiAddTransceiverConstMeta,
        argValues: [peer, mediaType, init],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiAddTransceiverConstMeta => const TaskConstMeta(
    debugName: "add_transceiver",
    argNames: ["peer", "mediaType", "init"],
  );

  @override
  Future<AudioProcessingConstraints>
  crateApiAudioProcessingConstraintsDefault() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 3,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_audio_processing_constraints,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiAudioProcessingConstraintsDefaultConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiAudioProcessingConstraintsDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "audio_processing_constraints_default",
        argNames: [],
      );

  @override
  Future<MediaStreamTrack?> crateApiCloneTrack({
    required String trackId,
    int? peerId,
    required MediaType kind,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(trackId, serializer);
          sse_encode_opt_box_autoadd_u_32(peerId, serializer);
          sse_encode_media_type(kind, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 4,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_opt_box_autoadd_media_stream_track,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiCloneTrackConstMeta,
        argValues: [trackId, peerId, kind],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCloneTrackConstMeta => const TaskConstMeta(
    debugName: "clone_track",
    argNames: ["trackId", "peerId", "kind"],
  );

  @override
  Future<RtcSessionDescription> crateApiCreateAnswer({
    required ArcPeerConnection peer,
    required bool voiceActivityDetection,
    required bool iceRestart,
    required bool useRtpMux,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_RustOpaque_ArcPeerConnection(peer, serializer);
          sse_encode_bool(voiceActivityDetection, serializer);
          sse_encode_bool(iceRestart, serializer);
          sse_encode_bool(useRtpMux, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 5,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_rtc_session_description,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiCreateAnswerConstMeta,
        argValues: [peer, voiceActivityDetection, iceRestart, useRtpMux],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCreateAnswerConstMeta => const TaskConstMeta(
    debugName: "create_answer",
    argNames: ["peer", "voiceActivityDetection", "iceRestart", "useRtpMux"],
  );

  @override
  Future<RtcSessionDescription> crateApiCreateOffer({
    required ArcPeerConnection peer,
    required bool voiceActivityDetection,
    required bool iceRestart,
    required bool useRtpMux,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_RustOpaque_ArcPeerConnection(peer, serializer);
          sse_encode_bool(voiceActivityDetection, serializer);
          sse_encode_bool(iceRestart, serializer);
          sse_encode_bool(useRtpMux, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 6,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_rtc_session_description,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiCreateOfferConstMeta,
        argValues: [peer, voiceActivityDetection, iceRestart, useRtpMux],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCreateOfferConstMeta => const TaskConstMeta(
    debugName: "create_offer",
    argNames: ["peer", "voiceActivityDetection", "iceRestart", "useRtpMux"],
  );

  @override
  Stream<PeerConnectionEvent> crateApiCreatePeerConnection({
    required RtcConfiguration configuration,
  }) {
    final cb = RustStreamSink<PeerConnectionEvent>();
    unawaited(
      handler.executeNormal(
        NormalTask(
          callFfi: (port_) {
            final serializer = SseSerializer(generalizedFrbRustBinding);
            sse_encode_StreamSink_peer_connection_event_Sse(cb, serializer);
            sse_encode_box_autoadd_rtc_configuration(configuration, serializer);
            pdeCallFfi(
              generalizedFrbRustBinding,
              serializer,
              funcId: 7,
              port: port_,
            );
          },
          codec: SseCodec(
            decodeSuccessData: sse_decode_unit,
            decodeErrorData: sse_decode_AnyhowException,
          ),
          constMeta: kCrateApiCreatePeerConnectionConstMeta,
          argValues: [cb, configuration],
          apiImpl: this,
        ),
      ),
    );
    return cb.stream;
  }

  TaskConstMeta get kCrateApiCreatePeerConnectionConstMeta =>
      const TaskConstMeta(
        debugName: "create_peer_connection",
        argNames: ["cb", "configuration"],
      );

  @override
  Stream<TextureEvent> crateApiCreateVideoSink({
    required PlatformInt64 sinkId,
    int? peerId,
    required String trackId,
    required PlatformInt64 callbackPtr,
    required PlatformInt64 textureId,
  }) {
    final cb = RustStreamSink<TextureEvent>();
    unawaited(
      handler.executeNormal(
        NormalTask(
          callFfi: (port_) {
            final serializer = SseSerializer(generalizedFrbRustBinding);
            sse_encode_StreamSink_texture_event_Sse(cb, serializer);
            sse_encode_i_64(sinkId, serializer);
            sse_encode_opt_box_autoadd_u_32(peerId, serializer);
            sse_encode_String(trackId, serializer);
            sse_encode_i_64(callbackPtr, serializer);
            sse_encode_i_64(textureId, serializer);
            pdeCallFfi(
              generalizedFrbRustBinding,
              serializer,
              funcId: 8,
              port: port_,
            );
          },
          codec: SseCodec(
            decodeSuccessData: sse_decode_unit,
            decodeErrorData: null,
          ),
          constMeta: kCrateApiCreateVideoSinkConstMeta,
          argValues: [cb, sinkId, peerId, trackId, callbackPtr, textureId],
          apiImpl: this,
        ),
      ),
    );
    return cb.stream;
  }

  TaskConstMeta get kCrateApiCreateVideoSinkConstMeta => const TaskConstMeta(
    debugName: "create_video_sink",
    argNames: ["cb", "sinkId", "peerId", "trackId", "callbackPtr", "textureId"],
  );

  @override
  Future<void> crateApiDisposePeerConnection({
    required ArcPeerConnection peer,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_RustOpaque_ArcPeerConnection(peer, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 9,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiDisposePeerConnectionConstMeta,
        argValues: [peer],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDisposePeerConnectionConstMeta =>
      const TaskConstMeta(
        debugName: "dispose_peer_connection",
        argNames: ["peer"],
      );

  @override
  Future<void> crateApiDisposeTrack({
    required String trackId,
    int? peerId,
    required MediaType kind,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(trackId, serializer);
          sse_encode_opt_box_autoadd_u_32(peerId, serializer);
          sse_encode_media_type(kind, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 10,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiDisposeTrackConstMeta,
        argValues: [trackId, peerId, kind],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDisposeTrackConstMeta => const TaskConstMeta(
    debugName: "dispose_track",
    argNames: ["trackId", "peerId", "kind"],
  );

  @override
  Future<void> crateApiDisposeVideoSink({required PlatformInt64 sinkId}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_i_64(sinkId, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 11,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiDisposeVideoSinkConstMeta,
        argValues: [sinkId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDisposeVideoSinkConstMeta => const TaskConstMeta(
    debugName: "dispose_video_sink",
    argNames: ["sinkId"],
  );

  @override
  Future<void> crateApiEnableFakeMedia() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 12,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiEnableFakeMediaConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiEnableFakeMediaConstMeta =>
      const TaskConstMeta(debugName: "enable_fake_media", argNames: []);

  @override
  Future<List<MediaDeviceInfo>> crateApiEnumerateDevices() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 13,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_media_device_info,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiEnumerateDevicesConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiEnumerateDevicesConstMeta =>
      const TaskConstMeta(debugName: "enumerate_devices", argNames: []);

  @override
  Future<List<MediaDisplayInfo>> crateApiEnumerateDisplays() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 14,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_media_display_info,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiEnumerateDisplaysConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiEnumerateDisplaysConstMeta =>
      const TaskConstMeta(debugName: "enumerate_displays", argNames: []);

  @override
  Future<AudioProcessingConfig> crateApiGetAudioProcessingConfig({
    required String trackId,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(trackId, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 15,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_audio_processing_config,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiGetAudioProcessingConfigConstMeta,
        argValues: [trackId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetAudioProcessingConfigConstMeta =>
      const TaskConstMeta(
        debugName: "get_audio_processing_config",
        argNames: ["trackId"],
      );

  @override
  Future<GetMediaResult> crateApiGetMedia({
    required MediaStreamConstraints constraints,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_media_stream_constraints(
            constraints,
            serializer,
          );
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 16,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_get_media_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiGetMediaConstMeta,
        argValues: [constraints],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetMediaConstMeta =>
      const TaskConstMeta(debugName: "get_media", argNames: ["constraints"]);

  @override
  Future<List<RtcStats>> crateApiGetPeerStats({
    required ArcPeerConnection peer,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_RustOpaque_ArcPeerConnection(peer, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 17,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_rtc_stats,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiGetPeerStatsConstMeta,
        argValues: [peer],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetPeerStatsConstMeta =>
      const TaskConstMeta(debugName: "get_peer_stats", argNames: ["peer"]);

  @override
  Future<RtpCapabilities> crateApiGetRtpReceiverCapabilities({
    required MediaType kind,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_media_type(kind, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 18,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_rtp_capabilities,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiGetRtpReceiverCapabilitiesConstMeta,
        argValues: [kind],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetRtpReceiverCapabilitiesConstMeta =>
      const TaskConstMeta(
        debugName: "get_rtp_receiver_capabilities",
        argNames: ["kind"],
      );

  @override
  Future<RtpCapabilities> crateApiGetRtpSenderCapabilities({
    required MediaType kind,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_media_type(kind, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 19,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_rtp_capabilities,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiGetRtpSenderCapabilitiesConstMeta,
        argValues: [kind],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetRtpSenderCapabilitiesConstMeta =>
      const TaskConstMeta(
        debugName: "get_rtp_sender_capabilities",
        argNames: ["kind"],
      );

  @override
  Future<RtpTransceiverDirection> crateApiGetTransceiverDirection({
    required ArcRtpTransceiver transceiver,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_RustOpaque_ArcRtpTransceiver(transceiver, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 20,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_rtp_transceiver_direction,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiGetTransceiverDirectionConstMeta,
        argValues: [transceiver],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetTransceiverDirectionConstMeta =>
      const TaskConstMeta(
        debugName: "get_transceiver_direction",
        argNames: ["transceiver"],
      );

  @override
  Future<String?> crateApiGetTransceiverMid({
    required ArcRtpTransceiver transceiver,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_RustOpaque_ArcRtpTransceiver(transceiver, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 21,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_opt_String,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiGetTransceiverMidConstMeta,
        argValues: [transceiver],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetTransceiverMidConstMeta => const TaskConstMeta(
    debugName: "get_transceiver_mid",
    argNames: ["transceiver"],
  );

  @override
  Future<List<RtcRtpTransceiver>> crateApiGetTransceivers({
    required ArcPeerConnection peer,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_RustOpaque_ArcPeerConnection(peer, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 22,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_rtc_rtp_transceiver,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiGetTransceiversConstMeta,
        argValues: [peer],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetTransceiversConstMeta =>
      const TaskConstMeta(debugName: "get_transceivers", argNames: ["peer"]);

  @override
  Future<bool> crateApiIsFakeMedia() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 23,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiIsFakeMediaConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiIsFakeMediaConstMeta =>
      const TaskConstMeta(debugName: "is_fake_media", argNames: []);

  @override
  Future<int> crateApiMicrophoneVolume() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 24,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_u_32,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiMicrophoneVolumeConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiMicrophoneVolumeConstMeta =>
      const TaskConstMeta(debugName: "microphone_volume", argNames: []);

  @override
  Future<bool> crateApiMicrophoneVolumeIsAvailable() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 25,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiMicrophoneVolumeIsAvailableConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiMicrophoneVolumeIsAvailableConstMeta =>
      const TaskConstMeta(
        debugName: "microphone_volume_is_available",
        argNames: [],
      );

  @override
  Stream<TrackEvent> crateApiRegisterTrackObserver({
    int? peerId,
    required String trackId,
    required MediaType kind,
  }) {
    final cb = RustStreamSink<TrackEvent>();
    unawaited(
      handler.executeNormal(
        NormalTask(
          callFfi: (port_) {
            final serializer = SseSerializer(generalizedFrbRustBinding);
            sse_encode_StreamSink_track_event_Sse(cb, serializer);
            sse_encode_opt_box_autoadd_u_32(peerId, serializer);
            sse_encode_String(trackId, serializer);
            sse_encode_media_type(kind, serializer);
            pdeCallFfi(
              generalizedFrbRustBinding,
              serializer,
              funcId: 26,
              port: port_,
            );
          },
          codec: SseCodec(
            decodeSuccessData: sse_decode_unit,
            decodeErrorData: null,
          ),
          constMeta: kCrateApiRegisterTrackObserverConstMeta,
          argValues: [cb, peerId, trackId, kind],
          apiImpl: this,
        ),
      ),
    );
    return cb.stream;
  }

  TaskConstMeta get kCrateApiRegisterTrackObserverConstMeta =>
      const TaskConstMeta(
        debugName: "register_track_observer",
        argNames: ["cb", "peerId", "trackId", "kind"],
      );

  @override
  Future<void> crateApiRestartIce({required ArcPeerConnection peer}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_RustOpaque_ArcPeerConnection(peer, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 27,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiRestartIceConstMeta,
        argValues: [peer],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiRestartIceConstMeta =>
      const TaskConstMeta(debugName: "restart_ice", argNames: ["peer"]);

  @override
  Future<RtcRtpSendParameters> crateApiSenderGetParameters({
    required ArcRtpTransceiver transceiver,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_RustOpaque_ArcRtpTransceiver(transceiver, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 28,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_rtc_rtp_send_parameters,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiSenderGetParametersConstMeta,
        argValues: [transceiver],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSenderGetParametersConstMeta =>
      const TaskConstMeta(
        debugName: "sender_get_parameters",
        argNames: ["transceiver"],
      );

  @override
  Future<void> crateApiSenderReplaceTrack({
    required ArcPeerConnection peer,
    required ArcRtpTransceiver transceiver,
    String? trackId,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_RustOpaque_ArcPeerConnection(peer, serializer);
          sse_encode_RustOpaque_ArcRtpTransceiver(transceiver, serializer);
          sse_encode_opt_String(trackId, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 29,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiSenderReplaceTrackConstMeta,
        argValues: [peer, transceiver, trackId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSenderReplaceTrackConstMeta => const TaskConstMeta(
    debugName: "sender_replace_track",
    argNames: ["peer", "transceiver", "trackId"],
  );

  @override
  Future<void> crateApiSenderSetParameters({
    required ArcRtpTransceiver transceiver,
    required RtcRtpSendParameters params,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_RustOpaque_ArcRtpTransceiver(transceiver, serializer);
          sse_encode_box_autoadd_rtc_rtp_send_parameters(params, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 30,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiSenderSetParametersConstMeta,
        argValues: [transceiver, params],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSenderSetParametersConstMeta =>
      const TaskConstMeta(
        debugName: "sender_set_parameters",
        argNames: ["transceiver", "params"],
      );

  @override
  Future<void> crateApiSetAudioLevelObserverEnabled({
    required String trackId,
    int? peerId,
    required bool enabled,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(trackId, serializer);
          sse_encode_opt_box_autoadd_u_32(peerId, serializer);
          sse_encode_bool(enabled, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 31,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiSetAudioLevelObserverEnabledConstMeta,
        argValues: [trackId, peerId, enabled],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSetAudioLevelObserverEnabledConstMeta =>
      const TaskConstMeta(
        debugName: "set_audio_level_observer_enabled",
        argNames: ["trackId", "peerId", "enabled"],
      );

  @override
  Future<void> crateApiSetAudioPlayoutDevice({required String deviceId}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(deviceId, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 32,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiSetAudioPlayoutDeviceConstMeta,
        argValues: [deviceId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSetAudioPlayoutDeviceConstMeta =>
      const TaskConstMeta(
        debugName: "set_audio_playout_device",
        argNames: ["deviceId"],
      );

  @override
  Future<void> crateApiSetCodecPreferences({
    required ArcRtpTransceiver transceiver,
    required List<RtpCodecCapability> codecs,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_RustOpaque_ArcRtpTransceiver(transceiver, serializer);
          sse_encode_list_rtp_codec_capability(codecs, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 33,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiSetCodecPreferencesConstMeta,
        argValues: [transceiver, codecs],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSetCodecPreferencesConstMeta =>
      const TaskConstMeta(
        debugName: "set_codec_preferences",
        argNames: ["transceiver", "codecs"],
      );

  @override
  Future<void> crateApiSetLocalDescription({
    required ArcPeerConnection peer,
    required SdpType kind,
    required String sdp,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_RustOpaque_ArcPeerConnection(peer, serializer);
          sse_encode_sdp_type(kind, serializer);
          sse_encode_String(sdp, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 34,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiSetLocalDescriptionConstMeta,
        argValues: [peer, kind, sdp],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSetLocalDescriptionConstMeta =>
      const TaskConstMeta(
        debugName: "set_local_description",
        argNames: ["peer", "kind", "sdp"],
      );

  @override
  Future<void> crateApiSetMicrophoneVolume({required int level}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_u_8(level, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 35,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiSetMicrophoneVolumeConstMeta,
        argValues: [level],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSetMicrophoneVolumeConstMeta =>
      const TaskConstMeta(
        debugName: "set_microphone_volume",
        argNames: ["level"],
      );

  @override
  Stream<void> crateApiSetOnDeviceChanged() {
    final cb = RustStreamSink<void>();
    unawaited(
      handler.executeNormal(
        NormalTask(
          callFfi: (port_) {
            final serializer = SseSerializer(generalizedFrbRustBinding);
            sse_encode_StreamSink_unit_Sse(cb, serializer);
            pdeCallFfi(
              generalizedFrbRustBinding,
              serializer,
              funcId: 36,
              port: port_,
            );
          },
          codec: SseCodec(
            decodeSuccessData: sse_decode_unit,
            decodeErrorData: null,
          ),
          constMeta: kCrateApiSetOnDeviceChangedConstMeta,
          argValues: [cb],
          apiImpl: this,
        ),
      ),
    );
    return cb.stream;
  }

  TaskConstMeta get kCrateApiSetOnDeviceChangedConstMeta =>
      const TaskConstMeta(debugName: "set_on_device_changed", argNames: ["cb"]);

  @override
  Future<void> crateApiSetRemoteDescription({
    required ArcPeerConnection peer,
    required SdpType kind,
    required String sdp,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_RustOpaque_ArcPeerConnection(peer, serializer);
          sse_encode_sdp_type(kind, serializer);
          sse_encode_String(sdp, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 37,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiSetRemoteDescriptionConstMeta,
        argValues: [peer, kind, sdp],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSetRemoteDescriptionConstMeta =>
      const TaskConstMeta(
        debugName: "set_remote_description",
        argNames: ["peer", "kind", "sdp"],
      );

  @override
  Future<void> crateApiSetTrackEnabled({
    required String trackId,
    int? peerId,
    required MediaType kind,
    required bool enabled,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(trackId, serializer);
          sse_encode_opt_box_autoadd_u_32(peerId, serializer);
          sse_encode_media_type(kind, serializer);
          sse_encode_bool(enabled, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 38,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiSetTrackEnabledConstMeta,
        argValues: [trackId, peerId, kind, enabled],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSetTrackEnabledConstMeta => const TaskConstMeta(
    debugName: "set_track_enabled",
    argNames: ["trackId", "peerId", "kind", "enabled"],
  );

  @override
  Future<void> crateApiSetTransceiverDirection({
    required ArcRtpTransceiver transceiver,
    required RtpTransceiverDirection direction,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_RustOpaque_ArcRtpTransceiver(transceiver, serializer);
          sse_encode_rtp_transceiver_direction(direction, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 39,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiSetTransceiverDirectionConstMeta,
        argValues: [transceiver, direction],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSetTransceiverDirectionConstMeta =>
      const TaskConstMeta(
        debugName: "set_transceiver_direction",
        argNames: ["transceiver", "direction"],
      );

  @override
  Future<void> crateApiSetTransceiverRecv({
    required ArcRtpTransceiver transceiver,
    required bool recv,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_RustOpaque_ArcRtpTransceiver(transceiver, serializer);
          sse_encode_bool(recv, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 40,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiSetTransceiverRecvConstMeta,
        argValues: [transceiver, recv],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSetTransceiverRecvConstMeta => const TaskConstMeta(
    debugName: "set_transceiver_recv",
    argNames: ["transceiver", "recv"],
  );

  @override
  Future<void> crateApiSetTransceiverSend({
    required ArcRtpTransceiver transceiver,
    required bool send,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_RustOpaque_ArcRtpTransceiver(transceiver, serializer);
          sse_encode_bool(send, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 41,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiSetTransceiverSendConstMeta,
        argValues: [transceiver, send],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSetTransceiverSendConstMeta => const TaskConstMeta(
    debugName: "set_transceiver_send",
    argNames: ["transceiver", "send"],
  );

  @override
  Future<void> crateApiStopTransceiver({
    required ArcRtpTransceiver transceiver,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_RustOpaque_ArcRtpTransceiver(transceiver, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 42,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiStopTransceiverConstMeta,
        argValues: [transceiver],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiStopTransceiverConstMeta => const TaskConstMeta(
    debugName: "stop_transceiver",
    argNames: ["transceiver"],
  );

  @override
  Future<int?> crateApiTrackHeight({
    required String trackId,
    int? peerId,
    required MediaType kind,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(trackId, serializer);
          sse_encode_opt_box_autoadd_u_32(peerId, serializer);
          sse_encode_media_type(kind, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 43,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_opt_box_autoadd_i_32,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiTrackHeightConstMeta,
        argValues: [trackId, peerId, kind],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiTrackHeightConstMeta => const TaskConstMeta(
    debugName: "track_height",
    argNames: ["trackId", "peerId", "kind"],
  );

  @override
  Future<TrackState> crateApiTrackState({
    required String trackId,
    int? peerId,
    required MediaType kind,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(trackId, serializer);
          sse_encode_opt_box_autoadd_u_32(peerId, serializer);
          sse_encode_media_type(kind, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 44,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_track_state,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiTrackStateConstMeta,
        argValues: [trackId, peerId, kind],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiTrackStateConstMeta => const TaskConstMeta(
    debugName: "track_state",
    argNames: ["trackId", "peerId", "kind"],
  );

  @override
  Future<int?> crateApiTrackWidth({
    required String trackId,
    int? peerId,
    required MediaType kind,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(trackId, serializer);
          sse_encode_opt_box_autoadd_u_32(peerId, serializer);
          sse_encode_media_type(kind, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 45,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_opt_box_autoadd_i_32,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiTrackWidthConstMeta,
        argValues: [trackId, peerId, kind],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiTrackWidthConstMeta => const TaskConstMeta(
    debugName: "track_width",
    argNames: ["trackId", "peerId", "kind"],
  );

  @override
  Future<void> crateApiUpdateAudioProcessing({
    required String trackId,
    required AudioProcessingConstraints conf,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(trackId, serializer);
          sse_encode_box_autoadd_audio_processing_constraints(conf, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 46,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiUpdateAudioProcessingConstMeta,
        argValues: [trackId, conf],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiUpdateAudioProcessingConstMeta =>
      const TaskConstMeta(
        debugName: "update_audio_processing",
        argNames: ["trackId", "conf"],
      );

  @override
  Future<List<VideoCodecInfo>> crateApiVideoDecoders() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 47,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_video_codec_info,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiVideoDecodersConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiVideoDecodersConstMeta =>
      const TaskConstMeta(debugName: "video_decoders", argNames: []);

  @override
  Future<List<VideoCodecInfo>> crateApiVideoEncoders() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 48,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_video_codec_info,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiVideoEncodersConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiVideoEncodersConstMeta =>
      const TaskConstMeta(debugName: "video_encoders", argNames: []);

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_ArcPeerConnection =>
      wire.rust_arc_increment_strong_count_RustOpaque_ArcPeerConnection;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_ArcPeerConnection =>
      wire.rust_arc_decrement_strong_count_RustOpaque_ArcPeerConnection;

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_ArcRtpEncodingParameters =>
      wire.rust_arc_increment_strong_count_RustOpaque_ArcRtpEncodingParameters;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_ArcRtpEncodingParameters =>
      wire.rust_arc_decrement_strong_count_RustOpaque_ArcRtpEncodingParameters;

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_ArcRtpParameters =>
      wire.rust_arc_increment_strong_count_RustOpaque_ArcRtpParameters;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_ArcRtpParameters =>
      wire.rust_arc_decrement_strong_count_RustOpaque_ArcRtpParameters;

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_ArcRtpTransceiver =>
      wire.rust_arc_increment_strong_count_RustOpaque_ArcRtpTransceiver;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_ArcRtpTransceiver =>
      wire.rust_arc_decrement_strong_count_RustOpaque_ArcRtpTransceiver;

  @protected
  AnyhowException dco_decode_AnyhowException(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AnyhowException(raw as String);
  }

  @protected
  ArcPeerConnection dco_decode_RustOpaque_ArcPeerConnection(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ArcPeerConnectionImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ArcRtpEncodingParameters dco_decode_RustOpaque_ArcRtpEncodingParameters(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ArcRtpEncodingParametersImpl.frbInternalDcoDecode(
      raw as List<dynamic>,
    );
  }

  @protected
  ArcRtpParameters dco_decode_RustOpaque_ArcRtpParameters(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ArcRtpParametersImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ArcRtpTransceiver dco_decode_RustOpaque_ArcRtpTransceiver(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ArcRtpTransceiverImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  RustStreamSink<PeerConnectionEvent>
  dco_decode_StreamSink_peer_connection_event_Sse(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  RustStreamSink<TextureEvent> dco_decode_StreamSink_texture_event_Sse(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  RustStreamSink<TrackEvent> dco_decode_StreamSink_track_event_Sse(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  RustStreamSink<void> dco_decode_StreamSink_unit_Sse(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  AudioConstraints dco_decode_audio_constraints(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return AudioConstraints(
      deviceId: dco_decode_opt_String(arr[0]),
      processing: dco_decode_audio_processing_constraints(arr[1]),
    );
  }

  @protected
  AudioProcessingConfig dco_decode_audio_processing_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return AudioProcessingConfig(
      autoGainControl: dco_decode_bool(arr[0]),
      highPassFilter: dco_decode_bool(arr[1]),
      noiseSuppression: dco_decode_bool(arr[2]),
      noiseSuppressionLevel: dco_decode_noise_suppression_level(arr[3]),
      echoCancellation: dco_decode_bool(arr[4]),
    );
  }

  @protected
  AudioProcessingConstraints dco_decode_audio_processing_constraints(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return AudioProcessingConstraints(
      autoGainControl: dco_decode_opt_box_autoadd_bool(arr[0]),
      highPassFilter: dco_decode_opt_box_autoadd_bool(arr[1]),
      noiseSuppression: dco_decode_opt_box_autoadd_bool(arr[2]),
      noiseSuppressionLevel: dco_decode_opt_box_autoadd_noise_suppression_level(
        arr[3],
      ),
      echoCancellation: dco_decode_opt_box_autoadd_bool(arr[4]),
    );
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  AudioConstraints dco_decode_box_autoadd_audio_constraints(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_audio_constraints(raw);
  }

  @protected
  AudioProcessingConstraints
  dco_decode_box_autoadd_audio_processing_constraints(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_audio_processing_constraints(raw);
  }

  @protected
  bool dco_decode_box_autoadd_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  double dco_decode_box_autoadd_f_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  GetMediaError dco_decode_box_autoadd_get_media_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_get_media_error(raw);
  }

  @protected
  int dco_decode_box_autoadd_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  IceCandidateStats dco_decode_box_autoadd_ice_candidate_stats(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ice_candidate_stats(raw);
  }

  @protected
  IceRole dco_decode_box_autoadd_ice_role(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ice_role(raw);
  }

  @protected
  MediaStreamConstraints dco_decode_box_autoadd_media_stream_constraints(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_media_stream_constraints(raw);
  }

  @protected
  MediaStreamTrack dco_decode_box_autoadd_media_stream_track(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_media_stream_track(raw);
  }

  @protected
  NoiseSuppressionLevel dco_decode_box_autoadd_noise_suppression_level(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_noise_suppression_level(raw);
  }

  @protected
  Protocol dco_decode_box_autoadd_protocol(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_protocol(raw);
  }

  @protected
  RtcConfiguration dco_decode_box_autoadd_rtc_configuration(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_rtc_configuration(raw);
  }

  @protected
  RtcIceCandidateStats dco_decode_box_autoadd_rtc_ice_candidate_stats(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_rtc_ice_candidate_stats(raw);
  }

  @protected
  RtcInboundRtpStreamMediaType
  dco_decode_box_autoadd_rtc_inbound_rtp_stream_media_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_rtc_inbound_rtp_stream_media_type(raw);
  }

  @protected
  RtcMediaSourceStatsMediaType
  dco_decode_box_autoadd_rtc_media_source_stats_media_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_rtc_media_source_stats_media_type(raw);
  }

  @protected
  RtcOutboundRtpStreamStatsMediaType
  dco_decode_box_autoadd_rtc_outbound_rtp_stream_stats_media_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_rtc_outbound_rtp_stream_stats_media_type(raw);
  }

  @protected
  RtcRtpSendParameters dco_decode_box_autoadd_rtc_rtp_send_parameters(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_rtc_rtp_send_parameters(raw);
  }

  @protected
  RtcTrackEvent dco_decode_box_autoadd_rtc_track_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_rtc_track_event(raw);
  }

  @protected
  RtcpFeedbackMessageType dco_decode_box_autoadd_rtcp_feedback_message_type(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_rtcp_feedback_message_type(raw);
  }

  @protected
  RtpTransceiverInit dco_decode_box_autoadd_rtp_transceiver_init(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_rtp_transceiver_init(raw);
  }

  @protected
  int dco_decode_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  BigInt dco_decode_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_u_64(raw);
  }

  @protected
  VideoConstraints dco_decode_box_autoadd_video_constraints(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_video_constraints(raw);
  }

  @protected
  BundlePolicy dco_decode_bundle_policy(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return BundlePolicy.values[raw as int];
  }

  @protected
  CandidateType dco_decode_candidate_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return CandidateType.values[raw as int];
  }

  @protected
  double dco_decode_f_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  GetMediaError dco_decode_get_media_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return GetMediaError_Audio(dco_decode_String(raw[1]));
      case 1:
        return GetMediaError_Video(dco_decode_String(raw[1]));
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  GetMediaResult dco_decode_get_media_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return GetMediaResult_Ok(dco_decode_list_media_stream_track(raw[1]));
      case 1:
        return GetMediaResult_Err(
          dco_decode_box_autoadd_get_media_error(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  PlatformInt64 dco_decode_i_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeI64(raw);
  }

  @protected
  IceCandidateStats dco_decode_ice_candidate_stats(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 8)
      throw Exception('unexpected arr length: expect 8 but see ${arr.length}');
    return IceCandidateStats(
      transportId: dco_decode_opt_String(arr[0]),
      address: dco_decode_opt_String(arr[1]),
      port: dco_decode_opt_box_autoadd_i_32(arr[2]),
      protocol: dco_decode_protocol(arr[3]),
      candidateType: dco_decode_candidate_type(arr[4]),
      priority: dco_decode_opt_box_autoadd_i_32(arr[5]),
      url: dco_decode_opt_String(arr[6]),
      relayProtocol: dco_decode_opt_box_autoadd_protocol(arr[7]),
    );
  }

  @protected
  IceConnectionState dco_decode_ice_connection_state(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return IceConnectionState.values[raw as int];
  }

  @protected
  IceGatheringState dco_decode_ice_gathering_state(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return IceGatheringState.values[raw as int];
  }

  @protected
  IceRole dco_decode_ice_role(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return IceRole.values[raw as int];
  }

  @protected
  IceTransportsType dco_decode_ice_transports_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return IceTransportsType.values[raw as int];
  }

  @protected
  List<String> dco_decode_list_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_String).toList();
  }

  @protected
  List<MediaDeviceInfo> dco_decode_list_media_device_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_media_device_info).toList();
  }

  @protected
  List<MediaDisplayInfo> dco_decode_list_media_display_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_media_display_info).toList();
  }

  @protected
  List<MediaStreamTrack> dco_decode_list_media_stream_track(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_media_stream_track).toList();
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  List<(RtcRtpEncodingParameters, ArcRtpEncodingParameters)>
  dco_decode_list_record_rtc_rtp_encoding_parameters_rust_opaque_arc_rtp_encoding_parameters(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(
          dco_decode_record_rtc_rtp_encoding_parameters_rust_opaque_arc_rtp_encoding_parameters,
        )
        .toList();
  }

  @protected
  List<(String, String)> dco_decode_list_record_string_string(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_record_string_string).toList();
  }

  @protected
  List<RtcIceServer> dco_decode_list_rtc_ice_server(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_rtc_ice_server).toList();
  }

  @protected
  List<RtcRtpEncodingParameters> dco_decode_list_rtc_rtp_encoding_parameters(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_rtc_rtp_encoding_parameters)
        .toList();
  }

  @protected
  List<RtcRtpTransceiver> dco_decode_list_rtc_rtp_transceiver(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_rtc_rtp_transceiver).toList();
  }

  @protected
  List<RtcStats> dco_decode_list_rtc_stats(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_rtc_stats).toList();
  }

  @protected
  List<RtcpFeedback> dco_decode_list_rtcp_feedback(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_rtcp_feedback).toList();
  }

  @protected
  List<RtpCodecCapability> dco_decode_list_rtp_codec_capability(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_rtp_codec_capability).toList();
  }

  @protected
  List<RtpHeaderExtensionCapability>
  dco_decode_list_rtp_header_extension_capability(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_rtp_header_extension_capability)
        .toList();
  }

  @protected
  List<ScalabilityMode> dco_decode_list_scalability_mode(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_scalability_mode).toList();
  }

  @protected
  List<VideoCodecInfo> dco_decode_list_video_codec_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_video_codec_info).toList();
  }

  @protected
  MediaDeviceInfo dco_decode_media_device_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return MediaDeviceInfo(
      deviceId: dco_decode_String(arr[0]),
      kind: dco_decode_media_device_kind(arr[1]),
      label: dco_decode_String(arr[2]),
    );
  }

  @protected
  MediaDeviceKind dco_decode_media_device_kind(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MediaDeviceKind.values[raw as int];
  }

  @protected
  MediaDisplayInfo dco_decode_media_display_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return MediaDisplayInfo(
      deviceId: dco_decode_String(arr[0]),
      title: dco_decode_opt_String(arr[1]),
    );
  }

  @protected
  MediaStreamConstraints dco_decode_media_stream_constraints(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return MediaStreamConstraints(
      audio: dco_decode_opt_box_autoadd_audio_constraints(arr[0]),
      video: dco_decode_opt_box_autoadd_video_constraints(arr[1]),
    );
  }

  @protected
  MediaStreamTrack dco_decode_media_stream_track(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return MediaStreamTrack(
      id: dco_decode_String(arr[0]),
      peerId: dco_decode_opt_box_autoadd_u_32(arr[1]),
      deviceId: dco_decode_String(arr[2]),
      kind: dco_decode_media_type(arr[3]),
      enabled: dco_decode_bool(arr[4]),
    );
  }

  @protected
  MediaType dco_decode_media_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MediaType.values[raw as int];
  }

  @protected
  NoiseSuppressionLevel dco_decode_noise_suppression_level(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return NoiseSuppressionLevel.values[raw as int];
  }

  @protected
  String? dco_decode_opt_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_String(raw);
  }

  @protected
  AudioConstraints? dco_decode_opt_box_autoadd_audio_constraints(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_audio_constraints(raw);
  }

  @protected
  bool? dco_decode_opt_box_autoadd_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_bool(raw);
  }

  @protected
  double? dco_decode_opt_box_autoadd_f_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_f_64(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_i_32(raw);
  }

  @protected
  IceRole? dco_decode_opt_box_autoadd_ice_role(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_ice_role(raw);
  }

  @protected
  MediaStreamTrack? dco_decode_opt_box_autoadd_media_stream_track(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_media_stream_track(raw);
  }

  @protected
  NoiseSuppressionLevel? dco_decode_opt_box_autoadd_noise_suppression_level(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_noise_suppression_level(raw);
  }

  @protected
  Protocol? dco_decode_opt_box_autoadd_protocol(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_protocol(raw);
  }

  @protected
  RtcInboundRtpStreamMediaType?
  dco_decode_opt_box_autoadd_rtc_inbound_rtp_stream_media_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_rtc_inbound_rtp_stream_media_type(raw);
  }

  @protected
  RtcpFeedbackMessageType?
  dco_decode_opt_box_autoadd_rtcp_feedback_message_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_rtcp_feedback_message_type(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_32(raw);
  }

  @protected
  BigInt? dco_decode_opt_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_64(raw);
  }

  @protected
  VideoConstraints? dco_decode_opt_box_autoadd_video_constraints(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_video_constraints(raw);
  }

  @protected
  PeerConnectionEvent dco_decode_peer_connection_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return PeerConnectionEvent_PeerCreated(
          peer: dco_decode_RustOpaque_ArcPeerConnection(raw[1]),
        );
      case 1:
        return PeerConnectionEvent_IceCandidate(
          sdpMid: dco_decode_String(raw[1]),
          sdpMlineIndex: dco_decode_i_32(raw[2]),
          candidate: dco_decode_String(raw[3]),
        );
      case 2:
        return PeerConnectionEvent_IceGatheringStateChange(
          dco_decode_ice_gathering_state(raw[1]),
        );
      case 3:
        return PeerConnectionEvent_IceCandidateError(
          address: dco_decode_String(raw[1]),
          port: dco_decode_i_32(raw[2]),
          url: dco_decode_String(raw[3]),
          errorCode: dco_decode_i_32(raw[4]),
          errorText: dco_decode_String(raw[5]),
        );
      case 4:
        return PeerConnectionEvent_NegotiationNeeded();
      case 5:
        return PeerConnectionEvent_SignallingChange(
          dco_decode_signaling_state(raw[1]),
        );
      case 6:
        return PeerConnectionEvent_IceConnectionStateChange(
          dco_decode_ice_connection_state(raw[1]),
        );
      case 7:
        return PeerConnectionEvent_ConnectionStateChange(
          dco_decode_peer_connection_state(raw[1]),
        );
      case 8:
        return PeerConnectionEvent_Track(
          dco_decode_box_autoadd_rtc_track_event(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  PeerConnectionState dco_decode_peer_connection_state(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PeerConnectionState.values[raw as int];
  }

  @protected
  Protocol dco_decode_protocol(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Protocol.values[raw as int];
  }

  @protected
  (RtcRtpEncodingParameters, ArcRtpEncodingParameters)
  dco_decode_record_rtc_rtp_encoding_parameters_rust_opaque_arc_rtp_encoding_parameters(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_rtc_rtp_encoding_parameters(arr[0]),
      dco_decode_RustOpaque_ArcRtpEncodingParameters(arr[1]),
    );
  }

  @protected
  (String, String) dco_decode_record_string_string(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (dco_decode_String(arr[0]), dco_decode_String(arr[1]));
  }

  @protected
  RtcConfiguration dco_decode_rtc_configuration(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return RtcConfiguration(
      iceTransportPolicy: dco_decode_ice_transports_type(arr[0]),
      bundlePolicy: dco_decode_bundle_policy(arr[1]),
      iceServers: dco_decode_list_rtc_ice_server(arr[2]),
    );
  }

  @protected
  RtcIceCandidateStats dco_decode_rtc_ice_candidate_stats(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return RtcIceCandidateStats_Local(
          dco_decode_box_autoadd_ice_candidate_stats(raw[1]),
        );
      case 1:
        return RtcIceCandidateStats_Remote(
          dco_decode_box_autoadd_ice_candidate_stats(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  RtcIceServer dco_decode_rtc_ice_server(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return RtcIceServer(
      urls: dco_decode_list_String(arr[0]),
      username: dco_decode_String(arr[1]),
      credential: dco_decode_String(arr[2]),
    );
  }

  @protected
  RtcInboundRtpStreamMediaType dco_decode_rtc_inbound_rtp_stream_media_type(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return RtcInboundRtpStreamMediaType_Audio(
          voiceActivityFlag: dco_decode_opt_box_autoadd_bool(raw[1]),
          totalSamplesReceived: dco_decode_opt_box_autoadd_u_64(raw[2]),
          concealedSamples: dco_decode_opt_box_autoadd_u_64(raw[3]),
          silentConcealedSamples: dco_decode_opt_box_autoadd_u_64(raw[4]),
          audioLevel: dco_decode_opt_box_autoadd_f_64(raw[5]),
          totalAudioEnergy: dco_decode_opt_box_autoadd_f_64(raw[6]),
          totalSamplesDuration: dco_decode_opt_box_autoadd_f_64(raw[7]),
        );
      case 1:
        return RtcInboundRtpStreamMediaType_Video(
          framesDecoded: dco_decode_opt_box_autoadd_u_32(raw[1]),
          keyFramesDecoded: dco_decode_opt_box_autoadd_u_32(raw[2]),
          frameWidth: dco_decode_opt_box_autoadd_u_32(raw[3]),
          frameHeight: dco_decode_opt_box_autoadd_u_32(raw[4]),
          totalInterFrameDelay: dco_decode_opt_box_autoadd_f_64(raw[5]),
          framesPerSecond: dco_decode_opt_box_autoadd_f_64(raw[6]),
          firCount: dco_decode_opt_box_autoadd_u_32(raw[7]),
          pliCount: dco_decode_opt_box_autoadd_u_32(raw[8]),
          sliCount: dco_decode_opt_box_autoadd_u_32(raw[9]),
          concealmentEvents: dco_decode_opt_box_autoadd_u_64(raw[10]),
          framesReceived: dco_decode_opt_box_autoadd_i_32(raw[11]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  RtcMediaSourceStatsMediaType dco_decode_rtc_media_source_stats_media_type(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return RtcMediaSourceStatsMediaType_RtcVideoSourceStats(
          width: dco_decode_opt_box_autoadd_u_32(raw[1]),
          height: dco_decode_opt_box_autoadd_u_32(raw[2]),
          frames: dco_decode_opt_box_autoadd_u_32(raw[3]),
          framesPerSecond: dco_decode_opt_box_autoadd_f_64(raw[4]),
        );
      case 1:
        return RtcMediaSourceStatsMediaType_RtcAudioSourceStats(
          audioLevel: dco_decode_opt_box_autoadd_f_64(raw[1]),
          totalAudioEnergy: dco_decode_opt_box_autoadd_f_64(raw[2]),
          totalSamplesDuration: dco_decode_opt_box_autoadd_f_64(raw[3]),
          echoReturnLoss: dco_decode_opt_box_autoadd_f_64(raw[4]),
          echoReturnLossEnhancement: dco_decode_opt_box_autoadd_f_64(raw[5]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  RtcOutboundRtpStreamStatsMediaType
  dco_decode_rtc_outbound_rtp_stream_stats_media_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return RtcOutboundRtpStreamStatsMediaType_Audio(
          totalSamplesSent: dco_decode_opt_box_autoadd_u_64(raw[1]),
          voiceActivityFlag: dco_decode_opt_box_autoadd_bool(raw[2]),
        );
      case 1:
        return RtcOutboundRtpStreamStatsMediaType_Video(
          frameWidth: dco_decode_opt_box_autoadd_u_32(raw[1]),
          frameHeight: dco_decode_opt_box_autoadd_u_32(raw[2]),
          framesPerSecond: dco_decode_opt_box_autoadd_f_64(raw[3]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  RtcRtpEncodingParameters dco_decode_rtc_rtp_encoding_parameters(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return RtcRtpEncodingParameters(
      rid: dco_decode_String(arr[0]),
      active: dco_decode_bool(arr[1]),
      maxBitrate: dco_decode_opt_box_autoadd_i_32(arr[2]),
      maxFramerate: dco_decode_opt_box_autoadd_f_64(arr[3]),
      scaleResolutionDownBy: dco_decode_opt_box_autoadd_f_64(arr[4]),
      scalabilityMode: dco_decode_opt_String(arr[5]),
    );
  }

  @protected
  RtcRtpSendParameters dco_decode_rtc_rtp_send_parameters(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return RtcRtpSendParameters(
      encodings:
          dco_decode_list_record_rtc_rtp_encoding_parameters_rust_opaque_arc_rtp_encoding_parameters(
            arr[0],
          ),
      inner: dco_decode_RustOpaque_ArcRtpParameters(arr[1]),
    );
  }

  @protected
  RtcRtpTransceiver dco_decode_rtc_rtp_transceiver(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return RtcRtpTransceiver(
      peer: dco_decode_RustOpaque_ArcPeerConnection(arr[0]),
      transceiver: dco_decode_RustOpaque_ArcRtpTransceiver(arr[1]),
      mid: dco_decode_opt_String(arr[2]),
      direction: dco_decode_rtp_transceiver_direction(arr[3]),
    );
  }

  @protected
  RtcSessionDescription dco_decode_rtc_session_description(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return RtcSessionDescription(
      sdp: dco_decode_String(arr[0]),
      kind: dco_decode_sdp_type(arr[1]),
    );
  }

  @protected
  RtcStats dco_decode_rtc_stats(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return RtcStats(
      id: dco_decode_String(arr[0]),
      timestampUs: dco_decode_i_64(arr[1]),
      kind: dco_decode_rtc_stats_type(arr[2]),
    );
  }

  @protected
  RtcStatsIceCandidatePairState dco_decode_rtc_stats_ice_candidate_pair_state(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return RtcStatsIceCandidatePairState.values[raw as int];
  }

  @protected
  RtcStatsType dco_decode_rtc_stats_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return RtcStatsType_RtcMediaSourceStats(
          trackIdentifier: dco_decode_opt_String(raw[1]),
          kind: dco_decode_box_autoadd_rtc_media_source_stats_media_type(
            raw[2],
          ),
        );
      case 1:
        return RtcStatsType_RtcIceCandidateStats(
          dco_decode_box_autoadd_rtc_ice_candidate_stats(raw[1]),
        );
      case 2:
        return RtcStatsType_RtcOutboundRtpStreamStats(
          trackId: dco_decode_opt_String(raw[1]),
          mediaType:
              dco_decode_box_autoadd_rtc_outbound_rtp_stream_stats_media_type(
                raw[2],
              ),
          bytesSent: dco_decode_opt_box_autoadd_u_64(raw[3]),
          packetsSent: dco_decode_opt_box_autoadd_u_32(raw[4]),
          mediaSourceId: dco_decode_opt_String(raw[5]),
        );
      case 3:
        return RtcStatsType_RtcInboundRtpStreamStats(
          remoteId: dco_decode_opt_String(raw[1]),
          bytesReceived: dco_decode_opt_box_autoadd_u_64(raw[2]),
          packetsReceived: dco_decode_opt_box_autoadd_u_32(raw[3]),
          packetsLost: dco_decode_opt_box_autoadd_u_64(raw[4]),
          jitter: dco_decode_opt_box_autoadd_f_64(raw[5]),
          totalDecodeTime: dco_decode_opt_box_autoadd_f_64(raw[6]),
          jitterBufferEmittedCount: dco_decode_opt_box_autoadd_u_64(raw[7]),
          mediaType:
              dco_decode_opt_box_autoadd_rtc_inbound_rtp_stream_media_type(
                raw[8],
              ),
        );
      case 4:
        return RtcStatsType_RtcIceCandidatePairStats(
          state: dco_decode_rtc_stats_ice_candidate_pair_state(raw[1]),
          nominated: dco_decode_opt_box_autoadd_bool(raw[2]),
          bytesSent: dco_decode_opt_box_autoadd_u_64(raw[3]),
          bytesReceived: dco_decode_opt_box_autoadd_u_64(raw[4]),
          totalRoundTripTime: dco_decode_opt_box_autoadd_f_64(raw[5]),
          currentRoundTripTime: dco_decode_opt_box_autoadd_f_64(raw[6]),
          availableOutgoingBitrate: dco_decode_opt_box_autoadd_f_64(raw[7]),
        );
      case 5:
        return RtcStatsType_RtcTransportStats(
          packetsSent: dco_decode_opt_box_autoadd_u_64(raw[1]),
          packetsReceived: dco_decode_opt_box_autoadd_u_64(raw[2]),
          bytesSent: dco_decode_opt_box_autoadd_u_64(raw[3]),
          bytesReceived: dco_decode_opt_box_autoadd_u_64(raw[4]),
          iceRole: dco_decode_opt_box_autoadd_ice_role(raw[5]),
        );
      case 6:
        return RtcStatsType_RtcRemoteInboundRtpStreamStats(
          localId: dco_decode_opt_String(raw[1]),
          jitter: dco_decode_opt_box_autoadd_f_64(raw[2]),
          roundTripTime: dco_decode_opt_box_autoadd_f_64(raw[3]),
          fractionLost: dco_decode_opt_box_autoadd_f_64(raw[4]),
          reportsReceived: dco_decode_opt_box_autoadd_u_64(raw[5]),
          roundTripTimeMeasurements: dco_decode_opt_box_autoadd_i_32(raw[6]),
        );
      case 7:
        return RtcStatsType_RtcRemoteOutboundRtpStreamStats(
          localId: dco_decode_opt_String(raw[1]),
          remoteTimestamp: dco_decode_opt_box_autoadd_f_64(raw[2]),
          reportsSent: dco_decode_opt_box_autoadd_u_64(raw[3]),
        );
      case 8:
        return RtcStatsType_Unimplemented();
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  RtcTrackEvent dco_decode_rtc_track_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return RtcTrackEvent(
      track: dco_decode_media_stream_track(arr[0]),
      transceiver: dco_decode_rtc_rtp_transceiver(arr[1]),
    );
  }

  @protected
  RtcpFeedback dco_decode_rtcp_feedback(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return RtcpFeedback(
      messageType: dco_decode_opt_box_autoadd_rtcp_feedback_message_type(
        arr[0],
      ),
      kind: dco_decode_rtcp_feedback_type(arr[1]),
    );
  }

  @protected
  RtcpFeedbackMessageType dco_decode_rtcp_feedback_message_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return RtcpFeedbackMessageType.values[raw as int];
  }

  @protected
  RtcpFeedbackType dco_decode_rtcp_feedback_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return RtcpFeedbackType.values[raw as int];
  }

  @protected
  RtpCapabilities dco_decode_rtp_capabilities(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return RtpCapabilities(
      codecs: dco_decode_list_rtp_codec_capability(arr[0]),
      headerExtensions: dco_decode_list_rtp_header_extension_capability(arr[1]),
    );
  }

  @protected
  RtpCodecCapability dco_decode_rtp_codec_capability(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 9)
      throw Exception('unexpected arr length: expect 9 but see ${arr.length}');
    return RtpCodecCapability(
      preferredPayloadType: dco_decode_opt_box_autoadd_i_32(arr[0]),
      scalabilityModes: dco_decode_list_scalability_mode(arr[1]),
      mimeType: dco_decode_String(arr[2]),
      name: dco_decode_String(arr[3]),
      kind: dco_decode_media_type(arr[4]),
      clockRate: dco_decode_opt_box_autoadd_i_32(arr[5]),
      numChannels: dco_decode_opt_box_autoadd_i_32(arr[6]),
      parameters: dco_decode_list_record_string_string(arr[7]),
      feedback: dco_decode_list_rtcp_feedback(arr[8]),
    );
  }

  @protected
  RtpHeaderExtensionCapability dco_decode_rtp_header_extension_capability(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return RtpHeaderExtensionCapability(
      uri: dco_decode_String(arr[0]),
      preferredId: dco_decode_opt_box_autoadd_i_32(arr[1]),
      preferredEncrypted: dco_decode_bool(arr[2]),
      direction: dco_decode_rtp_transceiver_direction(arr[3]),
    );
  }

  @protected
  RtpTransceiverDirection dco_decode_rtp_transceiver_direction(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return RtpTransceiverDirection.values[raw as int];
  }

  @protected
  RtpTransceiverInit dco_decode_rtp_transceiver_init(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return RtpTransceiverInit(
      direction: dco_decode_rtp_transceiver_direction(arr[0]),
      sendEncodings: dco_decode_list_rtc_rtp_encoding_parameters(arr[1]),
    );
  }

  @protected
  ScalabilityMode dco_decode_scalability_mode(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ScalabilityMode.values[raw as int];
  }

  @protected
  SdpType dco_decode_sdp_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SdpType.values[raw as int];
  }

  @protected
  SignalingState dco_decode_signaling_state(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SignalingState.values[raw as int];
  }

  @protected
  TextureEvent dco_decode_texture_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return TextureEvent_OnTextureChange(
          textureId: dco_decode_i_64(raw[1]),
          width: dco_decode_i_32(raw[2]),
          height: dco_decode_i_32(raw[3]),
          rotation: dco_decode_i_32(raw[4]),
        );
      case 1:
        return TextureEvent_OnFirstFrameRendered(
          textureId: dco_decode_i_64(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  TrackEvent dco_decode_track_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return TrackEvent_Ended();
      case 1:
        return TrackEvent_AudioLevelUpdated(dco_decode_u_32(raw[1]));
      case 2:
        return TrackEvent_TrackCreated();
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  TrackState dco_decode_track_state(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return TrackState.values[raw as int];
  }

  @protected
  int dco_decode_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  BigInt dco_decode_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  BigInt dco_decode_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  VideoCodec dco_decode_video_codec(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return VideoCodec.values[raw as int];
  }

  @protected
  VideoCodecInfo dco_decode_video_codec_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return VideoCodecInfo(
      isHardwareAccelerated: dco_decode_bool(arr[0]),
      codec: dco_decode_video_codec(arr[1]),
    );
  }

  @protected
  VideoConstraints dco_decode_video_constraints(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return VideoConstraints(
      deviceId: dco_decode_opt_String(arr[0]),
      width: dco_decode_u_32(arr[1]),
      height: dco_decode_u_32(arr[2]),
      frameRate: dco_decode_u_32(arr[3]),
      isDisplay: dco_decode_bool(arr[4]),
    );
  }

  @protected
  AnyhowException sse_decode_AnyhowException(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_String(deserializer);
    return AnyhowException(inner);
  }

  @protected
  ArcPeerConnection sse_decode_RustOpaque_ArcPeerConnection(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ArcPeerConnectionImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  ArcRtpEncodingParameters sse_decode_RustOpaque_ArcRtpEncodingParameters(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ArcRtpEncodingParametersImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  ArcRtpParameters sse_decode_RustOpaque_ArcRtpParameters(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ArcRtpParametersImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  ArcRtpTransceiver sse_decode_RustOpaque_ArcRtpTransceiver(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ArcRtpTransceiverImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  RustStreamSink<PeerConnectionEvent>
  sse_decode_StreamSink_peer_connection_event_Sse(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  RustStreamSink<TextureEvent> sse_decode_StreamSink_texture_event_Sse(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  RustStreamSink<TrackEvent> sse_decode_StreamSink_track_event_Sse(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  RustStreamSink<void> sse_decode_StreamSink_unit_Sse(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  AudioConstraints sse_decode_audio_constraints(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_deviceId = sse_decode_opt_String(deserializer);
    var var_processing = sse_decode_audio_processing_constraints(deserializer);
    return AudioConstraints(deviceId: var_deviceId, processing: var_processing);
  }

  @protected
  AudioProcessingConfig sse_decode_audio_processing_config(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_autoGainControl = sse_decode_bool(deserializer);
    var var_highPassFilter = sse_decode_bool(deserializer);
    var var_noiseSuppression = sse_decode_bool(deserializer);
    var var_noiseSuppressionLevel = sse_decode_noise_suppression_level(
      deserializer,
    );
    var var_echoCancellation = sse_decode_bool(deserializer);
    return AudioProcessingConfig(
      autoGainControl: var_autoGainControl,
      highPassFilter: var_highPassFilter,
      noiseSuppression: var_noiseSuppression,
      noiseSuppressionLevel: var_noiseSuppressionLevel,
      echoCancellation: var_echoCancellation,
    );
  }

  @protected
  AudioProcessingConstraints sse_decode_audio_processing_constraints(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_autoGainControl = sse_decode_opt_box_autoadd_bool(deserializer);
    var var_highPassFilter = sse_decode_opt_box_autoadd_bool(deserializer);
    var var_noiseSuppression = sse_decode_opt_box_autoadd_bool(deserializer);
    var var_noiseSuppressionLevel =
        sse_decode_opt_box_autoadd_noise_suppression_level(deserializer);
    var var_echoCancellation = sse_decode_opt_box_autoadd_bool(deserializer);
    return AudioProcessingConstraints(
      autoGainControl: var_autoGainControl,
      highPassFilter: var_highPassFilter,
      noiseSuppression: var_noiseSuppression,
      noiseSuppressionLevel: var_noiseSuppressionLevel,
      echoCancellation: var_echoCancellation,
    );
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  AudioConstraints sse_decode_box_autoadd_audio_constraints(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_audio_constraints(deserializer));
  }

  @protected
  AudioProcessingConstraints
  sse_decode_box_autoadd_audio_processing_constraints(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_audio_processing_constraints(deserializer));
  }

  @protected
  bool sse_decode_box_autoadd_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_bool(deserializer));
  }

  @protected
  double sse_decode_box_autoadd_f_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_f_64(deserializer));
  }

  @protected
  GetMediaError sse_decode_box_autoadd_get_media_error(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_get_media_error(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_i_32(deserializer));
  }

  @protected
  IceCandidateStats sse_decode_box_autoadd_ice_candidate_stats(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ice_candidate_stats(deserializer));
  }

  @protected
  IceRole sse_decode_box_autoadd_ice_role(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ice_role(deserializer));
  }

  @protected
  MediaStreamConstraints sse_decode_box_autoadd_media_stream_constraints(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_media_stream_constraints(deserializer));
  }

  @protected
  MediaStreamTrack sse_decode_box_autoadd_media_stream_track(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_media_stream_track(deserializer));
  }

  @protected
  NoiseSuppressionLevel sse_decode_box_autoadd_noise_suppression_level(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_noise_suppression_level(deserializer));
  }

  @protected
  Protocol sse_decode_box_autoadd_protocol(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_protocol(deserializer));
  }

  @protected
  RtcConfiguration sse_decode_box_autoadd_rtc_configuration(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_rtc_configuration(deserializer));
  }

  @protected
  RtcIceCandidateStats sse_decode_box_autoadd_rtc_ice_candidate_stats(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_rtc_ice_candidate_stats(deserializer));
  }

  @protected
  RtcInboundRtpStreamMediaType
  sse_decode_box_autoadd_rtc_inbound_rtp_stream_media_type(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_rtc_inbound_rtp_stream_media_type(deserializer));
  }

  @protected
  RtcMediaSourceStatsMediaType
  sse_decode_box_autoadd_rtc_media_source_stats_media_type(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_rtc_media_source_stats_media_type(deserializer));
  }

  @protected
  RtcOutboundRtpStreamStatsMediaType
  sse_decode_box_autoadd_rtc_outbound_rtp_stream_stats_media_type(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_rtc_outbound_rtp_stream_stats_media_type(deserializer));
  }

  @protected
  RtcRtpSendParameters sse_decode_box_autoadd_rtc_rtp_send_parameters(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_rtc_rtp_send_parameters(deserializer));
  }

  @protected
  RtcTrackEvent sse_decode_box_autoadd_rtc_track_event(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_rtc_track_event(deserializer));
  }

  @protected
  RtcpFeedbackMessageType sse_decode_box_autoadd_rtcp_feedback_message_type(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_rtcp_feedback_message_type(deserializer));
  }

  @protected
  RtpTransceiverInit sse_decode_box_autoadd_rtp_transceiver_init(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_rtp_transceiver_init(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_32(deserializer));
  }

  @protected
  BigInt sse_decode_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_64(deserializer));
  }

  @protected
  VideoConstraints sse_decode_box_autoadd_video_constraints(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_video_constraints(deserializer));
  }

  @protected
  BundlePolicy sse_decode_bundle_policy(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return BundlePolicy.values[inner];
  }

  @protected
  CandidateType sse_decode_candidate_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return CandidateType.values[inner];
  }

  @protected
  double sse_decode_f_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getFloat64();
  }

  @protected
  GetMediaError sse_decode_get_media_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_field0 = sse_decode_String(deserializer);
        return GetMediaError_Audio(var_field0);
      case 1:
        var var_field0 = sse_decode_String(deserializer);
        return GetMediaError_Video(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  GetMediaResult sse_decode_get_media_result(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_field0 = sse_decode_list_media_stream_track(deserializer);
        return GetMediaResult_Ok(var_field0);
      case 1:
        var var_field0 = sse_decode_box_autoadd_get_media_error(deserializer);
        return GetMediaResult_Err(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  PlatformInt64 sse_decode_i_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getPlatformInt64();
  }

  @protected
  IceCandidateStats sse_decode_ice_candidate_stats(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_transportId = sse_decode_opt_String(deserializer);
    var var_address = sse_decode_opt_String(deserializer);
    var var_port = sse_decode_opt_box_autoadd_i_32(deserializer);
    var var_protocol = sse_decode_protocol(deserializer);
    var var_candidateType = sse_decode_candidate_type(deserializer);
    var var_priority = sse_decode_opt_box_autoadd_i_32(deserializer);
    var var_url = sse_decode_opt_String(deserializer);
    var var_relayProtocol = sse_decode_opt_box_autoadd_protocol(deserializer);
    return IceCandidateStats(
      transportId: var_transportId,
      address: var_address,
      port: var_port,
      protocol: var_protocol,
      candidateType: var_candidateType,
      priority: var_priority,
      url: var_url,
      relayProtocol: var_relayProtocol,
    );
  }

  @protected
  IceConnectionState sse_decode_ice_connection_state(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return IceConnectionState.values[inner];
  }

  @protected
  IceGatheringState sse_decode_ice_gathering_state(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return IceGatheringState.values[inner];
  }

  @protected
  IceRole sse_decode_ice_role(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return IceRole.values[inner];
  }

  @protected
  IceTransportsType sse_decode_ice_transports_type(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return IceTransportsType.values[inner];
  }

  @protected
  List<String> sse_decode_list_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <String>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_String(deserializer));
    }
    return ans_;
  }

  @protected
  List<MediaDeviceInfo> sse_decode_list_media_device_info(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <MediaDeviceInfo>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_media_device_info(deserializer));
    }
    return ans_;
  }

  @protected
  List<MediaDisplayInfo> sse_decode_list_media_display_info(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <MediaDisplayInfo>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_media_display_info(deserializer));
    }
    return ans_;
  }

  @protected
  List<MediaStreamTrack> sse_decode_list_media_stream_track(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <MediaStreamTrack>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_media_stream_track(deserializer));
    }
    return ans_;
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  List<(RtcRtpEncodingParameters, ArcRtpEncodingParameters)>
  sse_decode_list_record_rtc_rtp_encoding_parameters_rust_opaque_arc_rtp_encoding_parameters(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <(RtcRtpEncodingParameters, ArcRtpEncodingParameters)>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(
        sse_decode_record_rtc_rtp_encoding_parameters_rust_opaque_arc_rtp_encoding_parameters(
          deserializer,
        ),
      );
    }
    return ans_;
  }

  @protected
  List<(String, String)> sse_decode_list_record_string_string(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <(String, String)>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_record_string_string(deserializer));
    }
    return ans_;
  }

  @protected
  List<RtcIceServer> sse_decode_list_rtc_ice_server(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <RtcIceServer>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_rtc_ice_server(deserializer));
    }
    return ans_;
  }

  @protected
  List<RtcRtpEncodingParameters> sse_decode_list_rtc_rtp_encoding_parameters(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <RtcRtpEncodingParameters>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_rtc_rtp_encoding_parameters(deserializer));
    }
    return ans_;
  }

  @protected
  List<RtcRtpTransceiver> sse_decode_list_rtc_rtp_transceiver(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <RtcRtpTransceiver>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_rtc_rtp_transceiver(deserializer));
    }
    return ans_;
  }

  @protected
  List<RtcStats> sse_decode_list_rtc_stats(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <RtcStats>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_rtc_stats(deserializer));
    }
    return ans_;
  }

  @protected
  List<RtcpFeedback> sse_decode_list_rtcp_feedback(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <RtcpFeedback>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_rtcp_feedback(deserializer));
    }
    return ans_;
  }

  @protected
  List<RtpCodecCapability> sse_decode_list_rtp_codec_capability(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <RtpCodecCapability>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_rtp_codec_capability(deserializer));
    }
    return ans_;
  }

  @protected
  List<RtpHeaderExtensionCapability>
  sse_decode_list_rtp_header_extension_capability(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <RtpHeaderExtensionCapability>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_rtp_header_extension_capability(deserializer));
    }
    return ans_;
  }

  @protected
  List<ScalabilityMode> sse_decode_list_scalability_mode(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ScalabilityMode>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_scalability_mode(deserializer));
    }
    return ans_;
  }

  @protected
  List<VideoCodecInfo> sse_decode_list_video_codec_info(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <VideoCodecInfo>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_video_codec_info(deserializer));
    }
    return ans_;
  }

  @protected
  MediaDeviceInfo sse_decode_media_device_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_deviceId = sse_decode_String(deserializer);
    var var_kind = sse_decode_media_device_kind(deserializer);
    var var_label = sse_decode_String(deserializer);
    return MediaDeviceInfo(
      deviceId: var_deviceId,
      kind: var_kind,
      label: var_label,
    );
  }

  @protected
  MediaDeviceKind sse_decode_media_device_kind(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return MediaDeviceKind.values[inner];
  }

  @protected
  MediaDisplayInfo sse_decode_media_display_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_deviceId = sse_decode_String(deserializer);
    var var_title = sse_decode_opt_String(deserializer);
    return MediaDisplayInfo(deviceId: var_deviceId, title: var_title);
  }

  @protected
  MediaStreamConstraints sse_decode_media_stream_constraints(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_audio = sse_decode_opt_box_autoadd_audio_constraints(deserializer);
    var var_video = sse_decode_opt_box_autoadd_video_constraints(deserializer);
    return MediaStreamConstraints(audio: var_audio, video: var_video);
  }

  @protected
  MediaStreamTrack sse_decode_media_stream_track(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_peerId = sse_decode_opt_box_autoadd_u_32(deserializer);
    var var_deviceId = sse_decode_String(deserializer);
    var var_kind = sse_decode_media_type(deserializer);
    var var_enabled = sse_decode_bool(deserializer);
    return MediaStreamTrack(
      id: var_id,
      peerId: var_peerId,
      deviceId: var_deviceId,
      kind: var_kind,
      enabled: var_enabled,
    );
  }

  @protected
  MediaType sse_decode_media_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return MediaType.values[inner];
  }

  @protected
  NoiseSuppressionLevel sse_decode_noise_suppression_level(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return NoiseSuppressionLevel.values[inner];
  }

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  AudioConstraints? sse_decode_opt_box_autoadd_audio_constraints(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_audio_constraints(deserializer));
    } else {
      return null;
    }
  }

  @protected
  bool? sse_decode_opt_box_autoadd_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_bool(deserializer));
    } else {
      return null;
    }
  }

  @protected
  double? sse_decode_opt_box_autoadd_f_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_f_64(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_i_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  IceRole? sse_decode_opt_box_autoadd_ice_role(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_ice_role(deserializer));
    } else {
      return null;
    }
  }

  @protected
  MediaStreamTrack? sse_decode_opt_box_autoadd_media_stream_track(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_media_stream_track(deserializer));
    } else {
      return null;
    }
  }

  @protected
  NoiseSuppressionLevel? sse_decode_opt_box_autoadd_noise_suppression_level(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_noise_suppression_level(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Protocol? sse_decode_opt_box_autoadd_protocol(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_protocol(deserializer));
    } else {
      return null;
    }
  }

  @protected
  RtcInboundRtpStreamMediaType?
  sse_decode_opt_box_autoadd_rtc_inbound_rtp_stream_media_type(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_rtc_inbound_rtp_stream_media_type(
        deserializer,
      ));
    } else {
      return null;
    }
  }

  @protected
  RtcpFeedbackMessageType?
  sse_decode_opt_box_autoadd_rtcp_feedback_message_type(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_rtcp_feedback_message_type(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  BigInt? sse_decode_opt_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_64(deserializer));
    } else {
      return null;
    }
  }

  @protected
  VideoConstraints? sse_decode_opt_box_autoadd_video_constraints(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_video_constraints(deserializer));
    } else {
      return null;
    }
  }

  @protected
  PeerConnectionEvent sse_decode_peer_connection_event(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_peer = sse_decode_RustOpaque_ArcPeerConnection(deserializer);
        return PeerConnectionEvent_PeerCreated(peer: var_peer);
      case 1:
        var var_sdpMid = sse_decode_String(deserializer);
        var var_sdpMlineIndex = sse_decode_i_32(deserializer);
        var var_candidate = sse_decode_String(deserializer);
        return PeerConnectionEvent_IceCandidate(
          sdpMid: var_sdpMid,
          sdpMlineIndex: var_sdpMlineIndex,
          candidate: var_candidate,
        );
      case 2:
        var var_field0 = sse_decode_ice_gathering_state(deserializer);
        return PeerConnectionEvent_IceGatheringStateChange(var_field0);
      case 3:
        var var_address = sse_decode_String(deserializer);
        var var_port = sse_decode_i_32(deserializer);
        var var_url = sse_decode_String(deserializer);
        var var_errorCode = sse_decode_i_32(deserializer);
        var var_errorText = sse_decode_String(deserializer);
        return PeerConnectionEvent_IceCandidateError(
          address: var_address,
          port: var_port,
          url: var_url,
          errorCode: var_errorCode,
          errorText: var_errorText,
        );
      case 4:
        return PeerConnectionEvent_NegotiationNeeded();
      case 5:
        var var_field0 = sse_decode_signaling_state(deserializer);
        return PeerConnectionEvent_SignallingChange(var_field0);
      case 6:
        var var_field0 = sse_decode_ice_connection_state(deserializer);
        return PeerConnectionEvent_IceConnectionStateChange(var_field0);
      case 7:
        var var_field0 = sse_decode_peer_connection_state(deserializer);
        return PeerConnectionEvent_ConnectionStateChange(var_field0);
      case 8:
        var var_field0 = sse_decode_box_autoadd_rtc_track_event(deserializer);
        return PeerConnectionEvent_Track(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  PeerConnectionState sse_decode_peer_connection_state(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return PeerConnectionState.values[inner];
  }

  @protected
  Protocol sse_decode_protocol(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return Protocol.values[inner];
  }

  @protected
  (RtcRtpEncodingParameters, ArcRtpEncodingParameters)
  sse_decode_record_rtc_rtp_encoding_parameters_rust_opaque_arc_rtp_encoding_parameters(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_rtc_rtp_encoding_parameters(deserializer);
    var var_field1 = sse_decode_RustOpaque_ArcRtpEncodingParameters(
      deserializer,
    );
    return (var_field0, var_field1);
  }

  @protected
  (String, String) sse_decode_record_string_string(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_String(deserializer);
    var var_field1 = sse_decode_String(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  RtcConfiguration sse_decode_rtc_configuration(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_iceTransportPolicy = sse_decode_ice_transports_type(deserializer);
    var var_bundlePolicy = sse_decode_bundle_policy(deserializer);
    var var_iceServers = sse_decode_list_rtc_ice_server(deserializer);
    return RtcConfiguration(
      iceTransportPolicy: var_iceTransportPolicy,
      bundlePolicy: var_bundlePolicy,
      iceServers: var_iceServers,
    );
  }

  @protected
  RtcIceCandidateStats sse_decode_rtc_ice_candidate_stats(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_field0 = sse_decode_box_autoadd_ice_candidate_stats(
          deserializer,
        );
        return RtcIceCandidateStats_Local(var_field0);
      case 1:
        var var_field0 = sse_decode_box_autoadd_ice_candidate_stats(
          deserializer,
        );
        return RtcIceCandidateStats_Remote(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  RtcIceServer sse_decode_rtc_ice_server(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_urls = sse_decode_list_String(deserializer);
    var var_username = sse_decode_String(deserializer);
    var var_credential = sse_decode_String(deserializer);
    return RtcIceServer(
      urls: var_urls,
      username: var_username,
      credential: var_credential,
    );
  }

  @protected
  RtcInboundRtpStreamMediaType sse_decode_rtc_inbound_rtp_stream_media_type(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_voiceActivityFlag = sse_decode_opt_box_autoadd_bool(
          deserializer,
        );
        var var_totalSamplesReceived = sse_decode_opt_box_autoadd_u_64(
          deserializer,
        );
        var var_concealedSamples = sse_decode_opt_box_autoadd_u_64(
          deserializer,
        );
        var var_silentConcealedSamples = sse_decode_opt_box_autoadd_u_64(
          deserializer,
        );
        var var_audioLevel = sse_decode_opt_box_autoadd_f_64(deserializer);
        var var_totalAudioEnergy = sse_decode_opt_box_autoadd_f_64(
          deserializer,
        );
        var var_totalSamplesDuration = sse_decode_opt_box_autoadd_f_64(
          deserializer,
        );
        return RtcInboundRtpStreamMediaType_Audio(
          voiceActivityFlag: var_voiceActivityFlag,
          totalSamplesReceived: var_totalSamplesReceived,
          concealedSamples: var_concealedSamples,
          silentConcealedSamples: var_silentConcealedSamples,
          audioLevel: var_audioLevel,
          totalAudioEnergy: var_totalAudioEnergy,
          totalSamplesDuration: var_totalSamplesDuration,
        );
      case 1:
        var var_framesDecoded = sse_decode_opt_box_autoadd_u_32(deserializer);
        var var_keyFramesDecoded = sse_decode_opt_box_autoadd_u_32(
          deserializer,
        );
        var var_frameWidth = sse_decode_opt_box_autoadd_u_32(deserializer);
        var var_frameHeight = sse_decode_opt_box_autoadd_u_32(deserializer);
        var var_totalInterFrameDelay = sse_decode_opt_box_autoadd_f_64(
          deserializer,
        );
        var var_framesPerSecond = sse_decode_opt_box_autoadd_f_64(deserializer);
        var var_firCount = sse_decode_opt_box_autoadd_u_32(deserializer);
        var var_pliCount = sse_decode_opt_box_autoadd_u_32(deserializer);
        var var_sliCount = sse_decode_opt_box_autoadd_u_32(deserializer);
        var var_concealmentEvents = sse_decode_opt_box_autoadd_u_64(
          deserializer,
        );
        var var_framesReceived = sse_decode_opt_box_autoadd_i_32(deserializer);
        return RtcInboundRtpStreamMediaType_Video(
          framesDecoded: var_framesDecoded,
          keyFramesDecoded: var_keyFramesDecoded,
          frameWidth: var_frameWidth,
          frameHeight: var_frameHeight,
          totalInterFrameDelay: var_totalInterFrameDelay,
          framesPerSecond: var_framesPerSecond,
          firCount: var_firCount,
          pliCount: var_pliCount,
          sliCount: var_sliCount,
          concealmentEvents: var_concealmentEvents,
          framesReceived: var_framesReceived,
        );
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  RtcMediaSourceStatsMediaType sse_decode_rtc_media_source_stats_media_type(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_width = sse_decode_opt_box_autoadd_u_32(deserializer);
        var var_height = sse_decode_opt_box_autoadd_u_32(deserializer);
        var var_frames = sse_decode_opt_box_autoadd_u_32(deserializer);
        var var_framesPerSecond = sse_decode_opt_box_autoadd_f_64(deserializer);
        return RtcMediaSourceStatsMediaType_RtcVideoSourceStats(
          width: var_width,
          height: var_height,
          frames: var_frames,
          framesPerSecond: var_framesPerSecond,
        );
      case 1:
        var var_audioLevel = sse_decode_opt_box_autoadd_f_64(deserializer);
        var var_totalAudioEnergy = sse_decode_opt_box_autoadd_f_64(
          deserializer,
        );
        var var_totalSamplesDuration = sse_decode_opt_box_autoadd_f_64(
          deserializer,
        );
        var var_echoReturnLoss = sse_decode_opt_box_autoadd_f_64(deserializer);
        var var_echoReturnLossEnhancement = sse_decode_opt_box_autoadd_f_64(
          deserializer,
        );
        return RtcMediaSourceStatsMediaType_RtcAudioSourceStats(
          audioLevel: var_audioLevel,
          totalAudioEnergy: var_totalAudioEnergy,
          totalSamplesDuration: var_totalSamplesDuration,
          echoReturnLoss: var_echoReturnLoss,
          echoReturnLossEnhancement: var_echoReturnLossEnhancement,
        );
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  RtcOutboundRtpStreamStatsMediaType
  sse_decode_rtc_outbound_rtp_stream_stats_media_type(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_totalSamplesSent = sse_decode_opt_box_autoadd_u_64(
          deserializer,
        );
        var var_voiceActivityFlag = sse_decode_opt_box_autoadd_bool(
          deserializer,
        );
        return RtcOutboundRtpStreamStatsMediaType_Audio(
          totalSamplesSent: var_totalSamplesSent,
          voiceActivityFlag: var_voiceActivityFlag,
        );
      case 1:
        var var_frameWidth = sse_decode_opt_box_autoadd_u_32(deserializer);
        var var_frameHeight = sse_decode_opt_box_autoadd_u_32(deserializer);
        var var_framesPerSecond = sse_decode_opt_box_autoadd_f_64(deserializer);
        return RtcOutboundRtpStreamStatsMediaType_Video(
          frameWidth: var_frameWidth,
          frameHeight: var_frameHeight,
          framesPerSecond: var_framesPerSecond,
        );
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  RtcRtpEncodingParameters sse_decode_rtc_rtp_encoding_parameters(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_rid = sse_decode_String(deserializer);
    var var_active = sse_decode_bool(deserializer);
    var var_maxBitrate = sse_decode_opt_box_autoadd_i_32(deserializer);
    var var_maxFramerate = sse_decode_opt_box_autoadd_f_64(deserializer);
    var var_scaleResolutionDownBy = sse_decode_opt_box_autoadd_f_64(
      deserializer,
    );
    var var_scalabilityMode = sse_decode_opt_String(deserializer);
    return RtcRtpEncodingParameters(
      rid: var_rid,
      active: var_active,
      maxBitrate: var_maxBitrate,
      maxFramerate: var_maxFramerate,
      scaleResolutionDownBy: var_scaleResolutionDownBy,
      scalabilityMode: var_scalabilityMode,
    );
  }

  @protected
  RtcRtpSendParameters sse_decode_rtc_rtp_send_parameters(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_encodings =
        sse_decode_list_record_rtc_rtp_encoding_parameters_rust_opaque_arc_rtp_encoding_parameters(
          deserializer,
        );
    var var_inner = sse_decode_RustOpaque_ArcRtpParameters(deserializer);
    return RtcRtpSendParameters(encodings: var_encodings, inner: var_inner);
  }

  @protected
  RtcRtpTransceiver sse_decode_rtc_rtp_transceiver(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_peer = sse_decode_RustOpaque_ArcPeerConnection(deserializer);
    var var_transceiver = sse_decode_RustOpaque_ArcRtpTransceiver(deserializer);
    var var_mid = sse_decode_opt_String(deserializer);
    var var_direction = sse_decode_rtp_transceiver_direction(deserializer);
    return RtcRtpTransceiver(
      peer: var_peer,
      transceiver: var_transceiver,
      mid: var_mid,
      direction: var_direction,
    );
  }

  @protected
  RtcSessionDescription sse_decode_rtc_session_description(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_sdp = sse_decode_String(deserializer);
    var var_kind = sse_decode_sdp_type(deserializer);
    return RtcSessionDescription(sdp: var_sdp, kind: var_kind);
  }

  @protected
  RtcStats sse_decode_rtc_stats(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_timestampUs = sse_decode_i_64(deserializer);
    var var_kind = sse_decode_rtc_stats_type(deserializer);
    return RtcStats(id: var_id, timestampUs: var_timestampUs, kind: var_kind);
  }

  @protected
  RtcStatsIceCandidatePairState sse_decode_rtc_stats_ice_candidate_pair_state(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return RtcStatsIceCandidatePairState.values[inner];
  }

  @protected
  RtcStatsType sse_decode_rtc_stats_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_trackIdentifier = sse_decode_opt_String(deserializer);
        var var_kind = sse_decode_box_autoadd_rtc_media_source_stats_media_type(
          deserializer,
        );
        return RtcStatsType_RtcMediaSourceStats(
          trackIdentifier: var_trackIdentifier,
          kind: var_kind,
        );
      case 1:
        var var_field0 = sse_decode_box_autoadd_rtc_ice_candidate_stats(
          deserializer,
        );
        return RtcStatsType_RtcIceCandidateStats(var_field0);
      case 2:
        var var_trackId = sse_decode_opt_String(deserializer);
        var var_mediaType =
            sse_decode_box_autoadd_rtc_outbound_rtp_stream_stats_media_type(
              deserializer,
            );
        var var_bytesSent = sse_decode_opt_box_autoadd_u_64(deserializer);
        var var_packetsSent = sse_decode_opt_box_autoadd_u_32(deserializer);
        var var_mediaSourceId = sse_decode_opt_String(deserializer);
        return RtcStatsType_RtcOutboundRtpStreamStats(
          trackId: var_trackId,
          mediaType: var_mediaType,
          bytesSent: var_bytesSent,
          packetsSent: var_packetsSent,
          mediaSourceId: var_mediaSourceId,
        );
      case 3:
        var var_remoteId = sse_decode_opt_String(deserializer);
        var var_bytesReceived = sse_decode_opt_box_autoadd_u_64(deserializer);
        var var_packetsReceived = sse_decode_opt_box_autoadd_u_32(deserializer);
        var var_packetsLost = sse_decode_opt_box_autoadd_u_64(deserializer);
        var var_jitter = sse_decode_opt_box_autoadd_f_64(deserializer);
        var var_totalDecodeTime = sse_decode_opt_box_autoadd_f_64(deserializer);
        var var_jitterBufferEmittedCount = sse_decode_opt_box_autoadd_u_64(
          deserializer,
        );
        var var_mediaType =
            sse_decode_opt_box_autoadd_rtc_inbound_rtp_stream_media_type(
              deserializer,
            );
        return RtcStatsType_RtcInboundRtpStreamStats(
          remoteId: var_remoteId,
          bytesReceived: var_bytesReceived,
          packetsReceived: var_packetsReceived,
          packetsLost: var_packetsLost,
          jitter: var_jitter,
          totalDecodeTime: var_totalDecodeTime,
          jitterBufferEmittedCount: var_jitterBufferEmittedCount,
          mediaType: var_mediaType,
        );
      case 4:
        var var_state = sse_decode_rtc_stats_ice_candidate_pair_state(
          deserializer,
        );
        var var_nominated = sse_decode_opt_box_autoadd_bool(deserializer);
        var var_bytesSent = sse_decode_opt_box_autoadd_u_64(deserializer);
        var var_bytesReceived = sse_decode_opt_box_autoadd_u_64(deserializer);
        var var_totalRoundTripTime = sse_decode_opt_box_autoadd_f_64(
          deserializer,
        );
        var var_currentRoundTripTime = sse_decode_opt_box_autoadd_f_64(
          deserializer,
        );
        var var_availableOutgoingBitrate = sse_decode_opt_box_autoadd_f_64(
          deserializer,
        );
        return RtcStatsType_RtcIceCandidatePairStats(
          state: var_state,
          nominated: var_nominated,
          bytesSent: var_bytesSent,
          bytesReceived: var_bytesReceived,
          totalRoundTripTime: var_totalRoundTripTime,
          currentRoundTripTime: var_currentRoundTripTime,
          availableOutgoingBitrate: var_availableOutgoingBitrate,
        );
      case 5:
        var var_packetsSent = sse_decode_opt_box_autoadd_u_64(deserializer);
        var var_packetsReceived = sse_decode_opt_box_autoadd_u_64(deserializer);
        var var_bytesSent = sse_decode_opt_box_autoadd_u_64(deserializer);
        var var_bytesReceived = sse_decode_opt_box_autoadd_u_64(deserializer);
        var var_iceRole = sse_decode_opt_box_autoadd_ice_role(deserializer);
        return RtcStatsType_RtcTransportStats(
          packetsSent: var_packetsSent,
          packetsReceived: var_packetsReceived,
          bytesSent: var_bytesSent,
          bytesReceived: var_bytesReceived,
          iceRole: var_iceRole,
        );
      case 6:
        var var_localId = sse_decode_opt_String(deserializer);
        var var_jitter = sse_decode_opt_box_autoadd_f_64(deserializer);
        var var_roundTripTime = sse_decode_opt_box_autoadd_f_64(deserializer);
        var var_fractionLost = sse_decode_opt_box_autoadd_f_64(deserializer);
        var var_reportsReceived = sse_decode_opt_box_autoadd_u_64(deserializer);
        var var_roundTripTimeMeasurements = sse_decode_opt_box_autoadd_i_32(
          deserializer,
        );
        return RtcStatsType_RtcRemoteInboundRtpStreamStats(
          localId: var_localId,
          jitter: var_jitter,
          roundTripTime: var_roundTripTime,
          fractionLost: var_fractionLost,
          reportsReceived: var_reportsReceived,
          roundTripTimeMeasurements: var_roundTripTimeMeasurements,
        );
      case 7:
        var var_localId = sse_decode_opt_String(deserializer);
        var var_remoteTimestamp = sse_decode_opt_box_autoadd_f_64(deserializer);
        var var_reportsSent = sse_decode_opt_box_autoadd_u_64(deserializer);
        return RtcStatsType_RtcRemoteOutboundRtpStreamStats(
          localId: var_localId,
          remoteTimestamp: var_remoteTimestamp,
          reportsSent: var_reportsSent,
        );
      case 8:
        return RtcStatsType_Unimplemented();
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  RtcTrackEvent sse_decode_rtc_track_event(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_track = sse_decode_media_stream_track(deserializer);
    var var_transceiver = sse_decode_rtc_rtp_transceiver(deserializer);
    return RtcTrackEvent(track: var_track, transceiver: var_transceiver);
  }

  @protected
  RtcpFeedback sse_decode_rtcp_feedback(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_messageType = sse_decode_opt_box_autoadd_rtcp_feedback_message_type(
      deserializer,
    );
    var var_kind = sse_decode_rtcp_feedback_type(deserializer);
    return RtcpFeedback(messageType: var_messageType, kind: var_kind);
  }

  @protected
  RtcpFeedbackMessageType sse_decode_rtcp_feedback_message_type(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return RtcpFeedbackMessageType.values[inner];
  }

  @protected
  RtcpFeedbackType sse_decode_rtcp_feedback_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return RtcpFeedbackType.values[inner];
  }

  @protected
  RtpCapabilities sse_decode_rtp_capabilities(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_codecs = sse_decode_list_rtp_codec_capability(deserializer);
    var var_headerExtensions = sse_decode_list_rtp_header_extension_capability(
      deserializer,
    );
    return RtpCapabilities(
      codecs: var_codecs,
      headerExtensions: var_headerExtensions,
    );
  }

  @protected
  RtpCodecCapability sse_decode_rtp_codec_capability(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_preferredPayloadType = sse_decode_opt_box_autoadd_i_32(
      deserializer,
    );
    var var_scalabilityModes = sse_decode_list_scalability_mode(deserializer);
    var var_mimeType = sse_decode_String(deserializer);
    var var_name = sse_decode_String(deserializer);
    var var_kind = sse_decode_media_type(deserializer);
    var var_clockRate = sse_decode_opt_box_autoadd_i_32(deserializer);
    var var_numChannels = sse_decode_opt_box_autoadd_i_32(deserializer);
    var var_parameters = sse_decode_list_record_string_string(deserializer);
    var var_feedback = sse_decode_list_rtcp_feedback(deserializer);
    return RtpCodecCapability(
      preferredPayloadType: var_preferredPayloadType,
      scalabilityModes: var_scalabilityModes,
      mimeType: var_mimeType,
      name: var_name,
      kind: var_kind,
      clockRate: var_clockRate,
      numChannels: var_numChannels,
      parameters: var_parameters,
      feedback: var_feedback,
    );
  }

  @protected
  RtpHeaderExtensionCapability sse_decode_rtp_header_extension_capability(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_uri = sse_decode_String(deserializer);
    var var_preferredId = sse_decode_opt_box_autoadd_i_32(deserializer);
    var var_preferredEncrypted = sse_decode_bool(deserializer);
    var var_direction = sse_decode_rtp_transceiver_direction(deserializer);
    return RtpHeaderExtensionCapability(
      uri: var_uri,
      preferredId: var_preferredId,
      preferredEncrypted: var_preferredEncrypted,
      direction: var_direction,
    );
  }

  @protected
  RtpTransceiverDirection sse_decode_rtp_transceiver_direction(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return RtpTransceiverDirection.values[inner];
  }

  @protected
  RtpTransceiverInit sse_decode_rtp_transceiver_init(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_direction = sse_decode_rtp_transceiver_direction(deserializer);
    var var_sendEncodings = sse_decode_list_rtc_rtp_encoding_parameters(
      deserializer,
    );
    return RtpTransceiverInit(
      direction: var_direction,
      sendEncodings: var_sendEncodings,
    );
  }

  @protected
  ScalabilityMode sse_decode_scalability_mode(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return ScalabilityMode.values[inner];
  }

  @protected
  SdpType sse_decode_sdp_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return SdpType.values[inner];
  }

  @protected
  SignalingState sse_decode_signaling_state(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return SignalingState.values[inner];
  }

  @protected
  TextureEvent sse_decode_texture_event(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_textureId = sse_decode_i_64(deserializer);
        var var_width = sse_decode_i_32(deserializer);
        var var_height = sse_decode_i_32(deserializer);
        var var_rotation = sse_decode_i_32(deserializer);
        return TextureEvent_OnTextureChange(
          textureId: var_textureId,
          width: var_width,
          height: var_height,
          rotation: var_rotation,
        );
      case 1:
        var var_textureId = sse_decode_i_64(deserializer);
        return TextureEvent_OnFirstFrameRendered(textureId: var_textureId);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  TrackEvent sse_decode_track_event(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return TrackEvent_Ended();
      case 1:
        var var_field0 = sse_decode_u_32(deserializer);
        return TrackEvent_AudioLevelUpdated(var_field0);
      case 2:
        return TrackEvent_TrackCreated();
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  TrackState sse_decode_track_state(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return TrackState.values[inner];
  }

  @protected
  int sse_decode_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint32();
  }

  @protected
  BigInt sse_decode_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  BigInt sse_decode_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  VideoCodec sse_decode_video_codec(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return VideoCodec.values[inner];
  }

  @protected
  VideoCodecInfo sse_decode_video_codec_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_isHardwareAccelerated = sse_decode_bool(deserializer);
    var var_codec = sse_decode_video_codec(deserializer);
    return VideoCodecInfo(
      isHardwareAccelerated: var_isHardwareAccelerated,
      codec: var_codec,
    );
  }

  @protected
  VideoConstraints sse_decode_video_constraints(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_deviceId = sse_decode_opt_String(deserializer);
    var var_width = sse_decode_u_32(deserializer);
    var var_height = sse_decode_u_32(deserializer);
    var var_frameRate = sse_decode_u_32(deserializer);
    var var_isDisplay = sse_decode_bool(deserializer);
    return VideoConstraints(
      deviceId: var_deviceId,
      width: var_width,
      height: var_height,
      frameRate: var_frameRate,
      isDisplay: var_isDisplay,
    );
  }

  @protected
  void sse_encode_AnyhowException(
    AnyhowException self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.message, serializer);
  }

  @protected
  void sse_encode_RustOpaque_ArcPeerConnection(
    ArcPeerConnection self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as ArcPeerConnectionImpl).frbInternalSseEncode(move: null),
      serializer,
    );
  }

  @protected
  void sse_encode_RustOpaque_ArcRtpEncodingParameters(
    ArcRtpEncodingParameters self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as ArcRtpEncodingParametersImpl).frbInternalSseEncode(move: null),
      serializer,
    );
  }

  @protected
  void sse_encode_RustOpaque_ArcRtpParameters(
    ArcRtpParameters self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as ArcRtpParametersImpl).frbInternalSseEncode(move: null),
      serializer,
    );
  }

  @protected
  void sse_encode_RustOpaque_ArcRtpTransceiver(
    ArcRtpTransceiver self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as ArcRtpTransceiverImpl).frbInternalSseEncode(move: null),
      serializer,
    );
  }

  @protected
  void sse_encode_StreamSink_peer_connection_event_Sse(
    RustStreamSink<PeerConnectionEvent> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
      self.setupAndSerialize(
        codec: SseCodec(
          decodeSuccessData: sse_decode_peer_connection_event,
          decodeErrorData: sse_decode_AnyhowException,
        ),
      ),
      serializer,
    );
  }

  @protected
  void sse_encode_StreamSink_texture_event_Sse(
    RustStreamSink<TextureEvent> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
      self.setupAndSerialize(
        codec: SseCodec(
          decodeSuccessData: sse_decode_texture_event,
          decodeErrorData: sse_decode_AnyhowException,
        ),
      ),
      serializer,
    );
  }

  @protected
  void sse_encode_StreamSink_track_event_Sse(
    RustStreamSink<TrackEvent> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
      self.setupAndSerialize(
        codec: SseCodec(
          decodeSuccessData: sse_decode_track_event,
          decodeErrorData: sse_decode_AnyhowException,
        ),
      ),
      serializer,
    );
  }

  @protected
  void sse_encode_StreamSink_unit_Sse(
    RustStreamSink<void> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
      self.setupAndSerialize(
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
      ),
      serializer,
    );
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_audio_constraints(
    AudioConstraints self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_String(self.deviceId, serializer);
    sse_encode_audio_processing_constraints(self.processing, serializer);
  }

  @protected
  void sse_encode_audio_processing_config(
    AudioProcessingConfig self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.autoGainControl, serializer);
    sse_encode_bool(self.highPassFilter, serializer);
    sse_encode_bool(self.noiseSuppression, serializer);
    sse_encode_noise_suppression_level(self.noiseSuppressionLevel, serializer);
    sse_encode_bool(self.echoCancellation, serializer);
  }

  @protected
  void sse_encode_audio_processing_constraints(
    AudioProcessingConstraints self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_box_autoadd_bool(self.autoGainControl, serializer);
    sse_encode_opt_box_autoadd_bool(self.highPassFilter, serializer);
    sse_encode_opt_box_autoadd_bool(self.noiseSuppression, serializer);
    sse_encode_opt_box_autoadd_noise_suppression_level(
      self.noiseSuppressionLevel,
      serializer,
    );
    sse_encode_opt_box_autoadd_bool(self.echoCancellation, serializer);
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void sse_encode_box_autoadd_audio_constraints(
    AudioConstraints self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_audio_constraints(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_audio_processing_constraints(
    AudioProcessingConstraints self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_audio_processing_constraints(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_f_64(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_f_64(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_get_media_error(
    GetMediaError self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_get_media_error(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ice_candidate_stats(
    IceCandidateStats self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ice_candidate_stats(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ice_role(IceRole self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ice_role(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_media_stream_constraints(
    MediaStreamConstraints self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_media_stream_constraints(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_media_stream_track(
    MediaStreamTrack self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_media_stream_track(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_noise_suppression_level(
    NoiseSuppressionLevel self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_noise_suppression_level(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_protocol(
    Protocol self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_protocol(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_rtc_configuration(
    RtcConfiguration self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_rtc_configuration(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_rtc_ice_candidate_stats(
    RtcIceCandidateStats self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_rtc_ice_candidate_stats(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_rtc_inbound_rtp_stream_media_type(
    RtcInboundRtpStreamMediaType self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_rtc_inbound_rtp_stream_media_type(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_rtc_media_source_stats_media_type(
    RtcMediaSourceStatsMediaType self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_rtc_media_source_stats_media_type(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_rtc_outbound_rtp_stream_stats_media_type(
    RtcOutboundRtpStreamStatsMediaType self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_rtc_outbound_rtp_stream_stats_media_type(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_rtc_rtp_send_parameters(
    RtcRtpSendParameters self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_rtc_rtp_send_parameters(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_rtc_track_event(
    RtcTrackEvent self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_rtc_track_event(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_rtcp_feedback_message_type(
    RtcpFeedbackMessageType self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_rtcp_feedback_message_type(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_rtp_transceiver_init(
    RtpTransceiverInit self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_rtp_transceiver_init(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_video_constraints(
    VideoConstraints self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_video_constraints(self, serializer);
  }

  @protected
  void sse_encode_bundle_policy(BundlePolicy self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_candidate_type(CandidateType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_f_64(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putFloat64(self);
  }

  @protected
  void sse_encode_get_media_error(
    GetMediaError self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case GetMediaError_Audio(field0: final field0):
        sse_encode_i_32(0, serializer);
        sse_encode_String(field0, serializer);
      case GetMediaError_Video(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_String(field0, serializer);
    }
  }

  @protected
  void sse_encode_get_media_result(
    GetMediaResult self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case GetMediaResult_Ok(field0: final field0):
        sse_encode_i_32(0, serializer);
        sse_encode_list_media_stream_track(field0, serializer);
      case GetMediaResult_Err(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_get_media_error(field0, serializer);
    }
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_i_64(PlatformInt64 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putPlatformInt64(self);
  }

  @protected
  void sse_encode_ice_candidate_stats(
    IceCandidateStats self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_String(self.transportId, serializer);
    sse_encode_opt_String(self.address, serializer);
    sse_encode_opt_box_autoadd_i_32(self.port, serializer);
    sse_encode_protocol(self.protocol, serializer);
    sse_encode_candidate_type(self.candidateType, serializer);
    sse_encode_opt_box_autoadd_i_32(self.priority, serializer);
    sse_encode_opt_String(self.url, serializer);
    sse_encode_opt_box_autoadd_protocol(self.relayProtocol, serializer);
  }

  @protected
  void sse_encode_ice_connection_state(
    IceConnectionState self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_ice_gathering_state(
    IceGatheringState self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_ice_role(IceRole self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_ice_transports_type(
    IceTransportsType self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_list_String(List<String> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_String(item, serializer);
    }
  }

  @protected
  void sse_encode_list_media_device_info(
    List<MediaDeviceInfo> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_media_device_info(item, serializer);
    }
  }

  @protected
  void sse_encode_list_media_display_info(
    List<MediaDisplayInfo> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_media_display_info(item, serializer);
    }
  }

  @protected
  void sse_encode_list_media_stream_track(
    List<MediaStreamTrack> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_media_stream_track(item, serializer);
    }
  }

  @protected
  void sse_encode_list_prim_u_8_strict(
    Uint8List self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void
  sse_encode_list_record_rtc_rtp_encoding_parameters_rust_opaque_arc_rtp_encoding_parameters(
    List<(RtcRtpEncodingParameters, ArcRtpEncodingParameters)> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_record_rtc_rtp_encoding_parameters_rust_opaque_arc_rtp_encoding_parameters(
        item,
        serializer,
      );
    }
  }

  @protected
  void sse_encode_list_record_string_string(
    List<(String, String)> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_record_string_string(item, serializer);
    }
  }

  @protected
  void sse_encode_list_rtc_ice_server(
    List<RtcIceServer> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_rtc_ice_server(item, serializer);
    }
  }

  @protected
  void sse_encode_list_rtc_rtp_encoding_parameters(
    List<RtcRtpEncodingParameters> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_rtc_rtp_encoding_parameters(item, serializer);
    }
  }

  @protected
  void sse_encode_list_rtc_rtp_transceiver(
    List<RtcRtpTransceiver> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_rtc_rtp_transceiver(item, serializer);
    }
  }

  @protected
  void sse_encode_list_rtc_stats(
    List<RtcStats> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_rtc_stats(item, serializer);
    }
  }

  @protected
  void sse_encode_list_rtcp_feedback(
    List<RtcpFeedback> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_rtcp_feedback(item, serializer);
    }
  }

  @protected
  void sse_encode_list_rtp_codec_capability(
    List<RtpCodecCapability> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_rtp_codec_capability(item, serializer);
    }
  }

  @protected
  void sse_encode_list_rtp_header_extension_capability(
    List<RtpHeaderExtensionCapability> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_rtp_header_extension_capability(item, serializer);
    }
  }

  @protected
  void sse_encode_list_scalability_mode(
    List<ScalabilityMode> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_scalability_mode(item, serializer);
    }
  }

  @protected
  void sse_encode_list_video_codec_info(
    List<VideoCodecInfo> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_video_codec_info(item, serializer);
    }
  }

  @protected
  void sse_encode_media_device_info(
    MediaDeviceInfo self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.deviceId, serializer);
    sse_encode_media_device_kind(self.kind, serializer);
    sse_encode_String(self.label, serializer);
  }

  @protected
  void sse_encode_media_device_kind(
    MediaDeviceKind self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_media_display_info(
    MediaDisplayInfo self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.deviceId, serializer);
    sse_encode_opt_String(self.title, serializer);
  }

  @protected
  void sse_encode_media_stream_constraints(
    MediaStreamConstraints self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_box_autoadd_audio_constraints(self.audio, serializer);
    sse_encode_opt_box_autoadd_video_constraints(self.video, serializer);
  }

  @protected
  void sse_encode_media_stream_track(
    MediaStreamTrack self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_opt_box_autoadd_u_32(self.peerId, serializer);
    sse_encode_String(self.deviceId, serializer);
    sse_encode_media_type(self.kind, serializer);
    sse_encode_bool(self.enabled, serializer);
  }

  @protected
  void sse_encode_media_type(MediaType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_noise_suppression_level(
    NoiseSuppressionLevel self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_audio_constraints(
    AudioConstraints? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_audio_constraints(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_bool(bool? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_bool(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_f_64(double? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_f_64(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_i_32(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_i_32(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_ice_role(
    IceRole? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_ice_role(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_media_stream_track(
    MediaStreamTrack? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_media_stream_track(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_noise_suppression_level(
    NoiseSuppressionLevel? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_noise_suppression_level(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_protocol(
    Protocol? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_protocol(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_rtc_inbound_rtp_stream_media_type(
    RtcInboundRtpStreamMediaType? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_rtc_inbound_rtp_stream_media_type(
        self,
        serializer,
      );
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_rtcp_feedback_message_type(
    RtcpFeedbackMessageType? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_rtcp_feedback_message_type(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_32(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_32(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_64(BigInt? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_64(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_video_constraints(
    VideoConstraints? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_video_constraints(self, serializer);
    }
  }

  @protected
  void sse_encode_peer_connection_event(
    PeerConnectionEvent self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case PeerConnectionEvent_PeerCreated(peer: final peer):
        sse_encode_i_32(0, serializer);
        sse_encode_RustOpaque_ArcPeerConnection(peer, serializer);
      case PeerConnectionEvent_IceCandidate(
        sdpMid: final sdpMid,
        sdpMlineIndex: final sdpMlineIndex,
        candidate: final candidate,
      ):
        sse_encode_i_32(1, serializer);
        sse_encode_String(sdpMid, serializer);
        sse_encode_i_32(sdpMlineIndex, serializer);
        sse_encode_String(candidate, serializer);
      case PeerConnectionEvent_IceGatheringStateChange(field0: final field0):
        sse_encode_i_32(2, serializer);
        sse_encode_ice_gathering_state(field0, serializer);
      case PeerConnectionEvent_IceCandidateError(
        address: final address,
        port: final port,
        url: final url,
        errorCode: final errorCode,
        errorText: final errorText,
      ):
        sse_encode_i_32(3, serializer);
        sse_encode_String(address, serializer);
        sse_encode_i_32(port, serializer);
        sse_encode_String(url, serializer);
        sse_encode_i_32(errorCode, serializer);
        sse_encode_String(errorText, serializer);
      case PeerConnectionEvent_NegotiationNeeded():
        sse_encode_i_32(4, serializer);
      case PeerConnectionEvent_SignallingChange(field0: final field0):
        sse_encode_i_32(5, serializer);
        sse_encode_signaling_state(field0, serializer);
      case PeerConnectionEvent_IceConnectionStateChange(field0: final field0):
        sse_encode_i_32(6, serializer);
        sse_encode_ice_connection_state(field0, serializer);
      case PeerConnectionEvent_ConnectionStateChange(field0: final field0):
        sse_encode_i_32(7, serializer);
        sse_encode_peer_connection_state(field0, serializer);
      case PeerConnectionEvent_Track(field0: final field0):
        sse_encode_i_32(8, serializer);
        sse_encode_box_autoadd_rtc_track_event(field0, serializer);
    }
  }

  @protected
  void sse_encode_peer_connection_state(
    PeerConnectionState self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_protocol(Protocol self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void
  sse_encode_record_rtc_rtp_encoding_parameters_rust_opaque_arc_rtp_encoding_parameters(
    (RtcRtpEncodingParameters, ArcRtpEncodingParameters) self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_rtc_rtp_encoding_parameters(self.$1, serializer);
    sse_encode_RustOpaque_ArcRtpEncodingParameters(self.$2, serializer);
  }

  @protected
  void sse_encode_record_string_string(
    (String, String) self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.$1, serializer);
    sse_encode_String(self.$2, serializer);
  }

  @protected
  void sse_encode_rtc_configuration(
    RtcConfiguration self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ice_transports_type(self.iceTransportPolicy, serializer);
    sse_encode_bundle_policy(self.bundlePolicy, serializer);
    sse_encode_list_rtc_ice_server(self.iceServers, serializer);
  }

  @protected
  void sse_encode_rtc_ice_candidate_stats(
    RtcIceCandidateStats self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case RtcIceCandidateStats_Local(field0: final field0):
        sse_encode_i_32(0, serializer);
        sse_encode_box_autoadd_ice_candidate_stats(field0, serializer);
      case RtcIceCandidateStats_Remote(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_ice_candidate_stats(field0, serializer);
    }
  }

  @protected
  void sse_encode_rtc_ice_server(RtcIceServer self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_String(self.urls, serializer);
    sse_encode_String(self.username, serializer);
    sse_encode_String(self.credential, serializer);
  }

  @protected
  void sse_encode_rtc_inbound_rtp_stream_media_type(
    RtcInboundRtpStreamMediaType self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case RtcInboundRtpStreamMediaType_Audio(
        voiceActivityFlag: final voiceActivityFlag,
        totalSamplesReceived: final totalSamplesReceived,
        concealedSamples: final concealedSamples,
        silentConcealedSamples: final silentConcealedSamples,
        audioLevel: final audioLevel,
        totalAudioEnergy: final totalAudioEnergy,
        totalSamplesDuration: final totalSamplesDuration,
      ):
        sse_encode_i_32(0, serializer);
        sse_encode_opt_box_autoadd_bool(voiceActivityFlag, serializer);
        sse_encode_opt_box_autoadd_u_64(totalSamplesReceived, serializer);
        sse_encode_opt_box_autoadd_u_64(concealedSamples, serializer);
        sse_encode_opt_box_autoadd_u_64(silentConcealedSamples, serializer);
        sse_encode_opt_box_autoadd_f_64(audioLevel, serializer);
        sse_encode_opt_box_autoadd_f_64(totalAudioEnergy, serializer);
        sse_encode_opt_box_autoadd_f_64(totalSamplesDuration, serializer);
      case RtcInboundRtpStreamMediaType_Video(
        framesDecoded: final framesDecoded,
        keyFramesDecoded: final keyFramesDecoded,
        frameWidth: final frameWidth,
        frameHeight: final frameHeight,
        totalInterFrameDelay: final totalInterFrameDelay,
        framesPerSecond: final framesPerSecond,
        firCount: final firCount,
        pliCount: final pliCount,
        sliCount: final sliCount,
        concealmentEvents: final concealmentEvents,
        framesReceived: final framesReceived,
      ):
        sse_encode_i_32(1, serializer);
        sse_encode_opt_box_autoadd_u_32(framesDecoded, serializer);
        sse_encode_opt_box_autoadd_u_32(keyFramesDecoded, serializer);
        sse_encode_opt_box_autoadd_u_32(frameWidth, serializer);
        sse_encode_opt_box_autoadd_u_32(frameHeight, serializer);
        sse_encode_opt_box_autoadd_f_64(totalInterFrameDelay, serializer);
        sse_encode_opt_box_autoadd_f_64(framesPerSecond, serializer);
        sse_encode_opt_box_autoadd_u_32(firCount, serializer);
        sse_encode_opt_box_autoadd_u_32(pliCount, serializer);
        sse_encode_opt_box_autoadd_u_32(sliCount, serializer);
        sse_encode_opt_box_autoadd_u_64(concealmentEvents, serializer);
        sse_encode_opt_box_autoadd_i_32(framesReceived, serializer);
    }
  }

  @protected
  void sse_encode_rtc_media_source_stats_media_type(
    RtcMediaSourceStatsMediaType self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case RtcMediaSourceStatsMediaType_RtcVideoSourceStats(
        width: final width,
        height: final height,
        frames: final frames,
        framesPerSecond: final framesPerSecond,
      ):
        sse_encode_i_32(0, serializer);
        sse_encode_opt_box_autoadd_u_32(width, serializer);
        sse_encode_opt_box_autoadd_u_32(height, serializer);
        sse_encode_opt_box_autoadd_u_32(frames, serializer);
        sse_encode_opt_box_autoadd_f_64(framesPerSecond, serializer);
      case RtcMediaSourceStatsMediaType_RtcAudioSourceStats(
        audioLevel: final audioLevel,
        totalAudioEnergy: final totalAudioEnergy,
        totalSamplesDuration: final totalSamplesDuration,
        echoReturnLoss: final echoReturnLoss,
        echoReturnLossEnhancement: final echoReturnLossEnhancement,
      ):
        sse_encode_i_32(1, serializer);
        sse_encode_opt_box_autoadd_f_64(audioLevel, serializer);
        sse_encode_opt_box_autoadd_f_64(totalAudioEnergy, serializer);
        sse_encode_opt_box_autoadd_f_64(totalSamplesDuration, serializer);
        sse_encode_opt_box_autoadd_f_64(echoReturnLoss, serializer);
        sse_encode_opt_box_autoadd_f_64(echoReturnLossEnhancement, serializer);
    }
  }

  @protected
  void sse_encode_rtc_outbound_rtp_stream_stats_media_type(
    RtcOutboundRtpStreamStatsMediaType self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case RtcOutboundRtpStreamStatsMediaType_Audio(
        totalSamplesSent: final totalSamplesSent,
        voiceActivityFlag: final voiceActivityFlag,
      ):
        sse_encode_i_32(0, serializer);
        sse_encode_opt_box_autoadd_u_64(totalSamplesSent, serializer);
        sse_encode_opt_box_autoadd_bool(voiceActivityFlag, serializer);
      case RtcOutboundRtpStreamStatsMediaType_Video(
        frameWidth: final frameWidth,
        frameHeight: final frameHeight,
        framesPerSecond: final framesPerSecond,
      ):
        sse_encode_i_32(1, serializer);
        sse_encode_opt_box_autoadd_u_32(frameWidth, serializer);
        sse_encode_opt_box_autoadd_u_32(frameHeight, serializer);
        sse_encode_opt_box_autoadd_f_64(framesPerSecond, serializer);
    }
  }

  @protected
  void sse_encode_rtc_rtp_encoding_parameters(
    RtcRtpEncodingParameters self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.rid, serializer);
    sse_encode_bool(self.active, serializer);
    sse_encode_opt_box_autoadd_i_32(self.maxBitrate, serializer);
    sse_encode_opt_box_autoadd_f_64(self.maxFramerate, serializer);
    sse_encode_opt_box_autoadd_f_64(self.scaleResolutionDownBy, serializer);
    sse_encode_opt_String(self.scalabilityMode, serializer);
  }

  @protected
  void sse_encode_rtc_rtp_send_parameters(
    RtcRtpSendParameters self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_record_rtc_rtp_encoding_parameters_rust_opaque_arc_rtp_encoding_parameters(
      self.encodings,
      serializer,
    );
    sse_encode_RustOpaque_ArcRtpParameters(self.inner, serializer);
  }

  @protected
  void sse_encode_rtc_rtp_transceiver(
    RtcRtpTransceiver self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_RustOpaque_ArcPeerConnection(self.peer, serializer);
    sse_encode_RustOpaque_ArcRtpTransceiver(self.transceiver, serializer);
    sse_encode_opt_String(self.mid, serializer);
    sse_encode_rtp_transceiver_direction(self.direction, serializer);
  }

  @protected
  void sse_encode_rtc_session_description(
    RtcSessionDescription self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.sdp, serializer);
    sse_encode_sdp_type(self.kind, serializer);
  }

  @protected
  void sse_encode_rtc_stats(RtcStats self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_i_64(self.timestampUs, serializer);
    sse_encode_rtc_stats_type(self.kind, serializer);
  }

  @protected
  void sse_encode_rtc_stats_ice_candidate_pair_state(
    RtcStatsIceCandidatePairState self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_rtc_stats_type(RtcStatsType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case RtcStatsType_RtcMediaSourceStats(
        trackIdentifier: final trackIdentifier,
        kind: final kind,
      ):
        sse_encode_i_32(0, serializer);
        sse_encode_opt_String(trackIdentifier, serializer);
        sse_encode_box_autoadd_rtc_media_source_stats_media_type(
          kind,
          serializer,
        );
      case RtcStatsType_RtcIceCandidateStats(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_rtc_ice_candidate_stats(field0, serializer);
      case RtcStatsType_RtcOutboundRtpStreamStats(
        trackId: final trackId,
        mediaType: final mediaType,
        bytesSent: final bytesSent,
        packetsSent: final packetsSent,
        mediaSourceId: final mediaSourceId,
      ):
        sse_encode_i_32(2, serializer);
        sse_encode_opt_String(trackId, serializer);
        sse_encode_box_autoadd_rtc_outbound_rtp_stream_stats_media_type(
          mediaType,
          serializer,
        );
        sse_encode_opt_box_autoadd_u_64(bytesSent, serializer);
        sse_encode_opt_box_autoadd_u_32(packetsSent, serializer);
        sse_encode_opt_String(mediaSourceId, serializer);
      case RtcStatsType_RtcInboundRtpStreamStats(
        remoteId: final remoteId,
        bytesReceived: final bytesReceived,
        packetsReceived: final packetsReceived,
        packetsLost: final packetsLost,
        jitter: final jitter,
        totalDecodeTime: final totalDecodeTime,
        jitterBufferEmittedCount: final jitterBufferEmittedCount,
        mediaType: final mediaType,
      ):
        sse_encode_i_32(3, serializer);
        sse_encode_opt_String(remoteId, serializer);
        sse_encode_opt_box_autoadd_u_64(bytesReceived, serializer);
        sse_encode_opt_box_autoadd_u_32(packetsReceived, serializer);
        sse_encode_opt_box_autoadd_u_64(packetsLost, serializer);
        sse_encode_opt_box_autoadd_f_64(jitter, serializer);
        sse_encode_opt_box_autoadd_f_64(totalDecodeTime, serializer);
        sse_encode_opt_box_autoadd_u_64(jitterBufferEmittedCount, serializer);
        sse_encode_opt_box_autoadd_rtc_inbound_rtp_stream_media_type(
          mediaType,
          serializer,
        );
      case RtcStatsType_RtcIceCandidatePairStats(
        state: final state,
        nominated: final nominated,
        bytesSent: final bytesSent,
        bytesReceived: final bytesReceived,
        totalRoundTripTime: final totalRoundTripTime,
        currentRoundTripTime: final currentRoundTripTime,
        availableOutgoingBitrate: final availableOutgoingBitrate,
      ):
        sse_encode_i_32(4, serializer);
        sse_encode_rtc_stats_ice_candidate_pair_state(state, serializer);
        sse_encode_opt_box_autoadd_bool(nominated, serializer);
        sse_encode_opt_box_autoadd_u_64(bytesSent, serializer);
        sse_encode_opt_box_autoadd_u_64(bytesReceived, serializer);
        sse_encode_opt_box_autoadd_f_64(totalRoundTripTime, serializer);
        sse_encode_opt_box_autoadd_f_64(currentRoundTripTime, serializer);
        sse_encode_opt_box_autoadd_f_64(availableOutgoingBitrate, serializer);
      case RtcStatsType_RtcTransportStats(
        packetsSent: final packetsSent,
        packetsReceived: final packetsReceived,
        bytesSent: final bytesSent,
        bytesReceived: final bytesReceived,
        iceRole: final iceRole,
      ):
        sse_encode_i_32(5, serializer);
        sse_encode_opt_box_autoadd_u_64(packetsSent, serializer);
        sse_encode_opt_box_autoadd_u_64(packetsReceived, serializer);
        sse_encode_opt_box_autoadd_u_64(bytesSent, serializer);
        sse_encode_opt_box_autoadd_u_64(bytesReceived, serializer);
        sse_encode_opt_box_autoadd_ice_role(iceRole, serializer);
      case RtcStatsType_RtcRemoteInboundRtpStreamStats(
        localId: final localId,
        jitter: final jitter,
        roundTripTime: final roundTripTime,
        fractionLost: final fractionLost,
        reportsReceived: final reportsReceived,
        roundTripTimeMeasurements: final roundTripTimeMeasurements,
      ):
        sse_encode_i_32(6, serializer);
        sse_encode_opt_String(localId, serializer);
        sse_encode_opt_box_autoadd_f_64(jitter, serializer);
        sse_encode_opt_box_autoadd_f_64(roundTripTime, serializer);
        sse_encode_opt_box_autoadd_f_64(fractionLost, serializer);
        sse_encode_opt_box_autoadd_u_64(reportsReceived, serializer);
        sse_encode_opt_box_autoadd_i_32(roundTripTimeMeasurements, serializer);
      case RtcStatsType_RtcRemoteOutboundRtpStreamStats(
        localId: final localId,
        remoteTimestamp: final remoteTimestamp,
        reportsSent: final reportsSent,
      ):
        sse_encode_i_32(7, serializer);
        sse_encode_opt_String(localId, serializer);
        sse_encode_opt_box_autoadd_f_64(remoteTimestamp, serializer);
        sse_encode_opt_box_autoadd_u_64(reportsSent, serializer);
      case RtcStatsType_Unimplemented():
        sse_encode_i_32(8, serializer);
    }
  }

  @protected
  void sse_encode_rtc_track_event(
    RtcTrackEvent self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_media_stream_track(self.track, serializer);
    sse_encode_rtc_rtp_transceiver(self.transceiver, serializer);
  }

  @protected
  void sse_encode_rtcp_feedback(RtcpFeedback self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_box_autoadd_rtcp_feedback_message_type(
      self.messageType,
      serializer,
    );
    sse_encode_rtcp_feedback_type(self.kind, serializer);
  }

  @protected
  void sse_encode_rtcp_feedback_message_type(
    RtcpFeedbackMessageType self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_rtcp_feedback_type(
    RtcpFeedbackType self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_rtp_capabilities(
    RtpCapabilities self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_rtp_codec_capability(self.codecs, serializer);
    sse_encode_list_rtp_header_extension_capability(
      self.headerExtensions,
      serializer,
    );
  }

  @protected
  void sse_encode_rtp_codec_capability(
    RtpCodecCapability self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_box_autoadd_i_32(self.preferredPayloadType, serializer);
    sse_encode_list_scalability_mode(self.scalabilityModes, serializer);
    sse_encode_String(self.mimeType, serializer);
    sse_encode_String(self.name, serializer);
    sse_encode_media_type(self.kind, serializer);
    sse_encode_opt_box_autoadd_i_32(self.clockRate, serializer);
    sse_encode_opt_box_autoadd_i_32(self.numChannels, serializer);
    sse_encode_list_record_string_string(self.parameters, serializer);
    sse_encode_list_rtcp_feedback(self.feedback, serializer);
  }

  @protected
  void sse_encode_rtp_header_extension_capability(
    RtpHeaderExtensionCapability self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.uri, serializer);
    sse_encode_opt_box_autoadd_i_32(self.preferredId, serializer);
    sse_encode_bool(self.preferredEncrypted, serializer);
    sse_encode_rtp_transceiver_direction(self.direction, serializer);
  }

  @protected
  void sse_encode_rtp_transceiver_direction(
    RtpTransceiverDirection self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_rtp_transceiver_init(
    RtpTransceiverInit self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_rtp_transceiver_direction(self.direction, serializer);
    sse_encode_list_rtc_rtp_encoding_parameters(self.sendEncodings, serializer);
  }

  @protected
  void sse_encode_scalability_mode(
    ScalabilityMode self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_sdp_type(SdpType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_signaling_state(
    SignalingState self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_texture_event(TextureEvent self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case TextureEvent_OnTextureChange(
        textureId: final textureId,
        width: final width,
        height: final height,
        rotation: final rotation,
      ):
        sse_encode_i_32(0, serializer);
        sse_encode_i_64(textureId, serializer);
        sse_encode_i_32(width, serializer);
        sse_encode_i_32(height, serializer);
        sse_encode_i_32(rotation, serializer);
      case TextureEvent_OnFirstFrameRendered(textureId: final textureId):
        sse_encode_i_32(1, serializer);
        sse_encode_i_64(textureId, serializer);
    }
  }

  @protected
  void sse_encode_track_event(TrackEvent self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case TrackEvent_Ended():
        sse_encode_i_32(0, serializer);
      case TrackEvent_AudioLevelUpdated(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_u_32(field0, serializer);
      case TrackEvent_TrackCreated():
        sse_encode_i_32(2, serializer);
    }
  }

  @protected
  void sse_encode_track_state(TrackState self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint32(self);
  }

  @protected
  void sse_encode_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_usize(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_video_codec(VideoCodec self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_video_codec_info(
    VideoCodecInfo self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.isHardwareAccelerated, serializer);
    sse_encode_video_codec(self.codec, serializer);
  }

  @protected
  void sse_encode_video_constraints(
    VideoConstraints self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_String(self.deviceId, serializer);
    sse_encode_u_32(self.width, serializer);
    sse_encode_u_32(self.height, serializer);
    sse_encode_u_32(self.frameRate, serializer);
    sse_encode_bool(self.isDisplay, serializer);
  }
}

@sealed
class ArcPeerConnectionImpl extends RustOpaque implements ArcPeerConnection {
  // Not to be used by end users
  ArcPeerConnectionImpl.frbInternalDcoDecode(List<dynamic> wire)
    : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  ArcPeerConnectionImpl.frbInternalSseDecode(
    BigInt ptr,
    int externalSizeOnNative,
  ) : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_ArcPeerConnection,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_ArcPeerConnection,
    rustArcDecrementStrongCountPtr:
        RustLib
            .instance
            .api
            .rust_arc_decrement_strong_count_ArcPeerConnectionPtr,
  );
}

@sealed
class ArcRtpEncodingParametersImpl extends RustOpaque
    implements ArcRtpEncodingParameters {
  // Not to be used by end users
  ArcRtpEncodingParametersImpl.frbInternalDcoDecode(List<dynamic> wire)
    : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  ArcRtpEncodingParametersImpl.frbInternalSseDecode(
    BigInt ptr,
    int externalSizeOnNative,
  ) : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib
            .instance
            .api
            .rust_arc_increment_strong_count_ArcRtpEncodingParameters,
    rustArcDecrementStrongCount:
        RustLib
            .instance
            .api
            .rust_arc_decrement_strong_count_ArcRtpEncodingParameters,
    rustArcDecrementStrongCountPtr:
        RustLib
            .instance
            .api
            .rust_arc_decrement_strong_count_ArcRtpEncodingParametersPtr,
  );
}

@sealed
class ArcRtpParametersImpl extends RustOpaque implements ArcRtpParameters {
  // Not to be used by end users
  ArcRtpParametersImpl.frbInternalDcoDecode(List<dynamic> wire)
    : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  ArcRtpParametersImpl.frbInternalSseDecode(
    BigInt ptr,
    int externalSizeOnNative,
  ) : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_ArcRtpParameters,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_ArcRtpParameters,
    rustArcDecrementStrongCountPtr:
        RustLib
            .instance
            .api
            .rust_arc_decrement_strong_count_ArcRtpParametersPtr,
  );
}

@sealed
class ArcRtpTransceiverImpl extends RustOpaque implements ArcRtpTransceiver {
  // Not to be used by end users
  ArcRtpTransceiverImpl.frbInternalDcoDecode(List<dynamic> wire)
    : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  ArcRtpTransceiverImpl.frbInternalSseDecode(
    BigInt ptr,
    int externalSizeOnNative,
  ) : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_ArcRtpTransceiver,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_ArcRtpTransceiver,
    rustArcDecrementStrongCountPtr:
        RustLib
            .instance
            .api
            .rust_arc_decrement_strong_count_ArcRtpTransceiverPtr,
  );
}
