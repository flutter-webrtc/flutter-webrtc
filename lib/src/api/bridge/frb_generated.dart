// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.4.0.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'dart:async';
import 'dart:convert';

import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

import 'api.dart';
import 'frb_generated.dart';
import 'lib.dart';
import 'renderer.dart';

import 'frb_generated.io.dart'
    if (dart.library.js_interop) 'frb_generated.web.dart';

/// Main entrypoint of the Rust API
class RustLib extends BaseEntrypoint<RustLibApi, RustLibApiImpl, RustLibWire> {
  @internal
  static final instance = RustLib._();

  RustLib._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    RustLibApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
    );
  }

  /// Initialize flutter_rust_bridge in mock mode.
  /// No libraries for FFI are loaded.
  static void initMock({
    required RustLibApi api,
  }) {
    instance.initMockImpl(
      api: api,
    );
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<RustLibApiImpl, RustLibWire> get apiImplConstructor =>
      RustLibApiImpl.new;

  @override
  WireConstructor<RustLibWire> get wireConstructor =>
      RustLibWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {}

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig =>
      kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.4.0';

  @override
  int get rustContentHash => -1353945569;

  static const kDefaultExternalLibraryLoaderConfig =
      ExternalLibraryLoaderConfig(
    stem: 'medea_flutter_webrtc_native',
    ioDirectory: 'crates/native/target/release/',
    webPrefix: 'pkg/',
  );
}

abstract class RustLibApi extends BaseApi {
  Future<void> crateApiAddIceCandidate(
      {required ArcPeerConnection peer,
      required String candidate,
      required String sdpMid,
      required int sdpMlineIndex});

  Future<RtcRtpTransceiver> crateApiAddTransceiver(
      {required ArcPeerConnection peer,
      required MediaType mediaType,
      required RtpTransceiverInit init});

  Future<MediaStreamTrack> crateApiCloneTrack(
      {required String trackId, int? peerId, required MediaType kind});

  Future<RtcSessionDescription> crateApiCreateAnswer(
      {required ArcPeerConnection peer,
      required bool voiceActivityDetection,
      required bool iceRestart,
      required bool useRtpMux});

  Future<RtcSessionDescription> crateApiCreateOffer(
      {required ArcPeerConnection peer,
      required bool voiceActivityDetection,
      required bool iceRestart,
      required bool useRtpMux});

  Stream<PeerConnectionEvent> crateApiCreatePeerConnection(
      {required RtcConfiguration configuration});

  Stream<TextureEvent> crateApiCreateVideoSink(
      {required PlatformInt64 sinkId,
      int? peerId,
      required String trackId,
      required PlatformInt64 callbackPtr,
      required PlatformInt64 textureId});

  Future<void> crateApiDisposePeerConnection({required ArcPeerConnection peer});

  Future<void> crateApiDisposeTrack(
      {required String trackId, int? peerId, required MediaType kind});

  Future<void> crateApiDisposeVideoSink({required PlatformInt64 sinkId});

  Future<void> crateApiEnableFakeMedia();

  Future<List<MediaDeviceInfo>> crateApiEnumerateDevices();

  Future<List<MediaDisplayInfo>> crateApiEnumerateDisplays();

  Future<GetMediaResult> crateApiGetMedia(
      {required MediaStreamConstraints constraints});

  Future<List<RtcStats>> crateApiGetPeerStats(
      {required ArcPeerConnection peer});

  Future<RtpCapabilities> crateApiGetRtpReceiverCapabilities(
      {required MediaType kind});

  Future<RtpCapabilities> crateApiGetRtpSenderCapabilities(
      {required MediaType kind});

  Future<RtpTransceiverDirection> crateApiGetTransceiverDirection(
      {required ArcRtpTransceiver transceiver});

  Future<String?> crateApiGetTransceiverMid(
      {required ArcRtpTransceiver transceiver});

  Future<List<RtcRtpTransceiver>> crateApiGetTransceivers(
      {required ArcPeerConnection peer});

  Future<bool> crateApiIsFakeMedia();

  Future<int> crateApiMicrophoneVolume();

  Future<bool> crateApiMicrophoneVolumeIsAvailable();

  Stream<TrackEvent> crateApiRegisterTrackObserver(
      {int? peerId, required String trackId, required MediaType kind});

  Future<void> crateApiRestartIce({required ArcPeerConnection peer});

  Future<RtcRtpSendParameters> crateApiSenderGetParameters(
      {required ArcRtpTransceiver transceiver});

  Future<void> crateApiSenderReplaceTrack(
      {required ArcPeerConnection peer,
      required ArcRtpTransceiver transceiver,
      String? trackId});

  Future<void> crateApiSenderSetParameters(
      {required ArcRtpTransceiver transceiver,
      required RtcRtpSendParameters params});

  Future<void> crateApiSetAudioLevelObserverEnabled(
      {required String trackId, int? peerId, required bool enabled});

  Future<void> crateApiSetAudioPlayoutDevice({required String deviceId});

  Future<void> crateApiSetCodecPreferences(
      {required ArcRtpTransceiver transceiver,
      required List<RtpCodecCapability> codecs});

  Future<void> crateApiSetLocalDescription(
      {required ArcPeerConnection peer,
      required SdpType kind,
      required String sdp});

  Future<void> crateApiSetMicrophoneVolume({required int level});

  Stream<void> crateApiSetOnDeviceChanged();

  Future<void> crateApiSetRemoteDescription(
      {required ArcPeerConnection peer,
      required SdpType kind,
      required String sdp});

  Future<void> crateApiSetTrackEnabled(
      {required String trackId,
      int? peerId,
      required MediaType kind,
      required bool enabled});

  Future<void> crateApiSetTransceiverDirection(
      {required ArcRtpTransceiver transceiver,
      required RtpTransceiverDirection direction});

  Future<void> crateApiSetTransceiverRecv(
      {required ArcRtpTransceiver transceiver, required bool recv});

  Future<void> crateApiSetTransceiverSend(
      {required ArcRtpTransceiver transceiver, required bool send});

  Future<void> crateApiStopTransceiver(
      {required ArcRtpTransceiver transceiver});

  Future<int?> crateApiTrackHeight(
      {required String trackId, int? peerId, required MediaType kind});

  Future<TrackState> crateApiTrackState(
      {required String trackId, int? peerId, required MediaType kind});

  Future<int?> crateApiTrackWidth(
      {required String trackId, int? peerId, required MediaType kind});

  Future<List<VideoCodecInfo>> crateApiVideoDecoders();

  Future<List<VideoCodecInfo>> crateApiVideoEncoders();

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ArcPeerConnection;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ArcPeerConnection;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_ArcPeerConnectionPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ArcRtpEncodingParameters;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ArcRtpEncodingParameters;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_ArcRtpEncodingParametersPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ArcRtpParameters;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ArcRtpParameters;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_ArcRtpParametersPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ArcRtpTransceiver;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ArcRtpTransceiver;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_ArcRtpTransceiverPtr;
}

class RustLibApiImpl extends RustLibApiImplPlatform implements RustLibApi {
  RustLibApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  Future<void> crateApiAddIceCandidate(
      {required ArcPeerConnection peer,
      required String candidate,
      required String sdpMid,
      required int sdpMlineIndex}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_RustOpaque_ArcPeerConnection(peer, serializer);
        sse_encode_String(candidate, serializer);
        sse_encode_String(sdpMid, serializer);
        sse_encode_i_32(sdpMlineIndex, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 1, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiAddIceCandidateConstMeta,
      argValues: [peer, candidate, sdpMid, sdpMlineIndex],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiAddIceCandidateConstMeta => const TaskConstMeta(
        debugName: "add_ice_candidate",
        argNames: ["peer", "candidate", "sdpMid", "sdpMlineIndex"],
      );

  @override
  Future<RtcRtpTransceiver> crateApiAddTransceiver(
      {required ArcPeerConnection peer,
      required MediaType mediaType,
      required RtpTransceiverInit init}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_RustOpaque_ArcPeerConnection(peer, serializer);
        sse_encode_media_type(mediaType, serializer);
        sse_encode_box_autoadd_rtp_transceiver_init(init, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 2, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_rtc_rtp_transceiver,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiAddTransceiverConstMeta,
      argValues: [peer, mediaType, init],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiAddTransceiverConstMeta => const TaskConstMeta(
        debugName: "add_transceiver",
        argNames: ["peer", "mediaType", "init"],
      );

  @override
  Future<MediaStreamTrack> crateApiCloneTrack(
      {required String trackId, int? peerId, required MediaType kind}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(trackId, serializer);
        sse_encode_opt_box_autoadd_u_32(peerId, serializer);
        sse_encode_media_type(kind, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 3, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_media_stream_track,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiCloneTrackConstMeta,
      argValues: [trackId, peerId, kind],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCloneTrackConstMeta => const TaskConstMeta(
        debugName: "clone_track",
        argNames: ["trackId", "peerId", "kind"],
      );

  @override
  Future<RtcSessionDescription> crateApiCreateAnswer(
      {required ArcPeerConnection peer,
      required bool voiceActivityDetection,
      required bool iceRestart,
      required bool useRtpMux}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_RustOpaque_ArcPeerConnection(peer, serializer);
        sse_encode_bool(voiceActivityDetection, serializer);
        sse_encode_bool(iceRestart, serializer);
        sse_encode_bool(useRtpMux, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 4, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_rtc_session_description,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiCreateAnswerConstMeta,
      argValues: [peer, voiceActivityDetection, iceRestart, useRtpMux],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCreateAnswerConstMeta => const TaskConstMeta(
        debugName: "create_answer",
        argNames: ["peer", "voiceActivityDetection", "iceRestart", "useRtpMux"],
      );

  @override
  Future<RtcSessionDescription> crateApiCreateOffer(
      {required ArcPeerConnection peer,
      required bool voiceActivityDetection,
      required bool iceRestart,
      required bool useRtpMux}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_RustOpaque_ArcPeerConnection(peer, serializer);
        sse_encode_bool(voiceActivityDetection, serializer);
        sse_encode_bool(iceRestart, serializer);
        sse_encode_bool(useRtpMux, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 5, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_rtc_session_description,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiCreateOfferConstMeta,
      argValues: [peer, voiceActivityDetection, iceRestart, useRtpMux],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCreateOfferConstMeta => const TaskConstMeta(
        debugName: "create_offer",
        argNames: ["peer", "voiceActivityDetection", "iceRestart", "useRtpMux"],
      );

  @override
  Stream<PeerConnectionEvent> crateApiCreatePeerConnection(
      {required RtcConfiguration configuration}) {
    final cb = RustStreamSink<PeerConnectionEvent>();
    unawaited(handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_StreamSink_peer_connection_event_Sse(cb, serializer);
        sse_encode_box_autoadd_rtc_configuration(configuration, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 6, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiCreatePeerConnectionConstMeta,
      argValues: [cb, configuration],
      apiImpl: this,
    )));
    return cb.stream;
  }

  TaskConstMeta get kCrateApiCreatePeerConnectionConstMeta =>
      const TaskConstMeta(
        debugName: "create_peer_connection",
        argNames: ["cb", "configuration"],
      );

  @override
  Stream<TextureEvent> crateApiCreateVideoSink(
      {required PlatformInt64 sinkId,
      int? peerId,
      required String trackId,
      required PlatformInt64 callbackPtr,
      required PlatformInt64 textureId}) {
    final cb = RustStreamSink<TextureEvent>();
    unawaited(handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_StreamSink_texture_event_Sse(cb, serializer);
        sse_encode_i_64(sinkId, serializer);
        sse_encode_opt_box_autoadd_u_32(peerId, serializer);
        sse_encode_String(trackId, serializer);
        sse_encode_i_64(callbackPtr, serializer);
        sse_encode_i_64(textureId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 7, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiCreateVideoSinkConstMeta,
      argValues: [cb, sinkId, peerId, trackId, callbackPtr, textureId],
      apiImpl: this,
    )));
    return cb.stream;
  }

  TaskConstMeta get kCrateApiCreateVideoSinkConstMeta => const TaskConstMeta(
        debugName: "create_video_sink",
        argNames: [
          "cb",
          "sinkId",
          "peerId",
          "trackId",
          "callbackPtr",
          "textureId"
        ],
      );

  @override
  Future<void> crateApiDisposePeerConnection(
      {required ArcPeerConnection peer}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_RustOpaque_ArcPeerConnection(peer, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 8, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiDisposePeerConnectionConstMeta,
      argValues: [peer],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDisposePeerConnectionConstMeta =>
      const TaskConstMeta(
        debugName: "dispose_peer_connection",
        argNames: ["peer"],
      );

  @override
  Future<void> crateApiDisposeTrack(
      {required String trackId, int? peerId, required MediaType kind}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(trackId, serializer);
        sse_encode_opt_box_autoadd_u_32(peerId, serializer);
        sse_encode_media_type(kind, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 9, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiDisposeTrackConstMeta,
      argValues: [trackId, peerId, kind],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDisposeTrackConstMeta => const TaskConstMeta(
        debugName: "dispose_track",
        argNames: ["trackId", "peerId", "kind"],
      );

  @override
  Future<void> crateApiDisposeVideoSink({required PlatformInt64 sinkId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_i_64(sinkId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 10, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiDisposeVideoSinkConstMeta,
      argValues: [sinkId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDisposeVideoSinkConstMeta => const TaskConstMeta(
        debugName: "dispose_video_sink",
        argNames: ["sinkId"],
      );

  @override
  Future<void> crateApiEnableFakeMedia() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 11, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiEnableFakeMediaConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEnableFakeMediaConstMeta => const TaskConstMeta(
        debugName: "enable_fake_media",
        argNames: [],
      );

  @override
  Future<List<MediaDeviceInfo>> crateApiEnumerateDevices() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 12, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_media_device_info,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiEnumerateDevicesConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEnumerateDevicesConstMeta => const TaskConstMeta(
        debugName: "enumerate_devices",
        argNames: [],
      );

  @override
  Future<List<MediaDisplayInfo>> crateApiEnumerateDisplays() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 13, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_media_display_info,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiEnumerateDisplaysConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEnumerateDisplaysConstMeta => const TaskConstMeta(
        debugName: "enumerate_displays",
        argNames: [],
      );

  @override
  Future<GetMediaResult> crateApiGetMedia(
      {required MediaStreamConstraints constraints}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_media_stream_constraints(
            constraints, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 14, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_get_media_result,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiGetMediaConstMeta,
      argValues: [constraints],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGetMediaConstMeta => const TaskConstMeta(
        debugName: "get_media",
        argNames: ["constraints"],
      );

  @override
  Future<List<RtcStats>> crateApiGetPeerStats(
      {required ArcPeerConnection peer}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_RustOpaque_ArcPeerConnection(peer, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 15, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_rtc_stats,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiGetPeerStatsConstMeta,
      argValues: [peer],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGetPeerStatsConstMeta => const TaskConstMeta(
        debugName: "get_peer_stats",
        argNames: ["peer"],
      );

  @override
  Future<RtpCapabilities> crateApiGetRtpReceiverCapabilities(
      {required MediaType kind}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_media_type(kind, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 16, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_rtp_capabilities,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiGetRtpReceiverCapabilitiesConstMeta,
      argValues: [kind],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGetRtpReceiverCapabilitiesConstMeta =>
      const TaskConstMeta(
        debugName: "get_rtp_receiver_capabilities",
        argNames: ["kind"],
      );

  @override
  Future<RtpCapabilities> crateApiGetRtpSenderCapabilities(
      {required MediaType kind}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_media_type(kind, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 17, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_rtp_capabilities,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiGetRtpSenderCapabilitiesConstMeta,
      argValues: [kind],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGetRtpSenderCapabilitiesConstMeta =>
      const TaskConstMeta(
        debugName: "get_rtp_sender_capabilities",
        argNames: ["kind"],
      );

  @override
  Future<RtpTransceiverDirection> crateApiGetTransceiverDirection(
      {required ArcRtpTransceiver transceiver}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_RustOpaque_ArcRtpTransceiver(transceiver, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 18, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_rtp_transceiver_direction,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiGetTransceiverDirectionConstMeta,
      argValues: [transceiver],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGetTransceiverDirectionConstMeta =>
      const TaskConstMeta(
        debugName: "get_transceiver_direction",
        argNames: ["transceiver"],
      );

  @override
  Future<String?> crateApiGetTransceiverMid(
      {required ArcRtpTransceiver transceiver}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_RustOpaque_ArcRtpTransceiver(transceiver, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 19, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiGetTransceiverMidConstMeta,
      argValues: [transceiver],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGetTransceiverMidConstMeta => const TaskConstMeta(
        debugName: "get_transceiver_mid",
        argNames: ["transceiver"],
      );

  @override
  Future<List<RtcRtpTransceiver>> crateApiGetTransceivers(
      {required ArcPeerConnection peer}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_RustOpaque_ArcPeerConnection(peer, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 20, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_rtc_rtp_transceiver,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiGetTransceiversConstMeta,
      argValues: [peer],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGetTransceiversConstMeta => const TaskConstMeta(
        debugName: "get_transceivers",
        argNames: ["peer"],
      );

  @override
  Future<bool> crateApiIsFakeMedia() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 21, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiIsFakeMediaConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiIsFakeMediaConstMeta => const TaskConstMeta(
        debugName: "is_fake_media",
        argNames: [],
      );

  @override
  Future<int> crateApiMicrophoneVolume() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 22, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_u_32,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiMicrophoneVolumeConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiMicrophoneVolumeConstMeta => const TaskConstMeta(
        debugName: "microphone_volume",
        argNames: [],
      );

  @override
  Future<bool> crateApiMicrophoneVolumeIsAvailable() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 23, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiMicrophoneVolumeIsAvailableConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiMicrophoneVolumeIsAvailableConstMeta =>
      const TaskConstMeta(
        debugName: "microphone_volume_is_available",
        argNames: [],
      );

  @override
  Stream<TrackEvent> crateApiRegisterTrackObserver(
      {int? peerId, required String trackId, required MediaType kind}) {
    final cb = RustStreamSink<TrackEvent>();
    unawaited(handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_StreamSink_track_event_Sse(cb, serializer);
        sse_encode_opt_box_autoadd_u_32(peerId, serializer);
        sse_encode_String(trackId, serializer);
        sse_encode_media_type(kind, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 24, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiRegisterTrackObserverConstMeta,
      argValues: [cb, peerId, trackId, kind],
      apiImpl: this,
    )));
    return cb.stream;
  }

  TaskConstMeta get kCrateApiRegisterTrackObserverConstMeta =>
      const TaskConstMeta(
        debugName: "register_track_observer",
        argNames: ["cb", "peerId", "trackId", "kind"],
      );

  @override
  Future<void> crateApiRestartIce({required ArcPeerConnection peer}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_RustOpaque_ArcPeerConnection(peer, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 25, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiRestartIceConstMeta,
      argValues: [peer],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiRestartIceConstMeta => const TaskConstMeta(
        debugName: "restart_ice",
        argNames: ["peer"],
      );

  @override
  Future<RtcRtpSendParameters> crateApiSenderGetParameters(
      {required ArcRtpTransceiver transceiver}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_RustOpaque_ArcRtpTransceiver(transceiver, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 26, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_rtc_rtp_send_parameters,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSenderGetParametersConstMeta,
      argValues: [transceiver],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSenderGetParametersConstMeta =>
      const TaskConstMeta(
        debugName: "sender_get_parameters",
        argNames: ["transceiver"],
      );

  @override
  Future<void> crateApiSenderReplaceTrack(
      {required ArcPeerConnection peer,
      required ArcRtpTransceiver transceiver,
      String? trackId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_RustOpaque_ArcPeerConnection(peer, serializer);
        sse_encode_RustOpaque_ArcRtpTransceiver(transceiver, serializer);
        sse_encode_opt_String(trackId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 27, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiSenderReplaceTrackConstMeta,
      argValues: [peer, transceiver, trackId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSenderReplaceTrackConstMeta => const TaskConstMeta(
        debugName: "sender_replace_track",
        argNames: ["peer", "transceiver", "trackId"],
      );

  @override
  Future<void> crateApiSenderSetParameters(
      {required ArcRtpTransceiver transceiver,
      required RtcRtpSendParameters params}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_RustOpaque_ArcRtpTransceiver(transceiver, serializer);
        sse_encode_box_autoadd_rtc_rtp_send_parameters(params, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 28, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiSenderSetParametersConstMeta,
      argValues: [transceiver, params],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSenderSetParametersConstMeta =>
      const TaskConstMeta(
        debugName: "sender_set_parameters",
        argNames: ["transceiver", "params"],
      );

  @override
  Future<void> crateApiSetAudioLevelObserverEnabled(
      {required String trackId, int? peerId, required bool enabled}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(trackId, serializer);
        sse_encode_opt_box_autoadd_u_32(peerId, serializer);
        sse_encode_bool(enabled, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 29, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiSetAudioLevelObserverEnabledConstMeta,
      argValues: [trackId, peerId, enabled],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSetAudioLevelObserverEnabledConstMeta =>
      const TaskConstMeta(
        debugName: "set_audio_level_observer_enabled",
        argNames: ["trackId", "peerId", "enabled"],
      );

  @override
  Future<void> crateApiSetAudioPlayoutDevice({required String deviceId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(deviceId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 30, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiSetAudioPlayoutDeviceConstMeta,
      argValues: [deviceId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSetAudioPlayoutDeviceConstMeta =>
      const TaskConstMeta(
        debugName: "set_audio_playout_device",
        argNames: ["deviceId"],
      );

  @override
  Future<void> crateApiSetCodecPreferences(
      {required ArcRtpTransceiver transceiver,
      required List<RtpCodecCapability> codecs}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_RustOpaque_ArcRtpTransceiver(transceiver, serializer);
        sse_encode_list_rtp_codec_capability(codecs, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 31, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSetCodecPreferencesConstMeta,
      argValues: [transceiver, codecs],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSetCodecPreferencesConstMeta =>
      const TaskConstMeta(
        debugName: "set_codec_preferences",
        argNames: ["transceiver", "codecs"],
      );

  @override
  Future<void> crateApiSetLocalDescription(
      {required ArcPeerConnection peer,
      required SdpType kind,
      required String sdp}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_RustOpaque_ArcPeerConnection(peer, serializer);
        sse_encode_sdp_type(kind, serializer);
        sse_encode_String(sdp, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 32, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiSetLocalDescriptionConstMeta,
      argValues: [peer, kind, sdp],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSetLocalDescriptionConstMeta =>
      const TaskConstMeta(
        debugName: "set_local_description",
        argNames: ["peer", "kind", "sdp"],
      );

  @override
  Future<void> crateApiSetMicrophoneVolume({required int level}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_8(level, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 33, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiSetMicrophoneVolumeConstMeta,
      argValues: [level],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSetMicrophoneVolumeConstMeta =>
      const TaskConstMeta(
        debugName: "set_microphone_volume",
        argNames: ["level"],
      );

  @override
  Stream<void> crateApiSetOnDeviceChanged() {
    final cb = RustStreamSink<void>();
    unawaited(handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_StreamSink_unit_Sse(cb, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 34, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiSetOnDeviceChangedConstMeta,
      argValues: [cb],
      apiImpl: this,
    )));
    return cb.stream;
  }

  TaskConstMeta get kCrateApiSetOnDeviceChangedConstMeta => const TaskConstMeta(
        debugName: "set_on_device_changed",
        argNames: ["cb"],
      );

  @override
  Future<void> crateApiSetRemoteDescription(
      {required ArcPeerConnection peer,
      required SdpType kind,
      required String sdp}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_RustOpaque_ArcPeerConnection(peer, serializer);
        sse_encode_sdp_type(kind, serializer);
        sse_encode_String(sdp, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 35, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiSetRemoteDescriptionConstMeta,
      argValues: [peer, kind, sdp],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSetRemoteDescriptionConstMeta =>
      const TaskConstMeta(
        debugName: "set_remote_description",
        argNames: ["peer", "kind", "sdp"],
      );

  @override
  Future<void> crateApiSetTrackEnabled(
      {required String trackId,
      int? peerId,
      required MediaType kind,
      required bool enabled}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(trackId, serializer);
        sse_encode_opt_box_autoadd_u_32(peerId, serializer);
        sse_encode_media_type(kind, serializer);
        sse_encode_bool(enabled, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 36, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiSetTrackEnabledConstMeta,
      argValues: [trackId, peerId, kind, enabled],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSetTrackEnabledConstMeta => const TaskConstMeta(
        debugName: "set_track_enabled",
        argNames: ["trackId", "peerId", "kind", "enabled"],
      );

  @override
  Future<void> crateApiSetTransceiverDirection(
      {required ArcRtpTransceiver transceiver,
      required RtpTransceiverDirection direction}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_RustOpaque_ArcRtpTransceiver(transceiver, serializer);
        sse_encode_rtp_transceiver_direction(direction, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 37, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiSetTransceiverDirectionConstMeta,
      argValues: [transceiver, direction],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSetTransceiverDirectionConstMeta =>
      const TaskConstMeta(
        debugName: "set_transceiver_direction",
        argNames: ["transceiver", "direction"],
      );

  @override
  Future<void> crateApiSetTransceiverRecv(
      {required ArcRtpTransceiver transceiver, required bool recv}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_RustOpaque_ArcRtpTransceiver(transceiver, serializer);
        sse_encode_bool(recv, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 38, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiSetTransceiverRecvConstMeta,
      argValues: [transceiver, recv],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSetTransceiverRecvConstMeta => const TaskConstMeta(
        debugName: "set_transceiver_recv",
        argNames: ["transceiver", "recv"],
      );

  @override
  Future<void> crateApiSetTransceiverSend(
      {required ArcRtpTransceiver transceiver, required bool send}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_RustOpaque_ArcRtpTransceiver(transceiver, serializer);
        sse_encode_bool(send, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 39, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiSetTransceiverSendConstMeta,
      argValues: [transceiver, send],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSetTransceiverSendConstMeta => const TaskConstMeta(
        debugName: "set_transceiver_send",
        argNames: ["transceiver", "send"],
      );

  @override
  Future<void> crateApiStopTransceiver(
      {required ArcRtpTransceiver transceiver}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_RustOpaque_ArcRtpTransceiver(transceiver, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 40, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiStopTransceiverConstMeta,
      argValues: [transceiver],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiStopTransceiverConstMeta => const TaskConstMeta(
        debugName: "stop_transceiver",
        argNames: ["transceiver"],
      );

  @override
  Future<int?> crateApiTrackHeight(
      {required String trackId, int? peerId, required MediaType kind}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(trackId, serializer);
        sse_encode_opt_box_autoadd_u_32(peerId, serializer);
        sse_encode_media_type(kind, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 41, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_i_32,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiTrackHeightConstMeta,
      argValues: [trackId, peerId, kind],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiTrackHeightConstMeta => const TaskConstMeta(
        debugName: "track_height",
        argNames: ["trackId", "peerId", "kind"],
      );

  @override
  Future<TrackState> crateApiTrackState(
      {required String trackId, int? peerId, required MediaType kind}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(trackId, serializer);
        sse_encode_opt_box_autoadd_u_32(peerId, serializer);
        sse_encode_media_type(kind, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 42, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_track_state,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiTrackStateConstMeta,
      argValues: [trackId, peerId, kind],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiTrackStateConstMeta => const TaskConstMeta(
        debugName: "track_state",
        argNames: ["trackId", "peerId", "kind"],
      );

  @override
  Future<int?> crateApiTrackWidth(
      {required String trackId, int? peerId, required MediaType kind}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(trackId, serializer);
        sse_encode_opt_box_autoadd_u_32(peerId, serializer);
        sse_encode_media_type(kind, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 43, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_i_32,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiTrackWidthConstMeta,
      argValues: [trackId, peerId, kind],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiTrackWidthConstMeta => const TaskConstMeta(
        debugName: "track_width",
        argNames: ["trackId", "peerId", "kind"],
      );

  @override
  Future<List<VideoCodecInfo>> crateApiVideoDecoders() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 44, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_video_codec_info,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVideoDecodersConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVideoDecodersConstMeta => const TaskConstMeta(
        debugName: "video_decoders",
        argNames: [],
      );

  @override
  Future<List<VideoCodecInfo>> crateApiVideoEncoders() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 45, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_video_codec_info,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVideoEncodersConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVideoEncodersConstMeta => const TaskConstMeta(
        debugName: "video_encoders",
        argNames: [],
      );

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ArcPeerConnection =>
          wire.rust_arc_increment_strong_count_RustOpaque_ArcPeerConnection;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ArcPeerConnection =>
          wire.rust_arc_decrement_strong_count_RustOpaque_ArcPeerConnection;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ArcRtpEncodingParameters => wire
          .rust_arc_increment_strong_count_RustOpaque_ArcRtpEncodingParameters;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ArcRtpEncodingParameters => wire
          .rust_arc_decrement_strong_count_RustOpaque_ArcRtpEncodingParameters;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ArcRtpParameters =>
          wire.rust_arc_increment_strong_count_RustOpaque_ArcRtpParameters;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ArcRtpParameters =>
          wire.rust_arc_decrement_strong_count_RustOpaque_ArcRtpParameters;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ArcRtpTransceiver =>
          wire.rust_arc_increment_strong_count_RustOpaque_ArcRtpTransceiver;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ArcRtpTransceiver =>
          wire.rust_arc_decrement_strong_count_RustOpaque_ArcRtpTransceiver;

  @protected
  AnyhowException dco_decode_AnyhowException(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AnyhowException(raw as String);
  }

  @protected
  ArcPeerConnection dco_decode_RustOpaque_ArcPeerConnection(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ArcPeerConnectionImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ArcRtpEncodingParameters dco_decode_RustOpaque_ArcRtpEncodingParameters(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ArcRtpEncodingParametersImpl.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  ArcRtpParameters dco_decode_RustOpaque_ArcRtpParameters(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ArcRtpParametersImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ArcRtpTransceiver dco_decode_RustOpaque_ArcRtpTransceiver(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ArcRtpTransceiverImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  RustStreamSink<PeerConnectionEvent>
      dco_decode_StreamSink_peer_connection_event_Sse(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  RustStreamSink<TextureEvent> dco_decode_StreamSink_texture_event_Sse(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  RustStreamSink<TrackEvent> dco_decode_StreamSink_track_event_Sse(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  RustStreamSink<void> dco_decode_StreamSink_unit_Sse(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  AudioConstraints dco_decode_audio_constraints(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return AudioConstraints(
      deviceId: dco_decode_opt_String(arr[0]),
      autoGainControl: dco_decode_opt_box_autoadd_bool(arr[1]),
    );
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  AudioConstraints dco_decode_box_autoadd_audio_constraints(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_audio_constraints(raw);
  }

  @protected
  bool dco_decode_box_autoadd_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  double dco_decode_box_autoadd_f_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  GetMediaError dco_decode_box_autoadd_get_media_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_get_media_error(raw);
  }

  @protected
  int dco_decode_box_autoadd_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  IceCandidateStats dco_decode_box_autoadd_ice_candidate_stats(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ice_candidate_stats(raw);
  }

  @protected
  IceRole dco_decode_box_autoadd_ice_role(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ice_role(raw);
  }

  @protected
  MediaStreamConstraints dco_decode_box_autoadd_media_stream_constraints(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_media_stream_constraints(raw);
  }

  @protected
  Protocol dco_decode_box_autoadd_protocol(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_protocol(raw);
  }

  @protected
  RtcConfiguration dco_decode_box_autoadd_rtc_configuration(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_rtc_configuration(raw);
  }

  @protected
  RtcIceCandidateStats dco_decode_box_autoadd_rtc_ice_candidate_stats(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_rtc_ice_candidate_stats(raw);
  }

  @protected
  RtcInboundRtpStreamMediaType
      dco_decode_box_autoadd_rtc_inbound_rtp_stream_media_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_rtc_inbound_rtp_stream_media_type(raw);
  }

  @protected
  RtcMediaSourceStatsMediaType
      dco_decode_box_autoadd_rtc_media_source_stats_media_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_rtc_media_source_stats_media_type(raw);
  }

  @protected
  RtcOutboundRtpStreamStatsMediaType
      dco_decode_box_autoadd_rtc_outbound_rtp_stream_stats_media_type(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_rtc_outbound_rtp_stream_stats_media_type(raw);
  }

  @protected
  RtcRtpSendParameters dco_decode_box_autoadd_rtc_rtp_send_parameters(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_rtc_rtp_send_parameters(raw);
  }

  @protected
  RtcTrackEvent dco_decode_box_autoadd_rtc_track_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_rtc_track_event(raw);
  }

  @protected
  RtcpFeedbackMessageType dco_decode_box_autoadd_rtcp_feedback_message_type(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_rtcp_feedback_message_type(raw);
  }

  @protected
  RtpTransceiverInit dco_decode_box_autoadd_rtp_transceiver_init(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_rtp_transceiver_init(raw);
  }

  @protected
  int dco_decode_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  BigInt dco_decode_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_u_64(raw);
  }

  @protected
  VideoConstraints dco_decode_box_autoadd_video_constraints(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_video_constraints(raw);
  }

  @protected
  BundlePolicy dco_decode_bundle_policy(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return BundlePolicy.values[raw as int];
  }

  @protected
  CandidateType dco_decode_candidate_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return CandidateType.values[raw as int];
  }

  @protected
  double dco_decode_f_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  GetMediaError dco_decode_get_media_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return GetMediaError_Audio(
          dco_decode_String(raw[1]),
        );
      case 1:
        return GetMediaError_Video(
          dco_decode_String(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  GetMediaResult dco_decode_get_media_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return GetMediaResult_Ok(
          dco_decode_list_media_stream_track(raw[1]),
        );
      case 1:
        return GetMediaResult_Err(
          dco_decode_box_autoadd_get_media_error(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  PlatformInt64 dco_decode_i_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeI64(raw);
  }

  @protected
  IceCandidateStats dco_decode_ice_candidate_stats(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 8)
      throw Exception('unexpected arr length: expect 8 but see ${arr.length}');
    return IceCandidateStats(
      transportId: dco_decode_opt_String(arr[0]),
      address: dco_decode_opt_String(arr[1]),
      port: dco_decode_opt_box_autoadd_i_32(arr[2]),
      protocol: dco_decode_protocol(arr[3]),
      candidateType: dco_decode_candidate_type(arr[4]),
      priority: dco_decode_opt_box_autoadd_i_32(arr[5]),
      url: dco_decode_opt_String(arr[6]),
      relayProtocol: dco_decode_opt_box_autoadd_protocol(arr[7]),
    );
  }

  @protected
  IceConnectionState dco_decode_ice_connection_state(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return IceConnectionState.values[raw as int];
  }

  @protected
  IceGatheringState dco_decode_ice_gathering_state(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return IceGatheringState.values[raw as int];
  }

  @protected
  IceRole dco_decode_ice_role(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return IceRole.values[raw as int];
  }

  @protected
  IceTransportsType dco_decode_ice_transports_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return IceTransportsType.values[raw as int];
  }

  @protected
  List<String> dco_decode_list_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_String).toList();
  }

  @protected
  List<MediaDeviceInfo> dco_decode_list_media_device_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_media_device_info).toList();
  }

  @protected
  List<MediaDisplayInfo> dco_decode_list_media_display_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_media_display_info).toList();
  }

  @protected
  List<MediaStreamTrack> dco_decode_list_media_stream_track(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_media_stream_track).toList();
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  List<(RtcRtpEncodingParameters, ArcRtpEncodingParameters)>
      dco_decode_list_record_rtc_rtp_encoding_parameters_rust_opaque_arc_rtp_encoding_parameters(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(
            dco_decode_record_rtc_rtp_encoding_parameters_rust_opaque_arc_rtp_encoding_parameters)
        .toList();
  }

  @protected
  List<(String, String)> dco_decode_list_record_string_string(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_record_string_string).toList();
  }

  @protected
  List<RtcIceServer> dco_decode_list_rtc_ice_server(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_rtc_ice_server).toList();
  }

  @protected
  List<RtcRtpEncodingParameters> dco_decode_list_rtc_rtp_encoding_parameters(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_rtc_rtp_encoding_parameters)
        .toList();
  }

  @protected
  List<RtcRtpTransceiver> dco_decode_list_rtc_rtp_transceiver(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_rtc_rtp_transceiver).toList();
  }

  @protected
  List<RtcStats> dco_decode_list_rtc_stats(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_rtc_stats).toList();
  }

  @protected
  List<RtcpFeedback> dco_decode_list_rtcp_feedback(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_rtcp_feedback).toList();
  }

  @protected
  List<RtpCodecCapability> dco_decode_list_rtp_codec_capability(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_rtp_codec_capability).toList();
  }

  @protected
  List<RtpHeaderExtensionCapability>
      dco_decode_list_rtp_header_extension_capability(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_rtp_header_extension_capability)
        .toList();
  }

  @protected
  List<ScalabilityMode> dco_decode_list_scalability_mode(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_scalability_mode).toList();
  }

  @protected
  List<VideoCodecInfo> dco_decode_list_video_codec_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_video_codec_info).toList();
  }

  @protected
  MediaDeviceInfo dco_decode_media_device_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return MediaDeviceInfo(
      deviceId: dco_decode_String(arr[0]),
      kind: dco_decode_media_device_kind(arr[1]),
      label: dco_decode_String(arr[2]),
    );
  }

  @protected
  MediaDeviceKind dco_decode_media_device_kind(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MediaDeviceKind.values[raw as int];
  }

  @protected
  MediaDisplayInfo dco_decode_media_display_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return MediaDisplayInfo(
      deviceId: dco_decode_String(arr[0]),
      title: dco_decode_opt_String(arr[1]),
    );
  }

  @protected
  MediaStreamConstraints dco_decode_media_stream_constraints(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return MediaStreamConstraints(
      audio: dco_decode_opt_box_autoadd_audio_constraints(arr[0]),
      video: dco_decode_opt_box_autoadd_video_constraints(arr[1]),
    );
  }

  @protected
  MediaStreamTrack dco_decode_media_stream_track(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return MediaStreamTrack(
      id: dco_decode_String(arr[0]),
      peerId: dco_decode_opt_box_autoadd_u_32(arr[1]),
      deviceId: dco_decode_String(arr[2]),
      kind: dco_decode_media_type(arr[3]),
      enabled: dco_decode_bool(arr[4]),
    );
  }

  @protected
  MediaType dco_decode_media_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MediaType.values[raw as int];
  }

  @protected
  String? dco_decode_opt_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_String(raw);
  }

  @protected
  AudioConstraints? dco_decode_opt_box_autoadd_audio_constraints(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_audio_constraints(raw);
  }

  @protected
  bool? dco_decode_opt_box_autoadd_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_bool(raw);
  }

  @protected
  double? dco_decode_opt_box_autoadd_f_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_f_64(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_i_32(raw);
  }

  @protected
  IceRole? dco_decode_opt_box_autoadd_ice_role(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_ice_role(raw);
  }

  @protected
  Protocol? dco_decode_opt_box_autoadd_protocol(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_protocol(raw);
  }

  @protected
  RtcInboundRtpStreamMediaType?
      dco_decode_opt_box_autoadd_rtc_inbound_rtp_stream_media_type(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_rtc_inbound_rtp_stream_media_type(raw);
  }

  @protected
  RtcpFeedbackMessageType?
      dco_decode_opt_box_autoadd_rtcp_feedback_message_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_rtcp_feedback_message_type(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_32(raw);
  }

  @protected
  BigInt? dco_decode_opt_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_64(raw);
  }

  @protected
  VideoConstraints? dco_decode_opt_box_autoadd_video_constraints(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_video_constraints(raw);
  }

  @protected
  PeerConnectionEvent dco_decode_peer_connection_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return PeerConnectionEvent_PeerCreated(
          peer: dco_decode_RustOpaque_ArcPeerConnection(raw[1]),
        );
      case 1:
        return PeerConnectionEvent_IceCandidate(
          sdpMid: dco_decode_String(raw[1]),
          sdpMlineIndex: dco_decode_i_32(raw[2]),
          candidate: dco_decode_String(raw[3]),
        );
      case 2:
        return PeerConnectionEvent_IceGatheringStateChange(
          dco_decode_ice_gathering_state(raw[1]),
        );
      case 3:
        return PeerConnectionEvent_IceCandidateError(
          address: dco_decode_String(raw[1]),
          port: dco_decode_i_32(raw[2]),
          url: dco_decode_String(raw[3]),
          errorCode: dco_decode_i_32(raw[4]),
          errorText: dco_decode_String(raw[5]),
        );
      case 4:
        return PeerConnectionEvent_NegotiationNeeded();
      case 5:
        return PeerConnectionEvent_SignallingChange(
          dco_decode_signaling_state(raw[1]),
        );
      case 6:
        return PeerConnectionEvent_IceConnectionStateChange(
          dco_decode_ice_connection_state(raw[1]),
        );
      case 7:
        return PeerConnectionEvent_ConnectionStateChange(
          dco_decode_peer_connection_state(raw[1]),
        );
      case 8:
        return PeerConnectionEvent_Track(
          dco_decode_box_autoadd_rtc_track_event(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  PeerConnectionState dco_decode_peer_connection_state(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PeerConnectionState.values[raw as int];
  }

  @protected
  Protocol dco_decode_protocol(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Protocol.values[raw as int];
  }

  @protected
  (
    RtcRtpEncodingParameters,
    ArcRtpEncodingParameters
  ) dco_decode_record_rtc_rtp_encoding_parameters_rust_opaque_arc_rtp_encoding_parameters(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_rtc_rtp_encoding_parameters(arr[0]),
      dco_decode_RustOpaque_ArcRtpEncodingParameters(arr[1]),
    );
  }

  @protected
  (String, String) dco_decode_record_string_string(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_String(arr[0]),
      dco_decode_String(arr[1]),
    );
  }

  @protected
  RtcConfiguration dco_decode_rtc_configuration(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return RtcConfiguration(
      iceTransportPolicy: dco_decode_ice_transports_type(arr[0]),
      bundlePolicy: dco_decode_bundle_policy(arr[1]),
      iceServers: dco_decode_list_rtc_ice_server(arr[2]),
    );
  }

  @protected
  RtcIceCandidateStats dco_decode_rtc_ice_candidate_stats(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return RtcIceCandidateStats_Local(
          dco_decode_box_autoadd_ice_candidate_stats(raw[1]),
        );
      case 1:
        return RtcIceCandidateStats_Remote(
          dco_decode_box_autoadd_ice_candidate_stats(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  RtcIceServer dco_decode_rtc_ice_server(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return RtcIceServer(
      urls: dco_decode_list_String(arr[0]),
      username: dco_decode_String(arr[1]),
      credential: dco_decode_String(arr[2]),
    );
  }

  @protected
  RtcInboundRtpStreamMediaType dco_decode_rtc_inbound_rtp_stream_media_type(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return RtcInboundRtpStreamMediaType_Audio(
          voiceActivityFlag: dco_decode_opt_box_autoadd_bool(raw[1]),
          totalSamplesReceived: dco_decode_opt_box_autoadd_u_64(raw[2]),
          concealedSamples: dco_decode_opt_box_autoadd_u_64(raw[3]),
          silentConcealedSamples: dco_decode_opt_box_autoadd_u_64(raw[4]),
          audioLevel: dco_decode_opt_box_autoadd_f_64(raw[5]),
          totalAudioEnergy: dco_decode_opt_box_autoadd_f_64(raw[6]),
          totalSamplesDuration: dco_decode_opt_box_autoadd_f_64(raw[7]),
        );
      case 1:
        return RtcInboundRtpStreamMediaType_Video(
          framesDecoded: dco_decode_opt_box_autoadd_u_32(raw[1]),
          keyFramesDecoded: dco_decode_opt_box_autoadd_u_32(raw[2]),
          frameWidth: dco_decode_opt_box_autoadd_u_32(raw[3]),
          frameHeight: dco_decode_opt_box_autoadd_u_32(raw[4]),
          totalInterFrameDelay: dco_decode_opt_box_autoadd_f_64(raw[5]),
          framesPerSecond: dco_decode_opt_box_autoadd_f_64(raw[6]),
          firCount: dco_decode_opt_box_autoadd_u_32(raw[7]),
          pliCount: dco_decode_opt_box_autoadd_u_32(raw[8]),
          sliCount: dco_decode_opt_box_autoadd_u_32(raw[9]),
          concealmentEvents: dco_decode_opt_box_autoadd_u_64(raw[10]),
          framesReceived: dco_decode_opt_box_autoadd_i_32(raw[11]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  RtcMediaSourceStatsMediaType dco_decode_rtc_media_source_stats_media_type(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return RtcMediaSourceStatsMediaType_RtcVideoSourceStats(
          width: dco_decode_opt_box_autoadd_u_32(raw[1]),
          height: dco_decode_opt_box_autoadd_u_32(raw[2]),
          frames: dco_decode_opt_box_autoadd_u_32(raw[3]),
          framesPerSecond: dco_decode_opt_box_autoadd_f_64(raw[4]),
        );
      case 1:
        return RtcMediaSourceStatsMediaType_RtcAudioSourceStats(
          audioLevel: dco_decode_opt_box_autoadd_f_64(raw[1]),
          totalAudioEnergy: dco_decode_opt_box_autoadd_f_64(raw[2]),
          totalSamplesDuration: dco_decode_opt_box_autoadd_f_64(raw[3]),
          echoReturnLoss: dco_decode_opt_box_autoadd_f_64(raw[4]),
          echoReturnLossEnhancement: dco_decode_opt_box_autoadd_f_64(raw[5]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  RtcOutboundRtpStreamStatsMediaType
      dco_decode_rtc_outbound_rtp_stream_stats_media_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return RtcOutboundRtpStreamStatsMediaType_Audio(
          totalSamplesSent: dco_decode_opt_box_autoadd_u_64(raw[1]),
          voiceActivityFlag: dco_decode_opt_box_autoadd_bool(raw[2]),
        );
      case 1:
        return RtcOutboundRtpStreamStatsMediaType_Video(
          frameWidth: dco_decode_opt_box_autoadd_u_32(raw[1]),
          frameHeight: dco_decode_opt_box_autoadd_u_32(raw[2]),
          framesPerSecond: dco_decode_opt_box_autoadd_f_64(raw[3]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  RtcRtpEncodingParameters dco_decode_rtc_rtp_encoding_parameters(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return RtcRtpEncodingParameters(
      rid: dco_decode_String(arr[0]),
      active: dco_decode_bool(arr[1]),
      maxBitrate: dco_decode_opt_box_autoadd_i_32(arr[2]),
      maxFramerate: dco_decode_opt_box_autoadd_f_64(arr[3]),
      scaleResolutionDownBy: dco_decode_opt_box_autoadd_f_64(arr[4]),
      scalabilityMode: dco_decode_opt_String(arr[5]),
    );
  }

  @protected
  RtcRtpSendParameters dco_decode_rtc_rtp_send_parameters(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return RtcRtpSendParameters(
      encodings:
          dco_decode_list_record_rtc_rtp_encoding_parameters_rust_opaque_arc_rtp_encoding_parameters(
              arr[0]),
      inner: dco_decode_RustOpaque_ArcRtpParameters(arr[1]),
    );
  }

  @protected
  RtcRtpTransceiver dco_decode_rtc_rtp_transceiver(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return RtcRtpTransceiver(
      peer: dco_decode_RustOpaque_ArcPeerConnection(arr[0]),
      transceiver: dco_decode_RustOpaque_ArcRtpTransceiver(arr[1]),
      mid: dco_decode_opt_String(arr[2]),
      direction: dco_decode_rtp_transceiver_direction(arr[3]),
    );
  }

  @protected
  RtcSessionDescription dco_decode_rtc_session_description(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return RtcSessionDescription(
      sdp: dco_decode_String(arr[0]),
      kind: dco_decode_sdp_type(arr[1]),
    );
  }

  @protected
  RtcStats dco_decode_rtc_stats(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return RtcStats(
      id: dco_decode_String(arr[0]),
      timestampUs: dco_decode_i_64(arr[1]),
      kind: dco_decode_rtc_stats_type(arr[2]),
    );
  }

  @protected
  RtcStatsIceCandidatePairState dco_decode_rtc_stats_ice_candidate_pair_state(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return RtcStatsIceCandidatePairState.values[raw as int];
  }

  @protected
  RtcStatsType dco_decode_rtc_stats_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return RtcStatsType_RtcMediaSourceStats(
          trackIdentifier: dco_decode_opt_String(raw[1]),
          kind:
              dco_decode_box_autoadd_rtc_media_source_stats_media_type(raw[2]),
        );
      case 1:
        return RtcStatsType_RtcIceCandidateStats(
          dco_decode_box_autoadd_rtc_ice_candidate_stats(raw[1]),
        );
      case 2:
        return RtcStatsType_RtcOutboundRtpStreamStats(
          trackId: dco_decode_opt_String(raw[1]),
          mediaType:
              dco_decode_box_autoadd_rtc_outbound_rtp_stream_stats_media_type(
                  raw[2]),
          bytesSent: dco_decode_opt_box_autoadd_u_64(raw[3]),
          packetsSent: dco_decode_opt_box_autoadd_u_32(raw[4]),
          mediaSourceId: dco_decode_opt_String(raw[5]),
        );
      case 3:
        return RtcStatsType_RtcInboundRtpStreamStats(
          remoteId: dco_decode_opt_String(raw[1]),
          bytesReceived: dco_decode_opt_box_autoadd_u_64(raw[2]),
          packetsReceived: dco_decode_opt_box_autoadd_u_32(raw[3]),
          packetsLost: dco_decode_opt_box_autoadd_u_64(raw[4]),
          jitter: dco_decode_opt_box_autoadd_f_64(raw[5]),
          totalDecodeTime: dco_decode_opt_box_autoadd_f_64(raw[6]),
          jitterBufferEmittedCount: dco_decode_opt_box_autoadd_u_64(raw[7]),
          mediaType:
              dco_decode_opt_box_autoadd_rtc_inbound_rtp_stream_media_type(
                  raw[8]),
        );
      case 4:
        return RtcStatsType_RtcIceCandidatePairStats(
          state: dco_decode_rtc_stats_ice_candidate_pair_state(raw[1]),
          nominated: dco_decode_opt_box_autoadd_bool(raw[2]),
          bytesSent: dco_decode_opt_box_autoadd_u_64(raw[3]),
          bytesReceived: dco_decode_opt_box_autoadd_u_64(raw[4]),
          totalRoundTripTime: dco_decode_opt_box_autoadd_f_64(raw[5]),
          currentRoundTripTime: dco_decode_opt_box_autoadd_f_64(raw[6]),
          availableOutgoingBitrate: dco_decode_opt_box_autoadd_f_64(raw[7]),
        );
      case 5:
        return RtcStatsType_RtcTransportStats(
          packetsSent: dco_decode_opt_box_autoadd_u_64(raw[1]),
          packetsReceived: dco_decode_opt_box_autoadd_u_64(raw[2]),
          bytesSent: dco_decode_opt_box_autoadd_u_64(raw[3]),
          bytesReceived: dco_decode_opt_box_autoadd_u_64(raw[4]),
          iceRole: dco_decode_opt_box_autoadd_ice_role(raw[5]),
        );
      case 6:
        return RtcStatsType_RtcRemoteInboundRtpStreamStats(
          localId: dco_decode_opt_String(raw[1]),
          jitter: dco_decode_opt_box_autoadd_f_64(raw[2]),
          roundTripTime: dco_decode_opt_box_autoadd_f_64(raw[3]),
          fractionLost: dco_decode_opt_box_autoadd_f_64(raw[4]),
          reportsReceived: dco_decode_opt_box_autoadd_u_64(raw[5]),
          roundTripTimeMeasurements: dco_decode_opt_box_autoadd_i_32(raw[6]),
        );
      case 7:
        return RtcStatsType_RtcRemoteOutboundRtpStreamStats(
          localId: dco_decode_opt_String(raw[1]),
          remoteTimestamp: dco_decode_opt_box_autoadd_f_64(raw[2]),
          reportsSent: dco_decode_opt_box_autoadd_u_64(raw[3]),
        );
      case 8:
        return RtcStatsType_Unimplemented();
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  RtcTrackEvent dco_decode_rtc_track_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return RtcTrackEvent(
      track: dco_decode_media_stream_track(arr[0]),
      transceiver: dco_decode_rtc_rtp_transceiver(arr[1]),
    );
  }

  @protected
  RtcpFeedback dco_decode_rtcp_feedback(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return RtcpFeedback(
      messageType:
          dco_decode_opt_box_autoadd_rtcp_feedback_message_type(arr[0]),
      kind: dco_decode_rtcp_feedback_type(arr[1]),
    );
  }

  @protected
  RtcpFeedbackMessageType dco_decode_rtcp_feedback_message_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return RtcpFeedbackMessageType.values[raw as int];
  }

  @protected
  RtcpFeedbackType dco_decode_rtcp_feedback_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return RtcpFeedbackType.values[raw as int];
  }

  @protected
  RtpCapabilities dco_decode_rtp_capabilities(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return RtpCapabilities(
      codecs: dco_decode_list_rtp_codec_capability(arr[0]),
      headerExtensions: dco_decode_list_rtp_header_extension_capability(arr[1]),
    );
  }

  @protected
  RtpCodecCapability dco_decode_rtp_codec_capability(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 9)
      throw Exception('unexpected arr length: expect 9 but see ${arr.length}');
    return RtpCodecCapability(
      preferredPayloadType: dco_decode_opt_box_autoadd_i_32(arr[0]),
      scalabilityModes: dco_decode_list_scalability_mode(arr[1]),
      mimeType: dco_decode_String(arr[2]),
      name: dco_decode_String(arr[3]),
      kind: dco_decode_media_type(arr[4]),
      clockRate: dco_decode_opt_box_autoadd_i_32(arr[5]),
      numChannels: dco_decode_opt_box_autoadd_i_32(arr[6]),
      parameters: dco_decode_list_record_string_string(arr[7]),
      feedback: dco_decode_list_rtcp_feedback(arr[8]),
    );
  }

  @protected
  RtpHeaderExtensionCapability dco_decode_rtp_header_extension_capability(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return RtpHeaderExtensionCapability(
      uri: dco_decode_String(arr[0]),
      preferredId: dco_decode_opt_box_autoadd_i_32(arr[1]),
      preferredEncrypted: dco_decode_bool(arr[2]),
      direction: dco_decode_rtp_transceiver_direction(arr[3]),
    );
  }

  @protected
  RtpTransceiverDirection dco_decode_rtp_transceiver_direction(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return RtpTransceiverDirection.values[raw as int];
  }

  @protected
  RtpTransceiverInit dco_decode_rtp_transceiver_init(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return RtpTransceiverInit(
      direction: dco_decode_rtp_transceiver_direction(arr[0]),
      sendEncodings: dco_decode_list_rtc_rtp_encoding_parameters(arr[1]),
    );
  }

  @protected
  ScalabilityMode dco_decode_scalability_mode(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ScalabilityMode.values[raw as int];
  }

  @protected
  SdpType dco_decode_sdp_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SdpType.values[raw as int];
  }

  @protected
  SignalingState dco_decode_signaling_state(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SignalingState.values[raw as int];
  }

  @protected
  TextureEvent dco_decode_texture_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return TextureEvent_OnTextureChange(
          textureId: dco_decode_i_64(raw[1]),
          width: dco_decode_i_32(raw[2]),
          height: dco_decode_i_32(raw[3]),
          rotation: dco_decode_i_32(raw[4]),
        );
      case 1:
        return TextureEvent_OnFirstFrameRendered(
          textureId: dco_decode_i_64(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  TrackEvent dco_decode_track_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return TrackEvent_Ended();
      case 1:
        return TrackEvent_AudioLevelUpdated(
          dco_decode_u_32(raw[1]),
        );
      case 2:
        return TrackEvent_TrackCreated();
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  TrackState dco_decode_track_state(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return TrackState.values[raw as int];
  }

  @protected
  int dco_decode_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  BigInt dco_decode_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  BigInt dco_decode_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  VideoCodec dco_decode_video_codec(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return VideoCodec.values[raw as int];
  }

  @protected
  VideoCodecInfo dco_decode_video_codec_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return VideoCodecInfo(
      isHardwareAccelerated: dco_decode_bool(arr[0]),
      codec: dco_decode_video_codec(arr[1]),
    );
  }

  @protected
  VideoConstraints dco_decode_video_constraints(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return VideoConstraints(
      deviceId: dco_decode_opt_String(arr[0]),
      width: dco_decode_u_32(arr[1]),
      height: dco_decode_u_32(arr[2]),
      frameRate: dco_decode_u_32(arr[3]),
      isDisplay: dco_decode_bool(arr[4]),
    );
  }

  @protected
  AnyhowException sse_decode_AnyhowException(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_String(deserializer);
    return AnyhowException(inner);
  }

  @protected
  ArcPeerConnection sse_decode_RustOpaque_ArcPeerConnection(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ArcPeerConnectionImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ArcRtpEncodingParameters sse_decode_RustOpaque_ArcRtpEncodingParameters(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ArcRtpEncodingParametersImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ArcRtpParameters sse_decode_RustOpaque_ArcRtpParameters(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ArcRtpParametersImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ArcRtpTransceiver sse_decode_RustOpaque_ArcRtpTransceiver(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ArcRtpTransceiverImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  RustStreamSink<PeerConnectionEvent>
      sse_decode_StreamSink_peer_connection_event_Sse(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  RustStreamSink<TextureEvent> sse_decode_StreamSink_texture_event_Sse(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  RustStreamSink<TrackEvent> sse_decode_StreamSink_track_event_Sse(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  RustStreamSink<void> sse_decode_StreamSink_unit_Sse(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  AudioConstraints sse_decode_audio_constraints(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_deviceId = sse_decode_opt_String(deserializer);
    var var_autoGainControl = sse_decode_opt_box_autoadd_bool(deserializer);
    return AudioConstraints(
        deviceId: var_deviceId, autoGainControl: var_autoGainControl);
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  AudioConstraints sse_decode_box_autoadd_audio_constraints(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_audio_constraints(deserializer));
  }

  @protected
  bool sse_decode_box_autoadd_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_bool(deserializer));
  }

  @protected
  double sse_decode_box_autoadd_f_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_f_64(deserializer));
  }

  @protected
  GetMediaError sse_decode_box_autoadd_get_media_error(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_get_media_error(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_i_32(deserializer));
  }

  @protected
  IceCandidateStats sse_decode_box_autoadd_ice_candidate_stats(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ice_candidate_stats(deserializer));
  }

  @protected
  IceRole sse_decode_box_autoadd_ice_role(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ice_role(deserializer));
  }

  @protected
  MediaStreamConstraints sse_decode_box_autoadd_media_stream_constraints(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_media_stream_constraints(deserializer));
  }

  @protected
  Protocol sse_decode_box_autoadd_protocol(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_protocol(deserializer));
  }

  @protected
  RtcConfiguration sse_decode_box_autoadd_rtc_configuration(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_rtc_configuration(deserializer));
  }

  @protected
  RtcIceCandidateStats sse_decode_box_autoadd_rtc_ice_candidate_stats(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_rtc_ice_candidate_stats(deserializer));
  }

  @protected
  RtcInboundRtpStreamMediaType
      sse_decode_box_autoadd_rtc_inbound_rtp_stream_media_type(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_rtc_inbound_rtp_stream_media_type(deserializer));
  }

  @protected
  RtcMediaSourceStatsMediaType
      sse_decode_box_autoadd_rtc_media_source_stats_media_type(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_rtc_media_source_stats_media_type(deserializer));
  }

  @protected
  RtcOutboundRtpStreamStatsMediaType
      sse_decode_box_autoadd_rtc_outbound_rtp_stream_stats_media_type(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_rtc_outbound_rtp_stream_stats_media_type(deserializer));
  }

  @protected
  RtcRtpSendParameters sse_decode_box_autoadd_rtc_rtp_send_parameters(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_rtc_rtp_send_parameters(deserializer));
  }

  @protected
  RtcTrackEvent sse_decode_box_autoadd_rtc_track_event(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_rtc_track_event(deserializer));
  }

  @protected
  RtcpFeedbackMessageType sse_decode_box_autoadd_rtcp_feedback_message_type(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_rtcp_feedback_message_type(deserializer));
  }

  @protected
  RtpTransceiverInit sse_decode_box_autoadd_rtp_transceiver_init(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_rtp_transceiver_init(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_32(deserializer));
  }

  @protected
  BigInt sse_decode_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_64(deserializer));
  }

  @protected
  VideoConstraints sse_decode_box_autoadd_video_constraints(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_video_constraints(deserializer));
  }

  @protected
  BundlePolicy sse_decode_bundle_policy(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return BundlePolicy.values[inner];
  }

  @protected
  CandidateType sse_decode_candidate_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return CandidateType.values[inner];
  }

  @protected
  double sse_decode_f_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getFloat64();
  }

  @protected
  GetMediaError sse_decode_get_media_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_field0 = sse_decode_String(deserializer);
        return GetMediaError_Audio(var_field0);
      case 1:
        var var_field0 = sse_decode_String(deserializer);
        return GetMediaError_Video(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  GetMediaResult sse_decode_get_media_result(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_field0 = sse_decode_list_media_stream_track(deserializer);
        return GetMediaResult_Ok(var_field0);
      case 1:
        var var_field0 = sse_decode_box_autoadd_get_media_error(deserializer);
        return GetMediaResult_Err(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  PlatformInt64 sse_decode_i_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getPlatformInt64();
  }

  @protected
  IceCandidateStats sse_decode_ice_candidate_stats(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_transportId = sse_decode_opt_String(deserializer);
    var var_address = sse_decode_opt_String(deserializer);
    var var_port = sse_decode_opt_box_autoadd_i_32(deserializer);
    var var_protocol = sse_decode_protocol(deserializer);
    var var_candidateType = sse_decode_candidate_type(deserializer);
    var var_priority = sse_decode_opt_box_autoadd_i_32(deserializer);
    var var_url = sse_decode_opt_String(deserializer);
    var var_relayProtocol = sse_decode_opt_box_autoadd_protocol(deserializer);
    return IceCandidateStats(
        transportId: var_transportId,
        address: var_address,
        port: var_port,
        protocol: var_protocol,
        candidateType: var_candidateType,
        priority: var_priority,
        url: var_url,
        relayProtocol: var_relayProtocol);
  }

  @protected
  IceConnectionState sse_decode_ice_connection_state(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return IceConnectionState.values[inner];
  }

  @protected
  IceGatheringState sse_decode_ice_gathering_state(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return IceGatheringState.values[inner];
  }

  @protected
  IceRole sse_decode_ice_role(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return IceRole.values[inner];
  }

  @protected
  IceTransportsType sse_decode_ice_transports_type(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return IceTransportsType.values[inner];
  }

  @protected
  List<String> sse_decode_list_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <String>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_String(deserializer));
    }
    return ans_;
  }

  @protected
  List<MediaDeviceInfo> sse_decode_list_media_device_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <MediaDeviceInfo>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_media_device_info(deserializer));
    }
    return ans_;
  }

  @protected
  List<MediaDisplayInfo> sse_decode_list_media_display_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <MediaDisplayInfo>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_media_display_info(deserializer));
    }
    return ans_;
  }

  @protected
  List<MediaStreamTrack> sse_decode_list_media_stream_track(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <MediaStreamTrack>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_media_stream_track(deserializer));
    }
    return ans_;
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  List<(RtcRtpEncodingParameters, ArcRtpEncodingParameters)>
      sse_decode_list_record_rtc_rtp_encoding_parameters_rust_opaque_arc_rtp_encoding_parameters(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <(RtcRtpEncodingParameters, ArcRtpEncodingParameters)>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(
          sse_decode_record_rtc_rtp_encoding_parameters_rust_opaque_arc_rtp_encoding_parameters(
              deserializer));
    }
    return ans_;
  }

  @protected
  List<(String, String)> sse_decode_list_record_string_string(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <(String, String)>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_record_string_string(deserializer));
    }
    return ans_;
  }

  @protected
  List<RtcIceServer> sse_decode_list_rtc_ice_server(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <RtcIceServer>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_rtc_ice_server(deserializer));
    }
    return ans_;
  }

  @protected
  List<RtcRtpEncodingParameters> sse_decode_list_rtc_rtp_encoding_parameters(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <RtcRtpEncodingParameters>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_rtc_rtp_encoding_parameters(deserializer));
    }
    return ans_;
  }

  @protected
  List<RtcRtpTransceiver> sse_decode_list_rtc_rtp_transceiver(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <RtcRtpTransceiver>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_rtc_rtp_transceiver(deserializer));
    }
    return ans_;
  }

  @protected
  List<RtcStats> sse_decode_list_rtc_stats(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <RtcStats>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_rtc_stats(deserializer));
    }
    return ans_;
  }

  @protected
  List<RtcpFeedback> sse_decode_list_rtcp_feedback(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <RtcpFeedback>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_rtcp_feedback(deserializer));
    }
    return ans_;
  }

  @protected
  List<RtpCodecCapability> sse_decode_list_rtp_codec_capability(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <RtpCodecCapability>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_rtp_codec_capability(deserializer));
    }
    return ans_;
  }

  @protected
  List<RtpHeaderExtensionCapability>
      sse_decode_list_rtp_header_extension_capability(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <RtpHeaderExtensionCapability>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_rtp_header_extension_capability(deserializer));
    }
    return ans_;
  }

  @protected
  List<ScalabilityMode> sse_decode_list_scalability_mode(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ScalabilityMode>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_scalability_mode(deserializer));
    }
    return ans_;
  }

  @protected
  List<VideoCodecInfo> sse_decode_list_video_codec_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <VideoCodecInfo>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_video_codec_info(deserializer));
    }
    return ans_;
  }

  @protected
  MediaDeviceInfo sse_decode_media_device_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_deviceId = sse_decode_String(deserializer);
    var var_kind = sse_decode_media_device_kind(deserializer);
    var var_label = sse_decode_String(deserializer);
    return MediaDeviceInfo(
        deviceId: var_deviceId, kind: var_kind, label: var_label);
  }

  @protected
  MediaDeviceKind sse_decode_media_device_kind(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return MediaDeviceKind.values[inner];
  }

  @protected
  MediaDisplayInfo sse_decode_media_display_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_deviceId = sse_decode_String(deserializer);
    var var_title = sse_decode_opt_String(deserializer);
    return MediaDisplayInfo(deviceId: var_deviceId, title: var_title);
  }

  @protected
  MediaStreamConstraints sse_decode_media_stream_constraints(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_audio = sse_decode_opt_box_autoadd_audio_constraints(deserializer);
    var var_video = sse_decode_opt_box_autoadd_video_constraints(deserializer);
    return MediaStreamConstraints(audio: var_audio, video: var_video);
  }

  @protected
  MediaStreamTrack sse_decode_media_stream_track(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_peerId = sse_decode_opt_box_autoadd_u_32(deserializer);
    var var_deviceId = sse_decode_String(deserializer);
    var var_kind = sse_decode_media_type(deserializer);
    var var_enabled = sse_decode_bool(deserializer);
    return MediaStreamTrack(
        id: var_id,
        peerId: var_peerId,
        deviceId: var_deviceId,
        kind: var_kind,
        enabled: var_enabled);
  }

  @protected
  MediaType sse_decode_media_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return MediaType.values[inner];
  }

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  AudioConstraints? sse_decode_opt_box_autoadd_audio_constraints(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_audio_constraints(deserializer));
    } else {
      return null;
    }
  }

  @protected
  bool? sse_decode_opt_box_autoadd_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_bool(deserializer));
    } else {
      return null;
    }
  }

  @protected
  double? sse_decode_opt_box_autoadd_f_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_f_64(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_i_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  IceRole? sse_decode_opt_box_autoadd_ice_role(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_ice_role(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Protocol? sse_decode_opt_box_autoadd_protocol(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_protocol(deserializer));
    } else {
      return null;
    }
  }

  @protected
  RtcInboundRtpStreamMediaType?
      sse_decode_opt_box_autoadd_rtc_inbound_rtp_stream_media_type(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_rtc_inbound_rtp_stream_media_type(
          deserializer));
    } else {
      return null;
    }
  }

  @protected
  RtcpFeedbackMessageType?
      sse_decode_opt_box_autoadd_rtcp_feedback_message_type(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_rtcp_feedback_message_type(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  BigInt? sse_decode_opt_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_64(deserializer));
    } else {
      return null;
    }
  }

  @protected
  VideoConstraints? sse_decode_opt_box_autoadd_video_constraints(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_video_constraints(deserializer));
    } else {
      return null;
    }
  }

  @protected
  PeerConnectionEvent sse_decode_peer_connection_event(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_peer = sse_decode_RustOpaque_ArcPeerConnection(deserializer);
        return PeerConnectionEvent_PeerCreated(peer: var_peer);
      case 1:
        var var_sdpMid = sse_decode_String(deserializer);
        var var_sdpMlineIndex = sse_decode_i_32(deserializer);
        var var_candidate = sse_decode_String(deserializer);
        return PeerConnectionEvent_IceCandidate(
            sdpMid: var_sdpMid,
            sdpMlineIndex: var_sdpMlineIndex,
            candidate: var_candidate);
      case 2:
        var var_field0 = sse_decode_ice_gathering_state(deserializer);
        return PeerConnectionEvent_IceGatheringStateChange(var_field0);
      case 3:
        var var_address = sse_decode_String(deserializer);
        var var_port = sse_decode_i_32(deserializer);
        var var_url = sse_decode_String(deserializer);
        var var_errorCode = sse_decode_i_32(deserializer);
        var var_errorText = sse_decode_String(deserializer);
        return PeerConnectionEvent_IceCandidateError(
            address: var_address,
            port: var_port,
            url: var_url,
            errorCode: var_errorCode,
            errorText: var_errorText);
      case 4:
        return PeerConnectionEvent_NegotiationNeeded();
      case 5:
        var var_field0 = sse_decode_signaling_state(deserializer);
        return PeerConnectionEvent_SignallingChange(var_field0);
      case 6:
        var var_field0 = sse_decode_ice_connection_state(deserializer);
        return PeerConnectionEvent_IceConnectionStateChange(var_field0);
      case 7:
        var var_field0 = sse_decode_peer_connection_state(deserializer);
        return PeerConnectionEvent_ConnectionStateChange(var_field0);
      case 8:
        var var_field0 = sse_decode_box_autoadd_rtc_track_event(deserializer);
        return PeerConnectionEvent_Track(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  PeerConnectionState sse_decode_peer_connection_state(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return PeerConnectionState.values[inner];
  }

  @protected
  Protocol sse_decode_protocol(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return Protocol.values[inner];
  }

  @protected
  (
    RtcRtpEncodingParameters,
    ArcRtpEncodingParameters
  ) sse_decode_record_rtc_rtp_encoding_parameters_rust_opaque_arc_rtp_encoding_parameters(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_rtc_rtp_encoding_parameters(deserializer);
    var var_field1 =
        sse_decode_RustOpaque_ArcRtpEncodingParameters(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  (String, String) sse_decode_record_string_string(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_String(deserializer);
    var var_field1 = sse_decode_String(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  RtcConfiguration sse_decode_rtc_configuration(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_iceTransportPolicy = sse_decode_ice_transports_type(deserializer);
    var var_bundlePolicy = sse_decode_bundle_policy(deserializer);
    var var_iceServers = sse_decode_list_rtc_ice_server(deserializer);
    return RtcConfiguration(
        iceTransportPolicy: var_iceTransportPolicy,
        bundlePolicy: var_bundlePolicy,
        iceServers: var_iceServers);
  }

  @protected
  RtcIceCandidateStats sse_decode_rtc_ice_candidate_stats(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_field0 =
            sse_decode_box_autoadd_ice_candidate_stats(deserializer);
        return RtcIceCandidateStats_Local(var_field0);
      case 1:
        var var_field0 =
            sse_decode_box_autoadd_ice_candidate_stats(deserializer);
        return RtcIceCandidateStats_Remote(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  RtcIceServer sse_decode_rtc_ice_server(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_urls = sse_decode_list_String(deserializer);
    var var_username = sse_decode_String(deserializer);
    var var_credential = sse_decode_String(deserializer);
    return RtcIceServer(
        urls: var_urls, username: var_username, credential: var_credential);
  }

  @protected
  RtcInboundRtpStreamMediaType sse_decode_rtc_inbound_rtp_stream_media_type(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_voiceActivityFlag =
            sse_decode_opt_box_autoadd_bool(deserializer);
        var var_totalSamplesReceived =
            sse_decode_opt_box_autoadd_u_64(deserializer);
        var var_concealedSamples =
            sse_decode_opt_box_autoadd_u_64(deserializer);
        var var_silentConcealedSamples =
            sse_decode_opt_box_autoadd_u_64(deserializer);
        var var_audioLevel = sse_decode_opt_box_autoadd_f_64(deserializer);
        var var_totalAudioEnergy =
            sse_decode_opt_box_autoadd_f_64(deserializer);
        var var_totalSamplesDuration =
            sse_decode_opt_box_autoadd_f_64(deserializer);
        return RtcInboundRtpStreamMediaType_Audio(
            voiceActivityFlag: var_voiceActivityFlag,
            totalSamplesReceived: var_totalSamplesReceived,
            concealedSamples: var_concealedSamples,
            silentConcealedSamples: var_silentConcealedSamples,
            audioLevel: var_audioLevel,
            totalAudioEnergy: var_totalAudioEnergy,
            totalSamplesDuration: var_totalSamplesDuration);
      case 1:
        var var_framesDecoded = sse_decode_opt_box_autoadd_u_32(deserializer);
        var var_keyFramesDecoded =
            sse_decode_opt_box_autoadd_u_32(deserializer);
        var var_frameWidth = sse_decode_opt_box_autoadd_u_32(deserializer);
        var var_frameHeight = sse_decode_opt_box_autoadd_u_32(deserializer);
        var var_totalInterFrameDelay =
            sse_decode_opt_box_autoadd_f_64(deserializer);
        var var_framesPerSecond = sse_decode_opt_box_autoadd_f_64(deserializer);
        var var_firCount = sse_decode_opt_box_autoadd_u_32(deserializer);
        var var_pliCount = sse_decode_opt_box_autoadd_u_32(deserializer);
        var var_sliCount = sse_decode_opt_box_autoadd_u_32(deserializer);
        var var_concealmentEvents =
            sse_decode_opt_box_autoadd_u_64(deserializer);
        var var_framesReceived = sse_decode_opt_box_autoadd_i_32(deserializer);
        return RtcInboundRtpStreamMediaType_Video(
            framesDecoded: var_framesDecoded,
            keyFramesDecoded: var_keyFramesDecoded,
            frameWidth: var_frameWidth,
            frameHeight: var_frameHeight,
            totalInterFrameDelay: var_totalInterFrameDelay,
            framesPerSecond: var_framesPerSecond,
            firCount: var_firCount,
            pliCount: var_pliCount,
            sliCount: var_sliCount,
            concealmentEvents: var_concealmentEvents,
            framesReceived: var_framesReceived);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  RtcMediaSourceStatsMediaType sse_decode_rtc_media_source_stats_media_type(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_width = sse_decode_opt_box_autoadd_u_32(deserializer);
        var var_height = sse_decode_opt_box_autoadd_u_32(deserializer);
        var var_frames = sse_decode_opt_box_autoadd_u_32(deserializer);
        var var_framesPerSecond = sse_decode_opt_box_autoadd_f_64(deserializer);
        return RtcMediaSourceStatsMediaType_RtcVideoSourceStats(
            width: var_width,
            height: var_height,
            frames: var_frames,
            framesPerSecond: var_framesPerSecond);
      case 1:
        var var_audioLevel = sse_decode_opt_box_autoadd_f_64(deserializer);
        var var_totalAudioEnergy =
            sse_decode_opt_box_autoadd_f_64(deserializer);
        var var_totalSamplesDuration =
            sse_decode_opt_box_autoadd_f_64(deserializer);
        var var_echoReturnLoss = sse_decode_opt_box_autoadd_f_64(deserializer);
        var var_echoReturnLossEnhancement =
            sse_decode_opt_box_autoadd_f_64(deserializer);
        return RtcMediaSourceStatsMediaType_RtcAudioSourceStats(
            audioLevel: var_audioLevel,
            totalAudioEnergy: var_totalAudioEnergy,
            totalSamplesDuration: var_totalSamplesDuration,
            echoReturnLoss: var_echoReturnLoss,
            echoReturnLossEnhancement: var_echoReturnLossEnhancement);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  RtcOutboundRtpStreamStatsMediaType
      sse_decode_rtc_outbound_rtp_stream_stats_media_type(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_totalSamplesSent =
            sse_decode_opt_box_autoadd_u_64(deserializer);
        var var_voiceActivityFlag =
            sse_decode_opt_box_autoadd_bool(deserializer);
        return RtcOutboundRtpStreamStatsMediaType_Audio(
            totalSamplesSent: var_totalSamplesSent,
            voiceActivityFlag: var_voiceActivityFlag);
      case 1:
        var var_frameWidth = sse_decode_opt_box_autoadd_u_32(deserializer);
        var var_frameHeight = sse_decode_opt_box_autoadd_u_32(deserializer);
        var var_framesPerSecond = sse_decode_opt_box_autoadd_f_64(deserializer);
        return RtcOutboundRtpStreamStatsMediaType_Video(
            frameWidth: var_frameWidth,
            frameHeight: var_frameHeight,
            framesPerSecond: var_framesPerSecond);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  RtcRtpEncodingParameters sse_decode_rtc_rtp_encoding_parameters(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_rid = sse_decode_String(deserializer);
    var var_active = sse_decode_bool(deserializer);
    var var_maxBitrate = sse_decode_opt_box_autoadd_i_32(deserializer);
    var var_maxFramerate = sse_decode_opt_box_autoadd_f_64(deserializer);
    var var_scaleResolutionDownBy =
        sse_decode_opt_box_autoadd_f_64(deserializer);
    var var_scalabilityMode = sse_decode_opt_String(deserializer);
    return RtcRtpEncodingParameters(
        rid: var_rid,
        active: var_active,
        maxBitrate: var_maxBitrate,
        maxFramerate: var_maxFramerate,
        scaleResolutionDownBy: var_scaleResolutionDownBy,
        scalabilityMode: var_scalabilityMode);
  }

  @protected
  RtcRtpSendParameters sse_decode_rtc_rtp_send_parameters(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_encodings =
        sse_decode_list_record_rtc_rtp_encoding_parameters_rust_opaque_arc_rtp_encoding_parameters(
            deserializer);
    var var_inner = sse_decode_RustOpaque_ArcRtpParameters(deserializer);
    return RtcRtpSendParameters(encodings: var_encodings, inner: var_inner);
  }

  @protected
  RtcRtpTransceiver sse_decode_rtc_rtp_transceiver(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_peer = sse_decode_RustOpaque_ArcPeerConnection(deserializer);
    var var_transceiver = sse_decode_RustOpaque_ArcRtpTransceiver(deserializer);
    var var_mid = sse_decode_opt_String(deserializer);
    var var_direction = sse_decode_rtp_transceiver_direction(deserializer);
    return RtcRtpTransceiver(
        peer: var_peer,
        transceiver: var_transceiver,
        mid: var_mid,
        direction: var_direction);
  }

  @protected
  RtcSessionDescription sse_decode_rtc_session_description(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_sdp = sse_decode_String(deserializer);
    var var_kind = sse_decode_sdp_type(deserializer);
    return RtcSessionDescription(sdp: var_sdp, kind: var_kind);
  }

  @protected
  RtcStats sse_decode_rtc_stats(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_timestampUs = sse_decode_i_64(deserializer);
    var var_kind = sse_decode_rtc_stats_type(deserializer);
    return RtcStats(id: var_id, timestampUs: var_timestampUs, kind: var_kind);
  }

  @protected
  RtcStatsIceCandidatePairState sse_decode_rtc_stats_ice_candidate_pair_state(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return RtcStatsIceCandidatePairState.values[inner];
  }

  @protected
  RtcStatsType sse_decode_rtc_stats_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_trackIdentifier = sse_decode_opt_String(deserializer);
        var var_kind = sse_decode_box_autoadd_rtc_media_source_stats_media_type(
            deserializer);
        return RtcStatsType_RtcMediaSourceStats(
            trackIdentifier: var_trackIdentifier, kind: var_kind);
      case 1:
        var var_field0 =
            sse_decode_box_autoadd_rtc_ice_candidate_stats(deserializer);
        return RtcStatsType_RtcIceCandidateStats(var_field0);
      case 2:
        var var_trackId = sse_decode_opt_String(deserializer);
        var var_mediaType =
            sse_decode_box_autoadd_rtc_outbound_rtp_stream_stats_media_type(
                deserializer);
        var var_bytesSent = sse_decode_opt_box_autoadd_u_64(deserializer);
        var var_packetsSent = sse_decode_opt_box_autoadd_u_32(deserializer);
        var var_mediaSourceId = sse_decode_opt_String(deserializer);
        return RtcStatsType_RtcOutboundRtpStreamStats(
            trackId: var_trackId,
            mediaType: var_mediaType,
            bytesSent: var_bytesSent,
            packetsSent: var_packetsSent,
            mediaSourceId: var_mediaSourceId);
      case 3:
        var var_remoteId = sse_decode_opt_String(deserializer);
        var var_bytesReceived = sse_decode_opt_box_autoadd_u_64(deserializer);
        var var_packetsReceived = sse_decode_opt_box_autoadd_u_32(deserializer);
        var var_packetsLost = sse_decode_opt_box_autoadd_u_64(deserializer);
        var var_jitter = sse_decode_opt_box_autoadd_f_64(deserializer);
        var var_totalDecodeTime = sse_decode_opt_box_autoadd_f_64(deserializer);
        var var_jitterBufferEmittedCount =
            sse_decode_opt_box_autoadd_u_64(deserializer);
        var var_mediaType =
            sse_decode_opt_box_autoadd_rtc_inbound_rtp_stream_media_type(
                deserializer);
        return RtcStatsType_RtcInboundRtpStreamStats(
            remoteId: var_remoteId,
            bytesReceived: var_bytesReceived,
            packetsReceived: var_packetsReceived,
            packetsLost: var_packetsLost,
            jitter: var_jitter,
            totalDecodeTime: var_totalDecodeTime,
            jitterBufferEmittedCount: var_jitterBufferEmittedCount,
            mediaType: var_mediaType);
      case 4:
        var var_state =
            sse_decode_rtc_stats_ice_candidate_pair_state(deserializer);
        var var_nominated = sse_decode_opt_box_autoadd_bool(deserializer);
        var var_bytesSent = sse_decode_opt_box_autoadd_u_64(deserializer);
        var var_bytesReceived = sse_decode_opt_box_autoadd_u_64(deserializer);
        var var_totalRoundTripTime =
            sse_decode_opt_box_autoadd_f_64(deserializer);
        var var_currentRoundTripTime =
            sse_decode_opt_box_autoadd_f_64(deserializer);
        var var_availableOutgoingBitrate =
            sse_decode_opt_box_autoadd_f_64(deserializer);
        return RtcStatsType_RtcIceCandidatePairStats(
            state: var_state,
            nominated: var_nominated,
            bytesSent: var_bytesSent,
            bytesReceived: var_bytesReceived,
            totalRoundTripTime: var_totalRoundTripTime,
            currentRoundTripTime: var_currentRoundTripTime,
            availableOutgoingBitrate: var_availableOutgoingBitrate);
      case 5:
        var var_packetsSent = sse_decode_opt_box_autoadd_u_64(deserializer);
        var var_packetsReceived = sse_decode_opt_box_autoadd_u_64(deserializer);
        var var_bytesSent = sse_decode_opt_box_autoadd_u_64(deserializer);
        var var_bytesReceived = sse_decode_opt_box_autoadd_u_64(deserializer);
        var var_iceRole = sse_decode_opt_box_autoadd_ice_role(deserializer);
        return RtcStatsType_RtcTransportStats(
            packetsSent: var_packetsSent,
            packetsReceived: var_packetsReceived,
            bytesSent: var_bytesSent,
            bytesReceived: var_bytesReceived,
            iceRole: var_iceRole);
      case 6:
        var var_localId = sse_decode_opt_String(deserializer);
        var var_jitter = sse_decode_opt_box_autoadd_f_64(deserializer);
        var var_roundTripTime = sse_decode_opt_box_autoadd_f_64(deserializer);
        var var_fractionLost = sse_decode_opt_box_autoadd_f_64(deserializer);
        var var_reportsReceived = sse_decode_opt_box_autoadd_u_64(deserializer);
        var var_roundTripTimeMeasurements =
            sse_decode_opt_box_autoadd_i_32(deserializer);
        return RtcStatsType_RtcRemoteInboundRtpStreamStats(
            localId: var_localId,
            jitter: var_jitter,
            roundTripTime: var_roundTripTime,
            fractionLost: var_fractionLost,
            reportsReceived: var_reportsReceived,
            roundTripTimeMeasurements: var_roundTripTimeMeasurements);
      case 7:
        var var_localId = sse_decode_opt_String(deserializer);
        var var_remoteTimestamp = sse_decode_opt_box_autoadd_f_64(deserializer);
        var var_reportsSent = sse_decode_opt_box_autoadd_u_64(deserializer);
        return RtcStatsType_RtcRemoteOutboundRtpStreamStats(
            localId: var_localId,
            remoteTimestamp: var_remoteTimestamp,
            reportsSent: var_reportsSent);
      case 8:
        return RtcStatsType_Unimplemented();
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  RtcTrackEvent sse_decode_rtc_track_event(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_track = sse_decode_media_stream_track(deserializer);
    var var_transceiver = sse_decode_rtc_rtp_transceiver(deserializer);
    return RtcTrackEvent(track: var_track, transceiver: var_transceiver);
  }

  @protected
  RtcpFeedback sse_decode_rtcp_feedback(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_messageType =
        sse_decode_opt_box_autoadd_rtcp_feedback_message_type(deserializer);
    var var_kind = sse_decode_rtcp_feedback_type(deserializer);
    return RtcpFeedback(messageType: var_messageType, kind: var_kind);
  }

  @protected
  RtcpFeedbackMessageType sse_decode_rtcp_feedback_message_type(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return RtcpFeedbackMessageType.values[inner];
  }

  @protected
  RtcpFeedbackType sse_decode_rtcp_feedback_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return RtcpFeedbackType.values[inner];
  }

  @protected
  RtpCapabilities sse_decode_rtp_capabilities(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_codecs = sse_decode_list_rtp_codec_capability(deserializer);
    var var_headerExtensions =
        sse_decode_list_rtp_header_extension_capability(deserializer);
    return RtpCapabilities(
        codecs: var_codecs, headerExtensions: var_headerExtensions);
  }

  @protected
  RtpCodecCapability sse_decode_rtp_codec_capability(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_preferredPayloadType =
        sse_decode_opt_box_autoadd_i_32(deserializer);
    var var_scalabilityModes = sse_decode_list_scalability_mode(deserializer);
    var var_mimeType = sse_decode_String(deserializer);
    var var_name = sse_decode_String(deserializer);
    var var_kind = sse_decode_media_type(deserializer);
    var var_clockRate = sse_decode_opt_box_autoadd_i_32(deserializer);
    var var_numChannels = sse_decode_opt_box_autoadd_i_32(deserializer);
    var var_parameters = sse_decode_list_record_string_string(deserializer);
    var var_feedback = sse_decode_list_rtcp_feedback(deserializer);
    return RtpCodecCapability(
        preferredPayloadType: var_preferredPayloadType,
        scalabilityModes: var_scalabilityModes,
        mimeType: var_mimeType,
        name: var_name,
        kind: var_kind,
        clockRate: var_clockRate,
        numChannels: var_numChannels,
        parameters: var_parameters,
        feedback: var_feedback);
  }

  @protected
  RtpHeaderExtensionCapability sse_decode_rtp_header_extension_capability(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_uri = sse_decode_String(deserializer);
    var var_preferredId = sse_decode_opt_box_autoadd_i_32(deserializer);
    var var_preferredEncrypted = sse_decode_bool(deserializer);
    var var_direction = sse_decode_rtp_transceiver_direction(deserializer);
    return RtpHeaderExtensionCapability(
        uri: var_uri,
        preferredId: var_preferredId,
        preferredEncrypted: var_preferredEncrypted,
        direction: var_direction);
  }

  @protected
  RtpTransceiverDirection sse_decode_rtp_transceiver_direction(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return RtpTransceiverDirection.values[inner];
  }

  @protected
  RtpTransceiverInit sse_decode_rtp_transceiver_init(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_direction = sse_decode_rtp_transceiver_direction(deserializer);
    var var_sendEncodings =
        sse_decode_list_rtc_rtp_encoding_parameters(deserializer);
    return RtpTransceiverInit(
        direction: var_direction, sendEncodings: var_sendEncodings);
  }

  @protected
  ScalabilityMode sse_decode_scalability_mode(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return ScalabilityMode.values[inner];
  }

  @protected
  SdpType sse_decode_sdp_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return SdpType.values[inner];
  }

  @protected
  SignalingState sse_decode_signaling_state(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return SignalingState.values[inner];
  }

  @protected
  TextureEvent sse_decode_texture_event(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_textureId = sse_decode_i_64(deserializer);
        var var_width = sse_decode_i_32(deserializer);
        var var_height = sse_decode_i_32(deserializer);
        var var_rotation = sse_decode_i_32(deserializer);
        return TextureEvent_OnTextureChange(
            textureId: var_textureId,
            width: var_width,
            height: var_height,
            rotation: var_rotation);
      case 1:
        var var_textureId = sse_decode_i_64(deserializer);
        return TextureEvent_OnFirstFrameRendered(textureId: var_textureId);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  TrackEvent sse_decode_track_event(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return TrackEvent_Ended();
      case 1:
        var var_field0 = sse_decode_u_32(deserializer);
        return TrackEvent_AudioLevelUpdated(var_field0);
      case 2:
        return TrackEvent_TrackCreated();
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  TrackState sse_decode_track_state(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return TrackState.values[inner];
  }

  @protected
  int sse_decode_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint32();
  }

  @protected
  BigInt sse_decode_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  BigInt sse_decode_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  VideoCodec sse_decode_video_codec(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return VideoCodec.values[inner];
  }

  @protected
  VideoCodecInfo sse_decode_video_codec_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_isHardwareAccelerated = sse_decode_bool(deserializer);
    var var_codec = sse_decode_video_codec(deserializer);
    return VideoCodecInfo(
        isHardwareAccelerated: var_isHardwareAccelerated, codec: var_codec);
  }

  @protected
  VideoConstraints sse_decode_video_constraints(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_deviceId = sse_decode_opt_String(deserializer);
    var var_width = sse_decode_u_32(deserializer);
    var var_height = sse_decode_u_32(deserializer);
    var var_frameRate = sse_decode_u_32(deserializer);
    var var_isDisplay = sse_decode_bool(deserializer);
    return VideoConstraints(
        deviceId: var_deviceId,
        width: var_width,
        height: var_height,
        frameRate: var_frameRate,
        isDisplay: var_isDisplay);
  }

  @protected
  void sse_encode_AnyhowException(
      AnyhowException self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.message, serializer);
  }

  @protected
  void sse_encode_RustOpaque_ArcPeerConnection(
      ArcPeerConnection self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ArcPeerConnectionImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void sse_encode_RustOpaque_ArcRtpEncodingParameters(
      ArcRtpEncodingParameters self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ArcRtpEncodingParametersImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void sse_encode_RustOpaque_ArcRtpParameters(
      ArcRtpParameters self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ArcRtpParametersImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void sse_encode_RustOpaque_ArcRtpTransceiver(
      ArcRtpTransceiver self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ArcRtpTransceiverImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void sse_encode_StreamSink_peer_connection_event_Sse(
      RustStreamSink<PeerConnectionEvent> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
        self.setupAndSerialize(
            codec: SseCodec(
          decodeSuccessData: sse_decode_peer_connection_event,
          decodeErrorData: sse_decode_AnyhowException,
        )),
        serializer);
  }

  @protected
  void sse_encode_StreamSink_texture_event_Sse(
      RustStreamSink<TextureEvent> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
        self.setupAndSerialize(
            codec: SseCodec(
          decodeSuccessData: sse_decode_texture_event,
          decodeErrorData: sse_decode_AnyhowException,
        )),
        serializer);
  }

  @protected
  void sse_encode_StreamSink_track_event_Sse(
      RustStreamSink<TrackEvent> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
        self.setupAndSerialize(
            codec: SseCodec(
          decodeSuccessData: sse_decode_track_event,
          decodeErrorData: sse_decode_AnyhowException,
        )),
        serializer);
  }

  @protected
  void sse_encode_StreamSink_unit_Sse(
      RustStreamSink<void> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
        self.setupAndSerialize(
            codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        )),
        serializer);
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_audio_constraints(
      AudioConstraints self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_String(self.deviceId, serializer);
    sse_encode_opt_box_autoadd_bool(self.autoGainControl, serializer);
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void sse_encode_box_autoadd_audio_constraints(
      AudioConstraints self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_audio_constraints(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_f_64(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_f_64(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_get_media_error(
      GetMediaError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_get_media_error(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ice_candidate_stats(
      IceCandidateStats self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ice_candidate_stats(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ice_role(IceRole self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ice_role(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_media_stream_constraints(
      MediaStreamConstraints self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_media_stream_constraints(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_protocol(
      Protocol self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_protocol(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_rtc_configuration(
      RtcConfiguration self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_rtc_configuration(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_rtc_ice_candidate_stats(
      RtcIceCandidateStats self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_rtc_ice_candidate_stats(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_rtc_inbound_rtp_stream_media_type(
      RtcInboundRtpStreamMediaType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_rtc_inbound_rtp_stream_media_type(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_rtc_media_source_stats_media_type(
      RtcMediaSourceStatsMediaType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_rtc_media_source_stats_media_type(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_rtc_outbound_rtp_stream_stats_media_type(
      RtcOutboundRtpStreamStatsMediaType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_rtc_outbound_rtp_stream_stats_media_type(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_rtc_rtp_send_parameters(
      RtcRtpSendParameters self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_rtc_rtp_send_parameters(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_rtc_track_event(
      RtcTrackEvent self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_rtc_track_event(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_rtcp_feedback_message_type(
      RtcpFeedbackMessageType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_rtcp_feedback_message_type(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_rtp_transceiver_init(
      RtpTransceiverInit self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_rtp_transceiver_init(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_video_constraints(
      VideoConstraints self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_video_constraints(self, serializer);
  }

  @protected
  void sse_encode_bundle_policy(BundlePolicy self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_candidate_type(CandidateType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_f_64(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putFloat64(self);
  }

  @protected
  void sse_encode_get_media_error(
      GetMediaError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case GetMediaError_Audio(field0: final field0):
        sse_encode_i_32(0, serializer);
        sse_encode_String(field0, serializer);
      case GetMediaError_Video(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_String(field0, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_get_media_result(
      GetMediaResult self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case GetMediaResult_Ok(field0: final field0):
        sse_encode_i_32(0, serializer);
        sse_encode_list_media_stream_track(field0, serializer);
      case GetMediaResult_Err(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_get_media_error(field0, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_i_64(PlatformInt64 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putPlatformInt64(self);
  }

  @protected
  void sse_encode_ice_candidate_stats(
      IceCandidateStats self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_String(self.transportId, serializer);
    sse_encode_opt_String(self.address, serializer);
    sse_encode_opt_box_autoadd_i_32(self.port, serializer);
    sse_encode_protocol(self.protocol, serializer);
    sse_encode_candidate_type(self.candidateType, serializer);
    sse_encode_opt_box_autoadd_i_32(self.priority, serializer);
    sse_encode_opt_String(self.url, serializer);
    sse_encode_opt_box_autoadd_protocol(self.relayProtocol, serializer);
  }

  @protected
  void sse_encode_ice_connection_state(
      IceConnectionState self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_ice_gathering_state(
      IceGatheringState self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_ice_role(IceRole self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_ice_transports_type(
      IceTransportsType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_list_String(List<String> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_String(item, serializer);
    }
  }

  @protected
  void sse_encode_list_media_device_info(
      List<MediaDeviceInfo> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_media_device_info(item, serializer);
    }
  }

  @protected
  void sse_encode_list_media_display_info(
      List<MediaDisplayInfo> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_media_display_info(item, serializer);
    }
  }

  @protected
  void sse_encode_list_media_stream_track(
      List<MediaStreamTrack> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_media_stream_track(item, serializer);
    }
  }

  @protected
  void sse_encode_list_prim_u_8_strict(
      Uint8List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void
      sse_encode_list_record_rtc_rtp_encoding_parameters_rust_opaque_arc_rtp_encoding_parameters(
          List<(RtcRtpEncodingParameters, ArcRtpEncodingParameters)> self,
          SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_record_rtc_rtp_encoding_parameters_rust_opaque_arc_rtp_encoding_parameters(
          item, serializer);
    }
  }

  @protected
  void sse_encode_list_record_string_string(
      List<(String, String)> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_record_string_string(item, serializer);
    }
  }

  @protected
  void sse_encode_list_rtc_ice_server(
      List<RtcIceServer> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_rtc_ice_server(item, serializer);
    }
  }

  @protected
  void sse_encode_list_rtc_rtp_encoding_parameters(
      List<RtcRtpEncodingParameters> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_rtc_rtp_encoding_parameters(item, serializer);
    }
  }

  @protected
  void sse_encode_list_rtc_rtp_transceiver(
      List<RtcRtpTransceiver> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_rtc_rtp_transceiver(item, serializer);
    }
  }

  @protected
  void sse_encode_list_rtc_stats(
      List<RtcStats> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_rtc_stats(item, serializer);
    }
  }

  @protected
  void sse_encode_list_rtcp_feedback(
      List<RtcpFeedback> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_rtcp_feedback(item, serializer);
    }
  }

  @protected
  void sse_encode_list_rtp_codec_capability(
      List<RtpCodecCapability> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_rtp_codec_capability(item, serializer);
    }
  }

  @protected
  void sse_encode_list_rtp_header_extension_capability(
      List<RtpHeaderExtensionCapability> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_rtp_header_extension_capability(item, serializer);
    }
  }

  @protected
  void sse_encode_list_scalability_mode(
      List<ScalabilityMode> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_scalability_mode(item, serializer);
    }
  }

  @protected
  void sse_encode_list_video_codec_info(
      List<VideoCodecInfo> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_video_codec_info(item, serializer);
    }
  }

  @protected
  void sse_encode_media_device_info(
      MediaDeviceInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.deviceId, serializer);
    sse_encode_media_device_kind(self.kind, serializer);
    sse_encode_String(self.label, serializer);
  }

  @protected
  void sse_encode_media_device_kind(
      MediaDeviceKind self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_media_display_info(
      MediaDisplayInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.deviceId, serializer);
    sse_encode_opt_String(self.title, serializer);
  }

  @protected
  void sse_encode_media_stream_constraints(
      MediaStreamConstraints self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_box_autoadd_audio_constraints(self.audio, serializer);
    sse_encode_opt_box_autoadd_video_constraints(self.video, serializer);
  }

  @protected
  void sse_encode_media_stream_track(
      MediaStreamTrack self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_opt_box_autoadd_u_32(self.peerId, serializer);
    sse_encode_String(self.deviceId, serializer);
    sse_encode_media_type(self.kind, serializer);
    sse_encode_bool(self.enabled, serializer);
  }

  @protected
  void sse_encode_media_type(MediaType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_audio_constraints(
      AudioConstraints? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_audio_constraints(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_bool(bool? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_bool(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_f_64(double? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_f_64(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_i_32(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_i_32(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_ice_role(
      IceRole? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_ice_role(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_protocol(
      Protocol? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_protocol(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_rtc_inbound_rtp_stream_media_type(
      RtcInboundRtpStreamMediaType? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_rtc_inbound_rtp_stream_media_type(
          self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_rtcp_feedback_message_type(
      RtcpFeedbackMessageType? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_rtcp_feedback_message_type(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_32(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_32(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_64(BigInt? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_64(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_video_constraints(
      VideoConstraints? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_video_constraints(self, serializer);
    }
  }

  @protected
  void sse_encode_peer_connection_event(
      PeerConnectionEvent self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case PeerConnectionEvent_PeerCreated(peer: final peer):
        sse_encode_i_32(0, serializer);
        sse_encode_RustOpaque_ArcPeerConnection(peer, serializer);
      case PeerConnectionEvent_IceCandidate(
          sdpMid: final sdpMid,
          sdpMlineIndex: final sdpMlineIndex,
          candidate: final candidate
        ):
        sse_encode_i_32(1, serializer);
        sse_encode_String(sdpMid, serializer);
        sse_encode_i_32(sdpMlineIndex, serializer);
        sse_encode_String(candidate, serializer);
      case PeerConnectionEvent_IceGatheringStateChange(field0: final field0):
        sse_encode_i_32(2, serializer);
        sse_encode_ice_gathering_state(field0, serializer);
      case PeerConnectionEvent_IceCandidateError(
          address: final address,
          port: final port,
          url: final url,
          errorCode: final errorCode,
          errorText: final errorText
        ):
        sse_encode_i_32(3, serializer);
        sse_encode_String(address, serializer);
        sse_encode_i_32(port, serializer);
        sse_encode_String(url, serializer);
        sse_encode_i_32(errorCode, serializer);
        sse_encode_String(errorText, serializer);
      case PeerConnectionEvent_NegotiationNeeded():
        sse_encode_i_32(4, serializer);
      case PeerConnectionEvent_SignallingChange(field0: final field0):
        sse_encode_i_32(5, serializer);
        sse_encode_signaling_state(field0, serializer);
      case PeerConnectionEvent_IceConnectionStateChange(field0: final field0):
        sse_encode_i_32(6, serializer);
        sse_encode_ice_connection_state(field0, serializer);
      case PeerConnectionEvent_ConnectionStateChange(field0: final field0):
        sse_encode_i_32(7, serializer);
        sse_encode_peer_connection_state(field0, serializer);
      case PeerConnectionEvent_Track(field0: final field0):
        sse_encode_i_32(8, serializer);
        sse_encode_box_autoadd_rtc_track_event(field0, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_peer_connection_state(
      PeerConnectionState self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_protocol(Protocol self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void
      sse_encode_record_rtc_rtp_encoding_parameters_rust_opaque_arc_rtp_encoding_parameters(
          (RtcRtpEncodingParameters, ArcRtpEncodingParameters) self,
          SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_rtc_rtp_encoding_parameters(self.$1, serializer);
    sse_encode_RustOpaque_ArcRtpEncodingParameters(self.$2, serializer);
  }

  @protected
  void sse_encode_record_string_string(
      (String, String) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.$1, serializer);
    sse_encode_String(self.$2, serializer);
  }

  @protected
  void sse_encode_rtc_configuration(
      RtcConfiguration self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ice_transports_type(self.iceTransportPolicy, serializer);
    sse_encode_bundle_policy(self.bundlePolicy, serializer);
    sse_encode_list_rtc_ice_server(self.iceServers, serializer);
  }

  @protected
  void sse_encode_rtc_ice_candidate_stats(
      RtcIceCandidateStats self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case RtcIceCandidateStats_Local(field0: final field0):
        sse_encode_i_32(0, serializer);
        sse_encode_box_autoadd_ice_candidate_stats(field0, serializer);
      case RtcIceCandidateStats_Remote(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_ice_candidate_stats(field0, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_rtc_ice_server(RtcIceServer self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_String(self.urls, serializer);
    sse_encode_String(self.username, serializer);
    sse_encode_String(self.credential, serializer);
  }

  @protected
  void sse_encode_rtc_inbound_rtp_stream_media_type(
      RtcInboundRtpStreamMediaType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case RtcInboundRtpStreamMediaType_Audio(
          voiceActivityFlag: final voiceActivityFlag,
          totalSamplesReceived: final totalSamplesReceived,
          concealedSamples: final concealedSamples,
          silentConcealedSamples: final silentConcealedSamples,
          audioLevel: final audioLevel,
          totalAudioEnergy: final totalAudioEnergy,
          totalSamplesDuration: final totalSamplesDuration
        ):
        sse_encode_i_32(0, serializer);
        sse_encode_opt_box_autoadd_bool(voiceActivityFlag, serializer);
        sse_encode_opt_box_autoadd_u_64(totalSamplesReceived, serializer);
        sse_encode_opt_box_autoadd_u_64(concealedSamples, serializer);
        sse_encode_opt_box_autoadd_u_64(silentConcealedSamples, serializer);
        sse_encode_opt_box_autoadd_f_64(audioLevel, serializer);
        sse_encode_opt_box_autoadd_f_64(totalAudioEnergy, serializer);
        sse_encode_opt_box_autoadd_f_64(totalSamplesDuration, serializer);
      case RtcInboundRtpStreamMediaType_Video(
          framesDecoded: final framesDecoded,
          keyFramesDecoded: final keyFramesDecoded,
          frameWidth: final frameWidth,
          frameHeight: final frameHeight,
          totalInterFrameDelay: final totalInterFrameDelay,
          framesPerSecond: final framesPerSecond,
          firCount: final firCount,
          pliCount: final pliCount,
          sliCount: final sliCount,
          concealmentEvents: final concealmentEvents,
          framesReceived: final framesReceived
        ):
        sse_encode_i_32(1, serializer);
        sse_encode_opt_box_autoadd_u_32(framesDecoded, serializer);
        sse_encode_opt_box_autoadd_u_32(keyFramesDecoded, serializer);
        sse_encode_opt_box_autoadd_u_32(frameWidth, serializer);
        sse_encode_opt_box_autoadd_u_32(frameHeight, serializer);
        sse_encode_opt_box_autoadd_f_64(totalInterFrameDelay, serializer);
        sse_encode_opt_box_autoadd_f_64(framesPerSecond, serializer);
        sse_encode_opt_box_autoadd_u_32(firCount, serializer);
        sse_encode_opt_box_autoadd_u_32(pliCount, serializer);
        sse_encode_opt_box_autoadd_u_32(sliCount, serializer);
        sse_encode_opt_box_autoadd_u_64(concealmentEvents, serializer);
        sse_encode_opt_box_autoadd_i_32(framesReceived, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_rtc_media_source_stats_media_type(
      RtcMediaSourceStatsMediaType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case RtcMediaSourceStatsMediaType_RtcVideoSourceStats(
          width: final width,
          height: final height,
          frames: final frames,
          framesPerSecond: final framesPerSecond
        ):
        sse_encode_i_32(0, serializer);
        sse_encode_opt_box_autoadd_u_32(width, serializer);
        sse_encode_opt_box_autoadd_u_32(height, serializer);
        sse_encode_opt_box_autoadd_u_32(frames, serializer);
        sse_encode_opt_box_autoadd_f_64(framesPerSecond, serializer);
      case RtcMediaSourceStatsMediaType_RtcAudioSourceStats(
          audioLevel: final audioLevel,
          totalAudioEnergy: final totalAudioEnergy,
          totalSamplesDuration: final totalSamplesDuration,
          echoReturnLoss: final echoReturnLoss,
          echoReturnLossEnhancement: final echoReturnLossEnhancement
        ):
        sse_encode_i_32(1, serializer);
        sse_encode_opt_box_autoadd_f_64(audioLevel, serializer);
        sse_encode_opt_box_autoadd_f_64(totalAudioEnergy, serializer);
        sse_encode_opt_box_autoadd_f_64(totalSamplesDuration, serializer);
        sse_encode_opt_box_autoadd_f_64(echoReturnLoss, serializer);
        sse_encode_opt_box_autoadd_f_64(echoReturnLossEnhancement, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_rtc_outbound_rtp_stream_stats_media_type(
      RtcOutboundRtpStreamStatsMediaType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case RtcOutboundRtpStreamStatsMediaType_Audio(
          totalSamplesSent: final totalSamplesSent,
          voiceActivityFlag: final voiceActivityFlag
        ):
        sse_encode_i_32(0, serializer);
        sse_encode_opt_box_autoadd_u_64(totalSamplesSent, serializer);
        sse_encode_opt_box_autoadd_bool(voiceActivityFlag, serializer);
      case RtcOutboundRtpStreamStatsMediaType_Video(
          frameWidth: final frameWidth,
          frameHeight: final frameHeight,
          framesPerSecond: final framesPerSecond
        ):
        sse_encode_i_32(1, serializer);
        sse_encode_opt_box_autoadd_u_32(frameWidth, serializer);
        sse_encode_opt_box_autoadd_u_32(frameHeight, serializer);
        sse_encode_opt_box_autoadd_f_64(framesPerSecond, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_rtc_rtp_encoding_parameters(
      RtcRtpEncodingParameters self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.rid, serializer);
    sse_encode_bool(self.active, serializer);
    sse_encode_opt_box_autoadd_i_32(self.maxBitrate, serializer);
    sse_encode_opt_box_autoadd_f_64(self.maxFramerate, serializer);
    sse_encode_opt_box_autoadd_f_64(self.scaleResolutionDownBy, serializer);
    sse_encode_opt_String(self.scalabilityMode, serializer);
  }

  @protected
  void sse_encode_rtc_rtp_send_parameters(
      RtcRtpSendParameters self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_record_rtc_rtp_encoding_parameters_rust_opaque_arc_rtp_encoding_parameters(
        self.encodings, serializer);
    sse_encode_RustOpaque_ArcRtpParameters(self.inner, serializer);
  }

  @protected
  void sse_encode_rtc_rtp_transceiver(
      RtcRtpTransceiver self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_RustOpaque_ArcPeerConnection(self.peer, serializer);
    sse_encode_RustOpaque_ArcRtpTransceiver(self.transceiver, serializer);
    sse_encode_opt_String(self.mid, serializer);
    sse_encode_rtp_transceiver_direction(self.direction, serializer);
  }

  @protected
  void sse_encode_rtc_session_description(
      RtcSessionDescription self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.sdp, serializer);
    sse_encode_sdp_type(self.kind, serializer);
  }

  @protected
  void sse_encode_rtc_stats(RtcStats self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_i_64(self.timestampUs, serializer);
    sse_encode_rtc_stats_type(self.kind, serializer);
  }

  @protected
  void sse_encode_rtc_stats_ice_candidate_pair_state(
      RtcStatsIceCandidatePairState self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_rtc_stats_type(RtcStatsType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case RtcStatsType_RtcMediaSourceStats(
          trackIdentifier: final trackIdentifier,
          kind: final kind
        ):
        sse_encode_i_32(0, serializer);
        sse_encode_opt_String(trackIdentifier, serializer);
        sse_encode_box_autoadd_rtc_media_source_stats_media_type(
            kind, serializer);
      case RtcStatsType_RtcIceCandidateStats(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_rtc_ice_candidate_stats(field0, serializer);
      case RtcStatsType_RtcOutboundRtpStreamStats(
          trackId: final trackId,
          mediaType: final mediaType,
          bytesSent: final bytesSent,
          packetsSent: final packetsSent,
          mediaSourceId: final mediaSourceId
        ):
        sse_encode_i_32(2, serializer);
        sse_encode_opt_String(trackId, serializer);
        sse_encode_box_autoadd_rtc_outbound_rtp_stream_stats_media_type(
            mediaType, serializer);
        sse_encode_opt_box_autoadd_u_64(bytesSent, serializer);
        sse_encode_opt_box_autoadd_u_32(packetsSent, serializer);
        sse_encode_opt_String(mediaSourceId, serializer);
      case RtcStatsType_RtcInboundRtpStreamStats(
          remoteId: final remoteId,
          bytesReceived: final bytesReceived,
          packetsReceived: final packetsReceived,
          packetsLost: final packetsLost,
          jitter: final jitter,
          totalDecodeTime: final totalDecodeTime,
          jitterBufferEmittedCount: final jitterBufferEmittedCount,
          mediaType: final mediaType
        ):
        sse_encode_i_32(3, serializer);
        sse_encode_opt_String(remoteId, serializer);
        sse_encode_opt_box_autoadd_u_64(bytesReceived, serializer);
        sse_encode_opt_box_autoadd_u_32(packetsReceived, serializer);
        sse_encode_opt_box_autoadd_u_64(packetsLost, serializer);
        sse_encode_opt_box_autoadd_f_64(jitter, serializer);
        sse_encode_opt_box_autoadd_f_64(totalDecodeTime, serializer);
        sse_encode_opt_box_autoadd_u_64(jitterBufferEmittedCount, serializer);
        sse_encode_opt_box_autoadd_rtc_inbound_rtp_stream_media_type(
            mediaType, serializer);
      case RtcStatsType_RtcIceCandidatePairStats(
          state: final state,
          nominated: final nominated,
          bytesSent: final bytesSent,
          bytesReceived: final bytesReceived,
          totalRoundTripTime: final totalRoundTripTime,
          currentRoundTripTime: final currentRoundTripTime,
          availableOutgoingBitrate: final availableOutgoingBitrate
        ):
        sse_encode_i_32(4, serializer);
        sse_encode_rtc_stats_ice_candidate_pair_state(state, serializer);
        sse_encode_opt_box_autoadd_bool(nominated, serializer);
        sse_encode_opt_box_autoadd_u_64(bytesSent, serializer);
        sse_encode_opt_box_autoadd_u_64(bytesReceived, serializer);
        sse_encode_opt_box_autoadd_f_64(totalRoundTripTime, serializer);
        sse_encode_opt_box_autoadd_f_64(currentRoundTripTime, serializer);
        sse_encode_opt_box_autoadd_f_64(availableOutgoingBitrate, serializer);
      case RtcStatsType_RtcTransportStats(
          packetsSent: final packetsSent,
          packetsReceived: final packetsReceived,
          bytesSent: final bytesSent,
          bytesReceived: final bytesReceived,
          iceRole: final iceRole
        ):
        sse_encode_i_32(5, serializer);
        sse_encode_opt_box_autoadd_u_64(packetsSent, serializer);
        sse_encode_opt_box_autoadd_u_64(packetsReceived, serializer);
        sse_encode_opt_box_autoadd_u_64(bytesSent, serializer);
        sse_encode_opt_box_autoadd_u_64(bytesReceived, serializer);
        sse_encode_opt_box_autoadd_ice_role(iceRole, serializer);
      case RtcStatsType_RtcRemoteInboundRtpStreamStats(
          localId: final localId,
          jitter: final jitter,
          roundTripTime: final roundTripTime,
          fractionLost: final fractionLost,
          reportsReceived: final reportsReceived,
          roundTripTimeMeasurements: final roundTripTimeMeasurements
        ):
        sse_encode_i_32(6, serializer);
        sse_encode_opt_String(localId, serializer);
        sse_encode_opt_box_autoadd_f_64(jitter, serializer);
        sse_encode_opt_box_autoadd_f_64(roundTripTime, serializer);
        sse_encode_opt_box_autoadd_f_64(fractionLost, serializer);
        sse_encode_opt_box_autoadd_u_64(reportsReceived, serializer);
        sse_encode_opt_box_autoadd_i_32(roundTripTimeMeasurements, serializer);
      case RtcStatsType_RtcRemoteOutboundRtpStreamStats(
          localId: final localId,
          remoteTimestamp: final remoteTimestamp,
          reportsSent: final reportsSent
        ):
        sse_encode_i_32(7, serializer);
        sse_encode_opt_String(localId, serializer);
        sse_encode_opt_box_autoadd_f_64(remoteTimestamp, serializer);
        sse_encode_opt_box_autoadd_u_64(reportsSent, serializer);
      case RtcStatsType_Unimplemented():
        sse_encode_i_32(8, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_rtc_track_event(
      RtcTrackEvent self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_media_stream_track(self.track, serializer);
    sse_encode_rtc_rtp_transceiver(self.transceiver, serializer);
  }

  @protected
  void sse_encode_rtcp_feedback(RtcpFeedback self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_box_autoadd_rtcp_feedback_message_type(
        self.messageType, serializer);
    sse_encode_rtcp_feedback_type(self.kind, serializer);
  }

  @protected
  void sse_encode_rtcp_feedback_message_type(
      RtcpFeedbackMessageType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_rtcp_feedback_type(
      RtcpFeedbackType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_rtp_capabilities(
      RtpCapabilities self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_rtp_codec_capability(self.codecs, serializer);
    sse_encode_list_rtp_header_extension_capability(
        self.headerExtensions, serializer);
  }

  @protected
  void sse_encode_rtp_codec_capability(
      RtpCodecCapability self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_box_autoadd_i_32(self.preferredPayloadType, serializer);
    sse_encode_list_scalability_mode(self.scalabilityModes, serializer);
    sse_encode_String(self.mimeType, serializer);
    sse_encode_String(self.name, serializer);
    sse_encode_media_type(self.kind, serializer);
    sse_encode_opt_box_autoadd_i_32(self.clockRate, serializer);
    sse_encode_opt_box_autoadd_i_32(self.numChannels, serializer);
    sse_encode_list_record_string_string(self.parameters, serializer);
    sse_encode_list_rtcp_feedback(self.feedback, serializer);
  }

  @protected
  void sse_encode_rtp_header_extension_capability(
      RtpHeaderExtensionCapability self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.uri, serializer);
    sse_encode_opt_box_autoadd_i_32(self.preferredId, serializer);
    sse_encode_bool(self.preferredEncrypted, serializer);
    sse_encode_rtp_transceiver_direction(self.direction, serializer);
  }

  @protected
  void sse_encode_rtp_transceiver_direction(
      RtpTransceiverDirection self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_rtp_transceiver_init(
      RtpTransceiverInit self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_rtp_transceiver_direction(self.direction, serializer);
    sse_encode_list_rtc_rtp_encoding_parameters(self.sendEncodings, serializer);
  }

  @protected
  void sse_encode_scalability_mode(
      ScalabilityMode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_sdp_type(SdpType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_signaling_state(
      SignalingState self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_texture_event(TextureEvent self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case TextureEvent_OnTextureChange(
          textureId: final textureId,
          width: final width,
          height: final height,
          rotation: final rotation
        ):
        sse_encode_i_32(0, serializer);
        sse_encode_i_64(textureId, serializer);
        sse_encode_i_32(width, serializer);
        sse_encode_i_32(height, serializer);
        sse_encode_i_32(rotation, serializer);
      case TextureEvent_OnFirstFrameRendered(textureId: final textureId):
        sse_encode_i_32(1, serializer);
        sse_encode_i_64(textureId, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_track_event(TrackEvent self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case TrackEvent_Ended():
        sse_encode_i_32(0, serializer);
      case TrackEvent_AudioLevelUpdated(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_u_32(field0, serializer);
      case TrackEvent_TrackCreated():
        sse_encode_i_32(2, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_track_state(TrackState self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint32(self);
  }

  @protected
  void sse_encode_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_usize(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_video_codec(VideoCodec self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_video_codec_info(
      VideoCodecInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.isHardwareAccelerated, serializer);
    sse_encode_video_codec(self.codec, serializer);
  }

  @protected
  void sse_encode_video_constraints(
      VideoConstraints self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_String(self.deviceId, serializer);
    sse_encode_u_32(self.width, serializer);
    sse_encode_u_32(self.height, serializer);
    sse_encode_u_32(self.frameRate, serializer);
    sse_encode_bool(self.isDisplay, serializer);
  }
}

@sealed
class ArcPeerConnectionImpl extends RustOpaque implements ArcPeerConnection {
  // Not to be used by end users
  ArcPeerConnectionImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  ArcPeerConnectionImpl.frbInternalSseDecode(
      BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_ArcPeerConnection,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_ArcPeerConnection,
    rustArcDecrementStrongCountPtr: RustLib
        .instance.api.rust_arc_decrement_strong_count_ArcPeerConnectionPtr,
  );
}

@sealed
class ArcRtpEncodingParametersImpl extends RustOpaque
    implements ArcRtpEncodingParameters {
  // Not to be used by end users
  ArcRtpEncodingParametersImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  ArcRtpEncodingParametersImpl.frbInternalSseDecode(
      BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: RustLib
        .instance.api.rust_arc_increment_strong_count_ArcRtpEncodingParameters,
    rustArcDecrementStrongCount: RustLib
        .instance.api.rust_arc_decrement_strong_count_ArcRtpEncodingParameters,
    rustArcDecrementStrongCountPtr: RustLib.instance.api
        .rust_arc_decrement_strong_count_ArcRtpEncodingParametersPtr,
  );
}

@sealed
class ArcRtpParametersImpl extends RustOpaque implements ArcRtpParameters {
  // Not to be used by end users
  ArcRtpParametersImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  ArcRtpParametersImpl.frbInternalSseDecode(
      BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_ArcRtpParameters,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_ArcRtpParameters,
    rustArcDecrementStrongCountPtr: RustLib
        .instance.api.rust_arc_decrement_strong_count_ArcRtpParametersPtr,
  );
}

@sealed
class ArcRtpTransceiverImpl extends RustOpaque implements ArcRtpTransceiver {
  // Not to be used by end users
  ArcRtpTransceiverImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  ArcRtpTransceiverImpl.frbInternalSseDecode(
      BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_ArcRtpTransceiver,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_ArcRtpTransceiver,
    rustArcDecrementStrongCountPtr: RustLib
        .instance.api.rust_arc_decrement_strong_count_ArcRtpTransceiverPtr,
  );
}
